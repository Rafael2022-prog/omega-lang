{
  "OMEGA Blockchain Contract": {
    "prefix": "blockchain",
    "body": [
      "blockchain ${1:ContractName} {",
      "\tstate {",
      "\t\t${2:// state variables}",
      "\t}",
      "",
      "\tconstructor(${3:parameters}) {",
      "\t\t${4:// initialization}",
      "\t}",
      "",
      "\tfunction ${5:functionName}(${6:parameters}) public ${7:returns} {",
      "\t\t${8:// function body}",
      "\t}",
      "",
      "\tevent ${9:EventName}(${10:parameters});",
      "}"
    ],
    "description": "Create a new blockchain contract"
  },
  "OMEGA Function": {
    "prefix": "function",
    "body": [
      "function ${1:functionName}(${2:parameters}) ${3:visibility} ${4:returns} {",
      "\t${5:// function body}",
      "}"
    ],
    "description": "Create a new function"
  },
  "OMEGA Constructor": {
    "prefix": "constructor",
    "body": [
      "constructor(${1:parameters}) {",
      "\t${2:// initialization}",
      "}"
    ],
    "description": "Create a constructor"
  },
  "OMEGA Event": {
    "prefix": "event",
    "body": [
      "event ${1:EventName}(${2:parameters});"
    ],
    "description": "Create an event"
  },
  "OMEGA Mapping": {
    "prefix": "mapping",
    "body": [
      "mapping(${1:keyType} => ${2:valueType}) ${3:public} ${4:variableName};"
    ],
    "description": "Create a mapping"
  },
  "OMEGA State Variable": {
    "prefix": "state",
    "body": [
      "${1:type} ${2:public} ${3:variableName};"
    ],
    "description": "Create a state variable"
  },
  "OMEGA ERC20 Token": {
    "prefix": "erc20",
    "body": [
      "blockchain ${1:TokenName} {",
      "\tstate {",
      "\t\tmapping(address => uint256) balances;",
      "\t\tmapping(address => mapping(address => uint256)) allowances;",
      "\t\tuint256 totalSupply;",
      "\t\tstring name;",
      "\t\tstring symbol;",
      "\t\tuint8 decimals;",
      "\t}",
      "",
      "\tconstructor(string memory _name, string memory _symbol, uint256 _totalSupply) {",
      "\t\tname = _name;",
      "\t\tsymbol = _symbol;",
      "\t\ttotalSupply = _totalSupply;",
      "\t\tdecimals = 18;",
      "\t\tbalances[msg.sender] = _totalSupply;",
      "\t}",
      "",
      "\tfunction transfer(address to, uint256 amount) public returns (bool) {",
      "\t\trequire(balances[msg.sender] >= amount, \"Insufficient balance\");",
      "\t\trequire(to != address(0), \"Invalid recipient\");",
      "",
      "\t\tbalances[msg.sender] -= amount;",
      "\t\tbalances[to] += amount;",
      "",
      "\t\temit Transfer(msg.sender, to, amount);",
      "\t\treturn true;",
      "\t}",
      "",
      "\tfunction balanceOf(address account) public view returns (uint256) {",
      "\t\treturn balances[account];",
      "\t}",
      "",
      "\tfunction approve(address spender, uint256 amount) public returns (bool) {",
      "\t\tallowances[msg.sender][spender] = amount;",
      "\t\temit Approval(msg.sender, spender, amount);",
      "\t\treturn true;",
      "\t}",
      "",
      "\tfunction transferFrom(address from, address to, uint256 amount) public returns (bool) {",
      "\t\trequire(balances[from] >= amount, \"Insufficient balance\");",
      "\t\trequire(allowances[from][msg.sender] >= amount, \"Insufficient allowance\");",
      "\t\trequire(to != address(0), \"Invalid recipient\");",
      "",
      "\t\tbalances[from] -= amount;",
      "\t\tbalances[to] += amount;",
      "\t\tallowances[from][msg.sender] -= amount;",
      "",
      "\t\temit Transfer(from, to, amount);",
      "\t\treturn true;",
      "\t}",
      "",
      "\tevent Transfer(address indexed from, address indexed to, uint256 value);",
      "\tevent Approval(address indexed owner, address indexed spender, uint256 value);",
      "}"
    ],
    "description": "Create a complete ERC20 token contract"
  },
  "OMEGA NFT Contract": {
    "prefix": "nft",
    "body": [
      "blockchain ${1:NFTContract} {",
      "\tstate {",
      "\t\tmapping(uint256 => address) tokenOwners;",
      "\t\tmapping(address => uint256) tokenBalances;",
      "\t\tmapping(uint256 => string) tokenURIs;",
      "\t\tuint256 nextTokenId;",
      "\t\tstring name;",
      "\t\tstring symbol;",
      "\t}",
      "",
      "\tconstructor(string memory _name, string memory _symbol) {",
      "\t\tname = _name;",
      "\t\tsymbol = _symbol;",
      "\t\tnextTokenId = 1;",
      "\t}",
      "",
      "\tfunction mint(address to, string memory tokenURI) public returns (uint256) {",
      "\t\tuint256 tokenId = nextTokenId;",
      "\t\ttokenOwners[tokenId] = to;",
      "\t\ttokenBalances[to] += 1;",
      "\t\ttokenURIs[tokenId] = tokenURI;",
      "\t\tnextTokenId += 1;",
      "",
      "\t\temit Transfer(address(0), to, tokenId);",
      "\t\treturn tokenId;",
      "\t}",
      "",
      "\tfunction ownerOf(uint256 tokenId) public view returns (address) {",
      "\t\treturn tokenOwners[tokenId];",
      "\t}",
      "",
      "\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);",
      "}"
    ],
    "description": "Create a basic NFT contract"
  },
  "OMEGA DeFi AMM": {
    "prefix": "amm",
    "body": [
      "blockchain ${1:AMM} {",
      "\tstate {",
      "\t\tmapping(address => uint256) tokenABalances;",
      "\t\tmapping(address => uint256) tokenBBalances;",
      "\t\tuint256 reserveA;",
      "\t\tuint256 reserveB;",
      "\t\tuint256 totalLiquidity;",
      "\t\tmapping(address => uint256) liquidityBalances;",
      "\t}",
      "",
      "\tfunction addLiquidity(uint256 amountA, uint256 amountB) public returns (uint256) {",
      "\t\tuint256 liquidity;",
      "\t\tif (totalLiquidity == 0) {",
      "\t\t\tliquidity = sqrt(amountA * amountB);",
      "\t\t} else {",
      "\t\t\tliquidity = min(amountA * totalLiquidity / reserveA, amountB * totalLiquidity / reserveB);",
      "\t\t}",
      "",
      "\t\ttokenABalances[msg.sender] += amountA;",
      "\t\ttokenBBalances[msg.sender] += amountB;",
      "\t\treserveA += amountA;",
      "\t\treserveB += amountB;",
      "\t\ttotalLiquidity += liquidity;",
      "\t\tliquidityBalances[msg.sender] += liquidity;",
      "",
      "\t\temit LiquidityAdded(msg.sender, amountA, amountB, liquidity);",
      "\t\treturn liquidity;",
      "\t}",
      "",
      "\tfunction swapAForB(uint256 amountAIn) public returns (uint256) {",
      "\t\tuint256 amountBOut = getAmountOut(amountAIn, reserveA, reserveB);",
      "\t\trequire(amountBOut > 0, \"Insufficient output amount\");",
      "\t\trequire(amountBOut <= reserveB, \"Insufficient liquidity\");",
      "",
      "\t\ttokenABalances[msg.sender] += amountAIn;",
      "\t\ttokenBBalances[msg.sender] -= amountBOut;",
      "\t\treserveA += amountAIn;",
      "\t\treserveB -= amountBOut;",
      "",
      "\t\temit Swap(msg.sender, amountAIn, 0, 0, amountBOut);",
      "\t\treturn amountBOut;",
      "\t}",
      "",
      "\tfunction getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) private pure returns (uint256) {",
      "\t\tuint256 amountInWithFee = amountIn * 997;",
      "\t\tuint256 numerator = amountInWithFee * reserveOut;",
      "\t\tuint256 denominator = reserveIn * 1000 + amountInWithFee;",
      "\t\treturn numerator / denominator;",
      "\t}",
      "",
      "\tfunction sqrt(uint256 x) private pure returns (uint256) {",
      "\t\tif (x == 0) return 0;",
      "\t\tuint256 z = (x + 1) / 2;",
      "\t\tuint256 y = x;",
      "\t\twhile (z < y) {",
      "\t\t\ty = z;",
      "\t\t\tz = (x / z + z) / 2;",
      "\t\t}",
      "\t\treturn y;",
      "\t}",
      "",
      "\tfunction min(uint256 a, uint256 b) private pure returns (uint256) {",
      "\t\treturn a < b ? a : b;",
      "\t}",
      "",
      "\tevent LiquidityAdded(address indexed provider, uint256 amountA, uint256 amountB, uint256 liquidity);",
      "\tevent Swap(address indexed sender, uint256 amountAIn, uint256 amountBIn, uint256 amountAOut, uint256 amountBOut);",
      "}"
    ],
    "description": "Create an Automated Market Maker (AMM) contract"
  },
  "OMEGA Cross-Chain Bridge": {
    "prefix": "bridge",
    "body": [
      "blockchain ${1:CrossChainBridge} {",
      "\tstate {",
      "\t\tmapping(bytes32 => bool) processedTransactions;",
      "\t\tmapping(address => uint256) lockedBalances;",
      "\t\taddress relayer;",
      "\t\tuint256 chainId;",
      "\t}",
      "",
      "\tconstructor(address _relayer, uint256 _chainId) {",
      "\t\trelayer = _relayer;",
      "\t\tchainId = _chainId;",
      "\t}",
      "",
      "\tmodifier onlyRelayer() {",
      "\t\trequire(msg.sender == relayer, \"Only relayer can call\");",
      "\t\t_;",
      "\t}",
      "",
      "\tfunction lockAndBridge(address token, uint256 amount, uint256 targetChain, bytes32 recipient) public {",
      "\t\trequire(amount > 0, \"Invalid amount\");",
      "\t\trequire(targetChain != chainId, \"Invalid target chain\");",
      "",
      "\t\t// Lock tokens",
      "\t\tlockedBalances[msg.sender] += amount;",
      "",
      "\t\t// Emit bridge event",
      "\t\temit TokensLocked(msg.sender, recipient, amount, token, chainId, targetChain);",
      "\t}",
      "",
      "\tfunction unlockAndRelease(bytes32 transactionId, address recipient, uint256 amount, address token, bytes memory signature) public onlyRelayer {",
      "\t\trequire(!processedTransactions[transactionId], \"Transaction already processed\");",
      "\t\trequire(_verifySignature(transactionId, recipient, amount, token, signature), \"Invalid signature\");",
      "",
      "\t\tprocessedTransactions[transactionId] = true;",
      "\t\tlockedBalances[recipient] -= amount;",
      "",
      "\t\temit TokensReleased(recipient, amount, token, transactionId);",
      "\t}",
      "",
      "\tfunction _verifySignature(bytes32 transactionId, address recipient, uint256 amount, address token, bytes memory signature) private pure returns (bool) {",
      "\t\t// Implement signature verification logic",
      "\t\treturn true; // Simplified for snippet",
      "\t}",
      "",
      "\tevent TokensLocked(address indexed from, bytes32 indexed recipient, uint256 amount, address token, uint256 fromChain, uint256 toChain);",
      "\tevent TokensReleased(address indexed recipient, uint256 amount, address token, bytes32 transactionId);",
      "}"
    ],
    "description": "Create a cross-chain bridge contract"
  },
  "OMEGA Governance DAO": {
    "prefix": "dao",
    "body": [
      "blockchain ${1:GovernanceDAO} {",
      "\tstate {",
      "\t\tmapping(address => uint256) votingPower;",
      "\t\tmapping(uint256 => Proposal) proposals;",
      "\t\tuint256 nextProposalId;",
      "\t\tuint256 minimumVotingPower;",
      "\t\tuint256 votingPeriod;",
      "\t}",
      "",
      "\tstruct Proposal {",
      "\t\tstring description;",
      "\t\tuint256 forVotes;",
      "\t\tuint256 againstVotes;",
      "\t\tuint256 startTime;",
      "\t\tuint256 endTime;",
      "\t\tbool executed;",
      "\t\tmapping(address => bool) hasVoted;",
      "\t}",
      "",
      "\tconstructor(uint256 _minimumVotingPower, uint256 _votingPeriod) {",
      "\t\tminimumVotingPower = _minimumVotingPower;",
      "\t\tvotingPeriod = _votingPeriod;",
      "\t}",
      "",
      "\tfunction createProposal(string memory description) public returns (uint256) {",
      "\t\trequire(votingPower[msg.sender] >= minimumVotingPower, \"Insufficient voting power\");",
      "",
      "\t\tuint256 proposalId = nextProposalId;",
      "\t\tproposals[proposalId] = Proposal({",
      "\t\t\tdescription: description,",
      "\t\t\tforVotes: 0,",
      "\t\t\tagainstVotes: 0,",
      "\t\t\tstartTime: block.timestamp,",
      "\t\t\tendTime: block.timestamp + votingPeriod,",
      "\t\t\texecuted: false",
      "\t\t});",
      "",
      "\t\tnextProposalId += 1;",
      "\t\temit ProposalCreated(proposalId, msg.sender, description);",
      "\t\treturn proposalId;",
      "\t}",
      "",
      "\tfunction vote(uint256 proposalId, bool support) public {",
      "\t\trequire(votingPower[msg.sender] > 0, \"No voting power\");",
      "\t\trequire(!proposals[proposalId].hasVoted[msg.sender], \"Already voted\");",
      "\t\trequire(block.timestamp >= proposals[proposalId].startTime, \"Voting not started\");",
      "\t\trequire(block.timestamp <= proposals[proposalId].endTime, \"Voting ended\");",
      "",
      "\t\tproposals[proposalId].hasVoted[msg.sender] = true;",
      "",
      "\t\tif (support) {",
      "\t\t\tproposals[proposalId].forVotes += votingPower[msg.sender];",
      "\t\t} else {",
      "\t\t\tproposals[proposalId].againstVotes += votingPower[msg.sender];",
      "\t\t}",
      "",
      "\t\temit VoteCast(msg.sender, proposalId, support, votingPower[msg.sender]);",
      "\t}",
      "",
      "\tfunction executeProposal(uint256 proposalId) public {",
      "\t\tProposal storage proposal = proposals[proposalId];",
      "\t\trequire(!proposal.executed, \"Already executed\");",
      "\t\trequire(block.timestamp > proposal.endTime, \"Voting not ended\");",
      "\t\trequire(proposal.forVotes > proposal.againstVotes, \"Proposal rejected\");",
      "",
      "\t\tproposal.executed = true;",
      "\t\temit ProposalExecuted(proposalId);",
      "\t}",
      "",
      "\tevent ProposalCreated(uint256 indexed proposalId, address indexed proposer, string description);",
      "\tevent VoteCast(address indexed voter, uint256 indexed proposalId, bool support, uint256 votes);",
      "\tevent ProposalExecuted(uint256 indexed proposalId);",
      "}"
    ],
    "description": "Create a governance DAO contract"
  },
  "OMEGA Staking Contract": {
    "prefix": "staking",
    "body": [
      "blockchain ${1:StakingContract} {",
      "\tstate {",
      "\t\tmapping(address => uint256) stakedAmount;",
      "\t\tmapping(address => uint256) stakingStartTime;",
      "\t\tmapping(address => uint256) rewards;",
      "\t\tuint256 totalStaked;",
      "\t\tuint256 rewardRate; // per second",
      "\t\taddress stakingToken;",
      "\t\taddress rewardToken;",
      "\t}",
      "",
      "\tconstructor(address _stakingToken, address _rewardToken, uint256 _rewardRate) {",
      "\t\tstakingToken = _stakingToken;",
      "\t\trewardToken = _rewardToken;",
      "\t\trewardRate = _rewardRate;",
      "\t}",
      "",
      "\tfunction stake(uint256 amount) public {",
      "\t\trequire(amount > 0, \"Cannot stake 0\");",
      "",
      "\t\t_updateRewards(msg.sender);",
      "",
      "\t\tstakedAmount[msg.sender] += amount;",
      "\t\tstakingStartTime[msg.sender] = block.timestamp;",
      "\t\ttotalStaked += amount;",
      "",
      "\t\t// Transfer tokens from user",
      "\t\t_transferFrom(stakingToken, msg.sender, address(this), amount);",
      "",
      "\t\temit Staked(msg.sender, amount);",
      "\t}",
      "",
      "\tfunction unstake(uint256 amount) public {",
      "\t\trequire(stakedAmount[msg.sender] >= amount, \"Insufficient stake\");",
      "",
      "\t\t_updateRewards(msg.sender);",
      "",
      "\t\tstakedAmount[msg.sender] -= amount;",
      "\t\ttotalStaked -= amount;",
      "",
      "\t\t// Transfer tokens back to user",
      "\t\t_transfer(stakingToken, msg.sender, amount);",
      "",
      "\t\temit Unstaked(msg.sender, amount);",
      "\t}",
      "",
      "\tfunction claimRewards() public {",
      "\t\t_updateRewards(msg.sender);",
      "",
      "\t\tuint256 reward = rewards[msg.sender];",
      "\t\trequire(reward > 0, \"No rewards to claim\");",
      "",
      "\t\trewards[msg.sender] = 0;",
      "\t\t_transfer(rewardToken, msg.sender, reward);",
      "",
      "\t\temit RewardsClaimed(msg.sender, reward);",
      "\t}",
      "",
      "\tfunction _updateRewards(address account) private {",
      "\t\tif (stakedAmount[account] > 0) {",
      "\t\t\tuint256 timeStaked = block.timestamp - stakingStartTime[account];",
      "\t\t\tuint256 reward = stakedAmount[account] * rewardRate * timeStaked / 1e18;",
      "\t\t\trewards[account] += reward;",
      "\t\t\tstakingStartTime[account] = block.timestamp;",
      "\t\t}",
      "\t}",
      "",
      "\tfunction _transferFrom(address token, address from, address to, uint256 amount) private {",
      "\t\t// Implement token transfer from logic",
      "\t}",
      "",
      "\tfunction _transfer(address token, address to, uint256 amount) private {",
      "\t\t// Implement token transfer logic",
      "\t}",
      "",
      "\tevent Staked(address indexed user, uint256 amount);",
      "\tevent Unstaked(address indexed user, uint256 amount);",
      "\tevent RewardsClaimed(address indexed user, uint256 amount);",
      "}"
    ],
    "description": "Create a staking contract with rewards"
  },
  "OMEGA Oracle Contract": {
    "prefix": "oracle",
    "body": [
      "blockchain ${1:PriceOracle} {",
      "\tstate {",
      "\t\tmapping(string => uint256) prices; // asset => price",
      "\t\tmapping(address => bool) authorizedProviders;",
      "\t\tuint256 lastUpdateTime;",
      "\t\tuint256 updateInterval;",
      "\t}",
      "",
      "\tconstructor(uint256 _updateInterval) {",
      "\t\tupdateInterval = _updateInterval;",
      "\t\tauthorizedProviders[msg.sender] = true;",
      "\t}",
      "",
      "\tmodifier onlyAuthorizedProvider() {",
      "\t\trequire(authorizedProviders[msg.sender], \"Not authorized provider\");",
      "\t\t_;",
      "\t}",
      "",
      "\tfunction updatePrice(string memory asset, uint256 price) public onlyAuthorizedProvider {",
      "\t\tprices[asset] = price;",
      "\t\tlastUpdateTime = block.timestamp;",
      "\t\temit PriceUpdated(asset, price, msg.sender);",
      "\t}",
      "",
      "\tfunction getPrice(string memory asset) public view returns (uint256) {",
      "\t\trequire(block.timestamp - lastUpdateTime <= updateInterval, \"Price data too old\");",
      "\t\treturn prices[asset];",
      "\t}",
      "",
      "\tfunction addAuthorizedProvider(address provider) public {",
      "\t\trequire(authorizedProviders[msg.sender], \"Not authorized\");",
      "\t\tauthorizedProviders[provider] = true;",
      "\t\temit ProviderAdded(provider);",
      "\t}",
      "",
      "\tfunction removeAuthorizedProvider(address provider) public {",
      "\t\trequire(authorizedProviders[msg.sender], \"Not authorized\");",
      "\t\tauthorizedProviders[provider] = false;",
      "\t\temit ProviderRemoved(provider);",
      "\t}",
      "",
      "\tevent PriceUpdated(string indexed asset, uint256 price, address indexed provider);",
      "\tevent ProviderAdded(address indexed provider);",
      "\tevent ProviderRemoved(address indexed provider);",
      "}"
    ],
    "description": "Create a price oracle contract"
  },
  "OMEGA Reentrancy Guard": {
    "prefix": "reentrancy",
    "body": [
      "blockchain ${1:SecureContract} {",
      "\tstate {",
      "\t\tbool private locked;",
      "\t\t${2:// other state variables}",
      "\t}",
      "",
      "\tmodifier nonReentrant() {",
      "\t\trequire(!locked, \"ReentrancyGuard: reentrant call\");",
      "\t\tlocked = true;",
      "\t\t_;",
      "\t\tlocked = false;",
      "\t}",
      "",
      "\tfunction ${2:vulnerableFunction}() public nonReentrant {",
      "\t\t${3:// function implementation}",
      "\t}",
      "}"
    ],
    "description": "Add reentrancy protection to contract"
  },
  "OMEGA Access Control": {
    "prefix": "access",
    "body": [
      "blockchain ${1:AccessControlled} {",
      "\tstate {",
      "\t\tmapping(address => bool) owners;",
      "\t\tmapping(address => mapping(bytes4 => bool)) functionPermissions;",
      "\t}",
      "",
      "\tconstructor() {",
      "\t\towners[msg.sender] = true;",
      "\t}",
      "",
      "\tmodifier onlyOwner() {",
      "\t\trequire(owners[msg.sender], \"Not owner\");",
      "\t\t_;",
      "\t}",
      "",
      "\tmodifier hasPermission(bytes4 functionSelector) {",
      "\t\trequire(functionPermissions[msg.sender][functionSelector], \"No permission\");",
      "\t\t_;",
      "\t}",
      "",
      "\tfunction addOwner(address newOwner) public onlyOwner {",
      "\t\towners[newOwner] = true;",
      "\t\temit OwnerAdded(newOwner);",
      "\t}",
      "",
      "\tfunction removeOwner(address owner) public onlyOwner {",
      "\t\towners[owner] = false;",
      "\t\temit OwnerRemoved(owner);",
      "\t}",
      "",
      "\tfunction grantPermission(address user, bytes4 functionSelector) public onlyOwner {",
      "\t\tfunctionPermissions[user][functionSelector] = true;",
      "\t\temit PermissionGranted(user, functionSelector);",
      "\t}",
      "",
      "\tfunction revokePermission(address user, bytes4 functionSelector) public onlyOwner {",
      "\t\tfunctionPermissions[user][functionSelector] = false;",
      "\t\temit PermissionRevoked(user, functionSelector);",
      "\t}",
      "",
      "\tevent OwnerAdded(address indexed newOwner);",
      "\tevent OwnerRemoved(address indexed removedOwner);",
      "\tevent PermissionGranted(address indexed user, bytes4 indexed functionSelector);",
      "\tevent PermissionRevoked(address indexed user, bytes4 indexed functionSelector);",
      "}"
    ],
    "description": "Add access control to contract"
  },
  "OMEGA Pausable Contract": {
    "prefix": "pausable",
    "body": [
      "blockchain ${1:PausableContract} {",
      "\tstate {",
      "\t\tbool paused;",
      "\t\t${2:// other state variables}",
      "\t}",
      "",
      "\tmodifier whenNotPaused() {",
      "\t\trequire(!paused, \"Contract is paused\");",
      "\t\t_;",
      "\t}",
      "",
      "\tmodifier whenPaused() {",
      "\t\trequire(paused, \"Contract is not paused\");",
      "\t\t_;",
      "\t}",
      "",
      "\tfunction pause() public {",
      "\t\tpaused = true;",
      "\t\temit Paused(msg.sender);",
      "\t}",
      "",
      "\tfunction unpause() public {",
      "\t\tpaused = false;",
      "\t\temit Unpaused(msg.sender);",
      "\t}",
      "",
      "\tfunction ${2:pausableFunction}() public whenNotPaused {",
      "\t\t${3:// function implementation}",
      "\t}",
      "",
      "\tevent Paused(address indexed account);",
      "\tevent Unpaused(address indexed account);",
      "}"
    ],
    "description": "Add pause functionality to contract"
  }
}
// OMEGA Intermediate Representation (OIR) - Self-hosted implementation in MEGA
// Replaces the Rust-based IR with native MEGA code

import "./parser.mega" as Parser;
import "./semantic/analyzer.mega" as Semantic;
import "./error/error.mega";

/// Blockchain utama untuk mengelola Intermediate Representation (IR) OMEGA
/// Mengonversi AST yang telah dianalisis menjadi IR yang dapat dioptimasi
blockchain OmegaIR {
    state {
        IRModule[] modules;                              // Daftar modul IR yang dihasilkan
        IRMetadata metadata;                             // Metadata untuk IR generation
        OptimizationLevel optimization_level;            // Level optimasi yang digunakan
        TargetPlatform[] target_platforms;               // Platform target untuk code generation
        mapping(string => IRModule) module_map;          // Mapping nama modul ke IRModule
        OmegaErrorHandler error_handler;                 // Integrated error handling system
        string current_file;                             // Current file being processed
        uint256 error_count;                             // Count of IR generation errors
    }
    
    /// Konstruktor untuk inisialisasi default IR generator
    constructor() {
        optimization_level = OptimizationLevel.O2;       // Default ke optimasi level 2
        target_platforms = [TargetPlatform.EVM, TargetPlatform.Solana];  // Support EVM dan Solana
        error_handler = OmegaErrorHandler::new();         // Initialize error handler
        current_file = "";                                // Initialize current file
        error_count = 0;                                  // Initialize error count
    }
    
    /// Fungsi utama untuk menghasilkan IR dari program yang telah dianalisis
    /// @param program Program AST yang akan dikonversi ke IR
    /// @param analysis Hasil analisis semantik dari program
    /// @return OmegaIRResult berisi IR modules dan metadata
    function generate_ir(Program memory program, AnalysisResult memory analysis) 
        public returns (OmegaIRResult memory) {
        
        // Initialize IR generation context dengan informasi dari analisis
        IRContext memory context = IRContext({
            current_module: "",                          // Modul yang sedang diproses
            current_blockchain: "",                      // Blockchain yang sedang diproses
            current_function: "",                        // Function yang sedang diproses
            symbol_table: analysis.symbol_table,        // Symbol table dari semantic analysis
            type_environment: analysis.type_environment, // Type environment dari semantic analysis
            temp_counter: 0,                            // Counter untuk temporary variables
            label_counter: 0                            // Counter untuk labels dalam control flow
        });
        
        // Generate IR untuk setiap item dalam program
        for (uint256 i = 0; i < program.items.length; i++) {
            Item memory item = program.items[i];
            
            // Dispatch ke function yang sesuai berdasarkan tipe item
            if (item.item_type == ItemType.Import) {
                generate_import_ir(item.import_item, context);
            } else if (item.item_type == ItemType.Blockchain) {
                generate_blockchain_ir(item.blockchain_item, context);
            } else if (item.item_type == ItemType.Struct) {
                generate_struct_ir(item.struct_item, context);
            } else if (item.item_type == ItemType.Enum) {
                generate_enum_ir(item.enum_item, context);
            } else if (item.item_type == ItemType.Function) {
                generate_function_ir(item.function_item, context);
            } else if (item.item_type == ItemType.Constant) {
                generate_constant_ir(item.constant_item, context);
            }
        }
        
        // Set metadata untuk IR yang dihasilkan
        metadata = IRMetadata({
            target_platforms: target_platforms,          // Platform target yang didukung
            optimization_level: optimization_level,      // Level optimasi yang digunakan
            debug_info: true,                           // Include debug information
            source_file: program.source_file,           // File sumber asli
            compiler_version: "1.0.0",                  // Versi compiler OMEGA
            generation_timestamp: block.timestamp       // Timestamp generation
        });
        
        return OmegaIRResult({
            modules: modules,                           // Semua modul IR yang dihasilkan
            metadata: metadata,                         // Metadata IR
            success: true,                              // Status keberhasilan
            errors: new string[](0)                     // Daftar error (kosong jika sukses)
        });
    }
    
    /// Generate IR untuk import statement
    /// @param import_item Import AST node untuk dikonversi
    /// @param context Context IR generation
    function generate_import_ir(Import memory import_item, IRContext memory context) private {
        ImportIR memory import_ir = ImportIR({
            module_path: import_item.path,              // Path ke modul yang diimport
            alias: import_item.has_alias ? import_item.alias : "",  // Alias jika ada
            has_alias: import_item.has_alias,           // Flag apakah ada alias
            is_wildcard: import_item.is_wildcard,       // Flag apakah wildcard import
            specific_items: import_item.specific_items  // Item spesifik yang diimport
        });
        
        // Tambahkan import ke modul saat ini
        get_current_module(context).imports.push(import_ir);
    }
    
    /// Generate IR untuk blockchain definition
    /// @param blockchain Blockchain AST node untuk dikonversi
    /// @param context Context IR generation
    function generate_blockchain_ir(Blockchain memory blockchain, IRContext memory context) private {
        context.current_blockchain = blockchain.name;   // Set current blockchain context
        
        // Create new module untuk blockchain ini
        IRModule memory blockchain_module = IRModule({
            name: blockchain.name,                      // Nama modul sama dengan nama blockchain
            module_type: ModuleType.Blockchain,         // Tipe modul adalah blockchain
            imports: new ImportIR[](0),                 // Array imports (akan diisi kemudian)
            blockchains: new BlockchainIR[](1),         // Array berisi satu blockchain
            structs: new StructIR[](0),                 // Array structs (kosong untuk blockchain module)
            enums: new EnumIR[](0),                     // Array enums (kosong untuk blockchain module)
            functions: new FunctionIR[](0),             // Array functions (kosong untuk blockchain module)
            constants: new ConstantIR[](0)              // Array constants (kosong untuk blockchain module)
        });
        
        // Generate blockchain IR dengan semua komponennya
        BlockchainIR memory blockchain_ir = BlockchainIR({
            name: blockchain.name,                      // Nama blockchain
            annotations: convert_annotations(blockchain.annotations),  // Konversi anotasi
            state_variables: new StateVariableIR[](0),  // Array state variables (akan diisi)
            events: new EventIR[](blockchain.events.length),  // Array events
            functions: new FunctionIR[](blockchain.functions.length),  // Array functions
            modifiers: new ModifierIR[](blockchain.modifiers.length),  // Array modifiers
            constructor: FunctionIR({                   // Default constructor IR
                name: "constructor",
                parameters: new ParameterIR[](0),
                return_type: TypeIR({ type_kind: IRTypeKind.Void }),
                has_return_type: false,
                visibility: VisibilityIR.Public,
                mutability: MutabilityIR.NonPayable,
                modifiers: new string[](0),
                body: BlockIR({ statements: new StatementIR[](0) }),
                is_constructor: true,
                annotations: new AnnotationIR[](0)
            }),
            has_constructor: false                      // Flag apakah ada constructor eksplisit
        });
        
        // Generate state variables jika ada state block
        if (blockchain.has_state_block) {
            blockchain_ir.state_variables = new StateVariableIR[](blockchain.state_block.variables.length);
            
            for (uint256 i = 0; i < blockchain.state_block.variables.length; i++) {
                blockchain_ir.state_variables[i] = generate_state_variable_ir(
                    blockchain.state_block.variables[i], 
                    context
                );
            }
        }
        
        // Generate IR untuk semua events
        for (uint256 i = 0; i < blockchain.events.length; i++) {
            blockchain_ir.events[i] = generate_event_ir(blockchain.events[i], context);
        }
        
        // Generate IR untuk semua functions
        for (uint256 i = 0; i < blockchain.functions.length; i++) {
            Function memory func = blockchain.functions[i];
            blockchain_ir.functions[i] = generate_function_ir(func, context);
            
            // Set constructor jika function adalah constructor
            if (func.is_constructor) {
                blockchain_ir.constructor = blockchain_ir.functions[i];
                blockchain_ir.has_constructor = true;
            }
        }
        
        // Generate IR untuk semua modifiers
        for (uint256 i = 0; i < blockchain.modifiers.length; i++) {
            blockchain_ir.modifiers[i] = generate_modifier_ir(blockchain.modifiers[i], context);
        }
        
        // Simpan blockchain IR ke module dan daftarkan
        blockchain_module.blockchains[0] = blockchain_ir;
        modules.push(blockchain_module);
        module_map[blockchain.name] = blockchain_module;
        
        context.current_blockchain = "";                // Reset current blockchain context
    }
    
    /// Generate IR untuk state variable
    /// @param var StateVariable AST node untuk dikonversi
    /// @param context Context IR generation
    /// @return StateVariableIR yang dihasilkan
    function generate_state_variable_ir(StateVariable memory var, IRContext memory context) 
        private returns (StateVariableIR memory) {
        
        StateVariableIR memory var_ir = StateVariableIR({
            name: var.name,                             // Nama variable
            var_type: convert_type_to_ir(var.var_type), // Konversi tipe ke IR
            visibility: convert_visibility_to_ir(var.visibility),  // Konversi visibility ke IR
            is_constant: var.is_constant,               // Flag apakah constant
            is_immutable: var.is_immutable,             // Flag apakah immutable
            has_initial_value: var.has_initial_value,   // Flag apakah ada initial value
            initial_value: ExpressionIR({               // Default initial value (null)
                expr_type: IRExpressionType.Literal,
                literal: ValueIR({ value_type: IRValueType.Null })
            }),
            annotations: convert_annotations(var.annotations)  // Konversi anotasi
        });
        
        // Generate IR untuk initial value jika ada
        if (var.has_initial_value) {
            var_ir.initial_value = generate_expression_ir(var.initial_value, context);
        }
        
        return var_ir;
    }
    
    /// Generate IR untuk event definition
    /// @param event Event AST node untuk dikonversi
    /// @param context Context IR generation
    /// @return EventIR yang dihasilkan
    function generate_event_ir(Event memory event, IRContext memory context) 
        private returns (EventIR memory) {
        
        EventIR memory event_ir = EventIR({
            name: event.name,                           // Nama event
            parameters: new ParameterIR[](event.parameters.length),  // Array parameters
            annotations: convert_annotations(event.annotations)  // Konversi anotasi
        });
        
        // Generate IR untuk semua parameters event
        for (uint256 i = 0; i < event.parameters.length; i++) {
            event_ir.parameters[i] = generate_parameter_ir(event.parameters[i], context);
        }
        
        return event_ir;
    }

    function generate_function_ir(Function memory func, IRContext memory context) 
        private returns (FunctionIR memory) {
        
        context.current_function = func.name;
        
        FunctionIR memory func_ir = FunctionIR({
            name: func.name,
            parameters: new ParameterIR[](func.parameters.length),
            return_type: convert_type_to_ir(func.return_type),
            has_return_type: func.has_return_type,
            visibility: convert_visibility_to_ir(func.visibility),
            mutability: convert_mutability_to_ir(func.mutability),
            modifiers: new string[](func.modifiers.length),
            body: generate_block_ir(func.body, context),
            is_constructor: func.is_constructor,
            annotations: convert_annotations(func.annotations)
        });
        
        // Generate parameters
        for (uint256 i = 0; i < func.parameters.length; i++) {
            func_ir.parameters[i] = generate_parameter_ir(func.parameters[i], context);
        }
        
        // Copy modifier names
        for (uint256 i = 0; i < func.modifiers.length; i++) {
            func_ir.modifiers[i] = func.modifiers[i];
        }
        
        context.current_function = "";
        return func_ir;
    }
    
    function generate_modifier_ir(Modifier memory modifier, IRContext memory context) 
        private returns (ModifierIR memory) {
        
        ModifierIR memory modifier_ir = ModifierIR({
            name: modifier.name,
            parameters: new ParameterIR[](modifier.parameters.length),
            body: generate_block_ir(modifier.body, context),
            annotations: convert_annotations(modifier.annotations)
        });
        
        for (uint256 i = 0; i < modifier.parameters.length; i++) {
            modifier_ir.parameters[i] = generate_parameter_ir(modifier.parameters[i], context);
        }
        
        return modifier_ir;
    }
    
    function generate_parameter_ir(Parameter memory param, IRContext memory context) 
        private returns (ParameterIR memory) {
        
        return ParameterIR({
            name: param.name,
            param_type: convert_type_to_ir(param.param_type),
            is_indexed: param.is_indexed,
            annotations: convert_annotations(param.annotations)
        });
    }
    
    function generate_struct_ir(Struct memory struct_def, IRContext memory context) private {
        StructIR memory struct_ir = StructIR({
            name: struct_def.name,
            fields: new StructFieldIR[](struct_def.fields.length),
            annotations: convert_annotations(struct_def.annotations)
        });
        
        for (uint256 i = 0; i < struct_def.fields.length; i++) {
            struct_ir.fields[i] = StructFieldIR({
                name: struct_def.fields[i].name,
                field_type: convert_type_to_ir(struct_def.fields[i].field_type),
                visibility: convert_visibility_to_ir(struct_def.fields[i].visibility),
                annotations: convert_annotations(struct_def.fields[i].annotations)
            });
        }
        
        get_current_module(context).structs.push(struct_ir);
    }
    
    function generate_enum_ir(Enum memory enum_def, IRContext memory context) private {
        EnumIR memory enum_ir = EnumIR({
            name: enum_def.name,
            variants: new EnumVariantIR[](enum_def.variants.length),
            annotations: convert_annotations(enum_def.annotations)
        });
        
        for (uint256 i = 0; i < enum_def.variants.length; i++) {
            enum_ir.variants[i] = EnumVariantIR({
                name: enum_def.variants[i].name,
                has_value: enum_def.variants[i].has_value,
                value: enum_def.variants[i].has_value ? 
                    generate_expression_ir(enum_def.variants[i].value, context) :
                    ExpressionIR({
                        expr_type: IRExpressionType.Literal,
                        literal: ValueIR({ value_type: IRValueType.Null })
                    }),
                annotations: convert_annotations(enum_def.variants[i].annotations)
            });
        }
        
        get_current_module(context).enums.push(enum_ir);
    }
    
    function generate_constant_ir(Constant memory constant, IRContext memory context) private {
        ConstantIR memory const_ir = ConstantIR({
            name: constant.name,
            const_type: convert_type_to_ir(constant.const_type),
            value: generate_expression_ir(constant.value, context),
            annotations: convert_annotations(constant.annotations)
        });
        
        get_current_module(context).constants.push(const_ir);
    }
    
    function generate_block_ir(Block memory block, IRContext memory context) 
        private returns (BlockIR memory) {
        
        BlockIR memory block_ir = BlockIR({
            statements: new StatementIR[](block.statements.length)
        });
        
        for (uint256 i = 0; i < block.statements.length; i++) {
            block_ir.statements[i] = generate_statement_ir(block.statements[i], context);
        }
        
        return block_ir;
    }
    
    function generate_statement_ir(Statement memory stmt, IRContext memory context) 
        private returns (StatementIR memory) {
        
        if (stmt.stmt_type == StatementType.VariableDeclaration) {
            return generate_variable_declaration_ir(stmt, context);
        } else if (stmt.stmt_type == StatementType.Expression) {
            return StatementIR({
                stmt_type: IRStatementType.Expression,
                expression: generate_expression_ir(stmt.expression, context)
            });
        } else if (stmt.stmt_type == StatementType.If) {
            return generate_if_statement_ir(stmt, context);
        } else if (stmt.stmt_type == StatementType.While) {
            return generate_while_statement_ir(stmt, context);
        } else if (stmt.stmt_type == StatementType.For) {
            return generate_for_statement_ir(stmt, context);
        } else if (stmt.stmt_type == StatementType.Return) {
            return generate_return_statement_ir(stmt, context);
        } else if (stmt.stmt_type == StatementType.Emit) {
            return generate_emit_statement_ir(stmt, context);
        } else if (stmt.stmt_type == StatementType.Require) {
            return generate_require_statement_ir(stmt, context);
        } else if (stmt.stmt_type == StatementType.Assert) {
            return generate_assert_statement_ir(stmt, context);
        } else if (stmt.stmt_type == StatementType.Revert) {
            return generate_revert_statement_ir(stmt, context);
        } else if (stmt.stmt_type == StatementType.Block) {
            return StatementIR({
                stmt_type: IRStatementType.Block,
                block: generate_block_ir(stmt.block, context)
            });
        } else {
            // Unknown statement type
            return StatementIR({
                stmt_type: IRStatementType.Expression,
                expression: ExpressionIR({
                    expr_type: IRExpressionType.Literal,
                    literal: ValueIR({ value_type: IRValueType.Null })
                })
            });
        }
    }
    
    function generate_variable_declaration_ir(Statement memory stmt, IRContext memory context) 
        private returns (StatementIR memory) {
        
        StatementIR memory var_decl_ir = StatementIR({
            stmt_type: IRStatementType.VariableDeclaration,
            var_name: stmt.var_name,
            var_type: convert_type_to_ir(stmt.var_type),
            has_initializer: stmt.has_initializer,
            initializer: ExpressionIR({
                expr_type: IRExpressionType.Literal,
                literal: ValueIR({ value_type: IRValueType.Null })
            })
        });
        
        if (stmt.has_initializer) {
            var_decl_ir.initializer = generate_expression_ir(stmt.initializer, context);
        }
        
        return var_decl_ir;
    }
    
    function generate_if_statement_ir(Statement memory stmt, IRContext memory context) 
        private returns (StatementIR memory) {
        
        StatementIR memory if_ir = StatementIR({
            stmt_type: IRStatementType.If,
            condition: generate_expression_ir(stmt.condition, context),
            then_branch: generate_statement_ir(stmt.then_branch, context),
            has_else_branch: stmt.has_else_branch,
            else_branch: StatementIR({
                stmt_type: IRStatementType.Expression,
                expression: ExpressionIR({
                    expr_type: IRExpressionType.Literal,
                    literal: ValueIR({ value_type: IRValueType.Null })
                })
            })
        });
        
        if (stmt.has_else_branch) {
            if_ir.else_branch = generate_statement_ir(stmt.else_branch, context);
        }
        
        return if_ir;
    }
    
    function generate_while_statement_ir(Statement memory stmt, IRContext memory context) 
        private returns (StatementIR memory) {
        
        return StatementIR({
            stmt_type: IRStatementType.While,
            condition: generate_expression_ir(stmt.condition, context),
            body: generate_statement_ir(stmt.body, context)
        });
    }
    
    function generate_for_statement_ir(Statement memory stmt, IRContext memory context) 
        private returns (StatementIR memory) {
        
        StatementIR memory for_ir = StatementIR({
            stmt_type: IRStatementType.For,
            has_init: stmt.has_init,
            init: StatementIR({
                stmt_type: IRStatementType.Expression,
                expression: ExpressionIR({
                    expr_type: IRExpressionType.Literal,
                    literal: ValueIR({ value_type: IRValueType.Null })
                })
            }),
            has_condition: stmt.has_condition,
            condition: ExpressionIR({
                expr_type: IRExpressionType.Literal,
                literal: ValueIR({ value_type: IRValueType.Bool, bool_value: true })
            }),
            has_update: stmt.has_update,
            update: ExpressionIR({
                expr_type: IRExpressionType.Literal,
                literal: ValueIR({ value_type: IRValueType.Null })
            }),
            body: generate_statement_ir(stmt.body, context)
        });
        
        if (stmt.has_init) {
            for_ir.init = generate_statement_ir(stmt.init, context);
        }
        
        if (stmt.has_condition) {
            for_ir.condition = generate_expression_ir(stmt.condition, context);
        }
        
        if (stmt.has_update) {
            for_ir.update = generate_expression_ir(stmt.update, context);
        }
        
        return for_ir;
    }
    
    function generate_return_statement_ir(Statement memory stmt, IRContext memory context) 
        private returns (StatementIR memory) {
        
        StatementIR memory return_ir = StatementIR({
            stmt_type: IRStatementType.Return,
            has_return_value: stmt.has_return_value,
            return_value: ExpressionIR({
                expr_type: IRExpressionType.Literal,
                literal: ValueIR({ value_type: IRValueType.Null })
            })
        });
        
        if (stmt.has_return_value) {
            return_ir.return_value = generate_expression_ir(stmt.return_value, context);
        }
        
        return return_ir;
    }
    
    function generate_emit_statement_ir(Statement memory stmt, IRContext memory context) 
        private returns (StatementIR memory) {
        
        StatementIR memory emit_ir = StatementIR({
            stmt_type: IRStatementType.Emit,
            event_name: stmt.event_name,
            arguments: new ExpressionIR[](stmt.arguments.length)
        });
        
        for (uint256 i = 0; i < stmt.arguments.length; i++) {
            emit_ir.arguments[i] = generate_expression_ir(stmt.arguments[i], context);
        }
        
        return emit_ir;
    }
    
    function generate_require_statement_ir(Statement memory stmt, IRContext memory context) 
        private returns (StatementIR memory) {
        
        StatementIR memory require_ir = StatementIR({
            stmt_type: IRStatementType.Require,
            condition: generate_expression_ir(stmt.condition, context),
            has_message: stmt.has_message,
            message: ExpressionIR({
                expr_type: IRExpressionType.Literal,
                literal: ValueIR({ value_type: IRValueType.Null })
            })
        });
        
        if (stmt.has_message) {
            require_ir.message = generate_expression_ir(stmt.message, context);
        }
        
        return require_ir;
    }
    
    function generate_assert_statement_ir(Statement memory stmt, IRContext memory context) 
        private returns (StatementIR memory) {
        
        StatementIR memory assert_ir = StatementIR({
            stmt_type: IRStatementType.Assert,
            condition: generate_expression_ir(stmt.condition, context),
            has_message: stmt.has_message,
            message: ExpressionIR({
                expr_type: IRExpressionType.Literal,
                literal: ValueIR({ value_type: IRValueType.Null })
            })
        });
        
        if (stmt.has_message) {
            assert_ir.message = generate_expression_ir(stmt.message, context);
        }
        
        return assert_ir;
    }
    
    function generate_revert_statement_ir(Statement memory stmt, IRContext memory context) 
        private returns (StatementIR memory) {
        
        StatementIR memory revert_ir = StatementIR({
            stmt_type: IRStatementType.Revert,
            has_message: stmt.has_message,
            message: ExpressionIR({
                expr_type: IRExpressionType.Literal,
                literal: ValueIR({ value_type: IRValueType.Null })
            })
        });
        
        if (stmt.has_message) {
            revert_ir.message = generate_expression_ir(stmt.message, context);
        }
        
        return revert_ir;
    }
    
    function generate_expression_ir(Expression memory expr, IRContext memory context) 
        private returns (ExpressionIR memory) {
        
        if (expr.expr_type == ExpressionType.Literal) {
            return ExpressionIR({
                expr_type: IRExpressionType.Literal,
                literal: convert_literal_to_ir(expr.literal)
            });
        } else if (expr.expr_type == ExpressionType.Identifier) {
            return ExpressionIR({
                expr_type: IRExpressionType.Identifier,
                name: expr.name
            });
        } else if (expr.expr_type == ExpressionType.Binary) {
            return generate_binary_expression_ir(expr, context);
        } else if (expr.expr_type == ExpressionType.Unary) {
            return generate_unary_expression_ir(expr, context);
        } else if (expr.expr_type == ExpressionType.Assignment) {
            return generate_assignment_expression_ir(expr, context);
        } else if (expr.expr_type == ExpressionType.FunctionCall) {
            return generate_function_call_ir(expr, context);
        } else if (expr.expr_type == ExpressionType.MemberAccess) {
            return generate_member_access_ir(expr, context);
        } else if (expr.expr_type == ExpressionType.IndexAccess) {
            return generate_index_access_ir(expr, context);
        } else {
            return ExpressionIR({
                expr_type: IRExpressionType.Literal,
                literal: ValueIR({ value_type: IRValueType.Null })
            });
        }
    }
    
    function generate_binary_expression_ir(Expression memory expr, IRContext memory context) 
        private returns (ExpressionIR memory) {
        
        return ExpressionIR({
            expr_type: IRExpressionType.Binary,
            left: generate_expression_ir(expr.left, context),
            right: generate_expression_ir(expr.right, context),
            operator: convert_binary_operator_to_ir(expr.operator)
        });
    }
    
    function generate_unary_expression_ir(Expression memory expr, IRContext memory context) 
        private returns (ExpressionIR memory) {
        
        return ExpressionIR({
            expr_type: IRExpressionType.Unary,
            operand: generate_expression_ir(expr.operand, context),
            operator: convert_unary_operator_to_ir(expr.operator)
        });
    }
    
    function generate_assignment_expression_ir(Expression memory expr, IRContext memory context) 
        private returns (ExpressionIR memory) {
        
        return ExpressionIR({
            expr_type: IRExpressionType.Assignment,
            left: generate_expression_ir(expr.left, context),
            right: generate_expression_ir(expr.right, context),
            operator: convert_assignment_operator_to_ir(expr.operator)
        });
    }
    
    function generate_function_call_ir(Expression memory expr, IRContext memory context) 
        private returns (ExpressionIR memory) {
        
        ExpressionIR memory call_ir = ExpressionIR({
            expr_type: IRExpressionType.FunctionCall,
            function: generate_expression_ir(expr.function, context),
            arguments: new ExpressionIR[](expr.arguments.length)
        });
        
        for (uint256 i = 0; i < expr.arguments.length; i++) {
            call_ir.arguments[i] = generate_expression_ir(expr.arguments[i], context);
        }
        
        return call_ir;
    }
    
    function generate_member_access_ir(Expression memory expr, IRContext memory context) 
        private returns (ExpressionIR memory) {
        
        return ExpressionIR({
            expr_type: IRExpressionType.MemberAccess,
            object: generate_expression_ir(expr.object, context),
            member: expr.member
        });
    }
    
    function generate_index_access_ir(Expression memory expr, IRContext memory context) 
        private returns (ExpressionIR memory) {
        
        return ExpressionIR({
            expr_type: IRExpressionType.IndexAccess,
            object: generate_expression_ir(expr.object, context),
            index: generate_expression_ir(expr.index, context)
        });
    }
    
    // Conversion utilities
    function convert_type_to_ir(Type memory type_def) private pure returns (TypeIR memory) {
        if (type_def.type_kind == TypeKind.Bool) {
            return TypeIR({ type_kind: IRTypeKind.Bool });
        } else if (type_def.type_kind == TypeKind.String) {
            return TypeIR({ type_kind: IRTypeKind.String });
        } else if (type_def.type_kind == TypeKind.Address) {
            return TypeIR({ type_kind: IRTypeKind.Address });
        } else if (type_def.type_kind == TypeKind.Uint) {
            return TypeIR({ 
                type_kind: IRTypeKind.Uint,
                size: type_def.size
            });
        } else if (type_def.type_kind == TypeKind.Int) {
            return TypeIR({ 
                type_kind: IRTypeKind.Int,
                size: type_def.size
            });
        } else if (type_def.type_kind == TypeKind.Array) {
            return TypeIR({
                type_kind: IRTypeKind.Array,
                element_type: convert_type_to_ir(type_def.element_type),
                is_dynamic: type_def.is_dynamic,
                size: type_def.size
            });
        } else if (type_def.type_kind == TypeKind.Mapping) {
            return TypeIR({
                type_kind: IRTypeKind.Mapping,
                key_type: convert_type_to_ir(type_def.key_type),
                value_type: convert_type_to_ir(type_def.value_type)
            });
        } else if (type_def.type_kind == TypeKind.Custom) {
            return TypeIR({
                type_kind: IRTypeKind.Custom,
                name: type_def.name
            });
        } else {
            return TypeIR({ type_kind: IRTypeKind.Void });
        }
    }
    
    function convert_visibility_to_ir(Visibility visibility) private pure returns (VisibilityIR) {
        if (visibility == Visibility.Public) {
            return VisibilityIR.Public;
        } else if (visibility == Visibility.Private) {
            return VisibilityIR.Private;
        } else if (visibility == Visibility.Internal) {
            return VisibilityIR.Internal;
        } else {
            return VisibilityIR.External;
        }
    }
    
    function convert_mutability_to_ir(Mutability mutability) private pure returns (MutabilityIR) {
        if (mutability == Mutability.Pure) {
            return MutabilityIR.Pure;
        } else if (mutability == Mutability.View) {
            return MutabilityIR.View;
        } else if (mutability == Mutability.Payable) {
            return MutabilityIR.Payable;
        } else {
            return MutabilityIR.NonPayable;
        }
    }
    
    function convert_literal_to_ir(Literal memory literal) private pure returns (ValueIR memory) {
        if (literal.literal_type == LiteralType.Bool) {
            return ValueIR({
                value_type: IRValueType.Bool,
                bool_value: literal.bool_value
            });
        } else if (literal.literal_type == LiteralType.Integer) {
            return ValueIR({
                value_type: IRValueType.Integer,
                int_value: literal.int_value
            });
        } else if (literal.literal_type == LiteralType.String) {
            return ValueIR({
                value_type: IRValueType.String,
                string_value: literal.string_value
            });
        } else if (literal.literal_type == LiteralType.Address) {
            return ValueIR({
                value_type: IRValueType.Address,
                address_value: literal.address_value
            });
        } else if (literal.literal_type == LiteralType.Bytes) {
            return ValueIR({
                value_type: IRValueType.Bytes,
                bytes_value: literal.bytes_value
            });
        } else {
            return ValueIR({ value_type: IRValueType.Null });
        }
    }
    
    function convert_binary_operator_to_ir(TokenType operator) private pure returns (BinaryOperatorIR) {
        if (operator == TokenType.Plus) {
            return BinaryOperatorIR.Add;
        } else if (operator == TokenType.Minus) {
            return BinaryOperatorIR.Sub;
        } else if (operator == TokenType.Star) {
            return BinaryOperatorIR.Mul;
        } else if (operator == TokenType.Slash) {
            return BinaryOperatorIR.Div;
        } else if (operator == TokenType.Percent) {
            return BinaryOperatorIR.Mod;
        } else if (operator == TokenType.Less) {
            return BinaryOperatorIR.Lt;
        } else if (operator == TokenType.LessEqual) {
            return BinaryOperatorIR.Le;
        } else if (operator == TokenType.Greater) {
            return BinaryOperatorIR.Gt;
        } else if (operator == TokenType.GreaterEqual) {
            return BinaryOperatorIR.Ge;
        } else if (operator == TokenType.EqualEqual) {
            return BinaryOperatorIR.Eq;
        } else if (operator == TokenType.BangEqual) {
            return BinaryOperatorIR.Ne;
        } else if (operator == TokenType.AmpersandAmpersand) {
            return BinaryOperatorIR.And;
        } else if (operator == TokenType.PipePipe) {
            return BinaryOperatorIR.Or;
        } else {
            return BinaryOperatorIR.Add; // fallback
        }
    }
    
    function convert_unary_operator_to_ir(TokenType operator) private pure returns (UnaryOperatorIR) {
        if (operator == TokenType.Minus) {
            return UnaryOperatorIR.Neg;
        } else if (operator == TokenType.Bang) {
            return UnaryOperatorIR.Not;
        } else if (operator == TokenType.Tilde) {
            return UnaryOperatorIR.BitNot;
        } else {
            return UnaryOperatorIR.Not; // fallback
        }
    }
    
    function convert_assignment_operator_to_ir(TokenType operator) private pure returns (BinaryOperatorIR) {
        if (operator == TokenType.Equal) {
            return BinaryOperatorIR.Assign;
        } else if (operator == TokenType.PlusEqual) {
            return BinaryOperatorIR.AddAssign;
        } else if (operator == TokenType.MinusEqual) {
            return BinaryOperatorIR.SubAssign;
        } else if (operator == TokenType.StarEqual) {
            return BinaryOperatorIR.MulAssign;
        } else if (operator == TokenType.SlashEqual) {
            return BinaryOperatorIR.DivAssign;
        } else {
            return BinaryOperatorIR.Assign; // fallback
        }
    }
    
    function convert_annotations(Annotation[] memory annotations) private pure returns (AnnotationIR[] memory) {
        AnnotationIR[] memory ir_annotations = new AnnotationIR[](annotations.length);
        
        for (uint256 i = 0; i < annotations.length; i++) {
            ir_annotations[i] = AnnotationIR({
                name: annotations[i].name,
                arguments: annotations[i].arguments
            });
        }
        
        return ir_annotations;
    }
    
    function get_current_module(IRContext memory context) private view returns (IRModule storage) {
        if (modules.length == 0) {
            // Create default module
            modules.push(IRModule({
                name: "default",
                module_type: ModuleType.Library,
                imports: new ImportIR[](0),
                blockchains: new BlockchainIR[](0),
                structs: new StructIR[](0),
                enums: new EnumIR[](0),
                functions: new FunctionIR[](0),
                constants: new ConstantIR[](0)
            }));
        }
        
        return modules[modules.length - 1];
    }
    
    function generate_temp_variable(IRContext memory context) private returns (string memory) {
        string memory temp_name = string.concat("_temp", uint_to_string(context.temp_counter));
        context.temp_counter++;
        return temp_name;
    }
    
    function generate_label(IRContext memory context) private returns (string memory) {
        string memory label_name = string.concat("_label", uint_to_string(context.label_counter));
        context.label_counter++;
        return label_name;
    }
    
    function uint_to_string(uint256 value) private pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        
        uint256 temp = value;
        uint256 digits;
        
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        
        bytes memory buffer = new bytes(digits);
        
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        
        return string(buffer);
    }
}

// IR Data Structures
struct OmegaIRResult {
    IRModule[] modules;
    IRMetadata metadata;
    bool success;
    string[] errors;
}

struct IRModule {
    string name;
    ModuleType module_type;
    ImportIR[] imports;
    BlockchainIR[] blockchains;
    StructIR[] structs;
    EnumIR[] enums;
    FunctionIR[] functions;
    ConstantIR[] constants;
}

enum ModuleType {
    Blockchain,
    Library,
    Interface
}

struct IRMetadata {
    TargetPlatform[] target_platforms;
    OptimizationLevel optimization_level;
    bool debug_info;
    string source_file;
    string compiler_version;
    uint256 generation_timestamp;
}

enum TargetPlatform {
    EVM,
    Solana,
    Cosmos,
    Substrate,
    Move,
    Near
}

enum OptimizationLevel {
    O0, // No optimization
    O1, // Basic optimization
    O2, // Standard optimization
    O3  // Aggressive optimization
}

struct IRContext {
    string current_module;
    string current_blockchain;
    string current_function;
    SymbolTable symbol_table;
    TypeEnvironment type_environment;
    uint256 temp_counter;
    uint256 label_counter;
}

struct ImportIR {
    string module_path;
    string alias;
    bool has_alias;
    bool is_wildcard;
    string[] specific_items;
}

struct BlockchainIR {
    string name;
    AnnotationIR[] annotations;
    StateVariableIR[] state_variables;
    EventIR[] events;
    FunctionIR[] functions;
    ModifierIR[] modifiers;
    FunctionIR constructor;
    bool has_constructor;
}

struct StateVariableIR {
    string name;
    TypeIR var_type;
    VisibilityIR visibility;
    bool is_constant;
    bool is_immutable;
    bool has_initial_value;
    ExpressionIR initial_value;
    AnnotationIR[] annotations;
}

struct EventIR {
    string name;
    ParameterIR[] parameters;
    AnnotationIR[] annotations;
}

struct FunctionIR {
    string name;
    ParameterIR[] parameters;
    TypeIR return_type;
    bool has_return_type;
    VisibilityIR visibility;
    MutabilityIR mutability;
    string[] modifiers;
    BlockIR body;
    bool is_constructor;
    AnnotationIR[] annotations;
}

struct ModifierIR {
    string name;
    ParameterIR[] parameters;
    BlockIR body;
    AnnotationIR[] annotations;
}

struct ParameterIR {
    string name;
    TypeIR param_type;
    bool is_indexed;
    AnnotationIR[] annotations;
}

struct StructIR {
    string name;
    StructFieldIR[] fields;
    AnnotationIR[] annotations;
}

struct StructFieldIR {
    string name;
    TypeIR field_type;
    VisibilityIR visibility;
    AnnotationIR[] annotations;
}

struct EnumIR {
    string name;
    EnumVariantIR[] variants;
    AnnotationIR[] annotations;
}

struct EnumVariantIR {
    string name;
    bool has_value;
    ExpressionIR value;
    AnnotationIR[] annotations;
}

struct ConstantIR {
    string name;
    TypeIR const_type;
    ExpressionIR value;
    AnnotationIR[] annotations;
}

struct BlockIR {
    StatementIR[] statements;
}

struct StatementIR {
    IRStatementType stmt_type;
    
    // Variable declaration
    string var_name;
    TypeIR var_type;
    bool has_initializer;
    ExpressionIR initializer;
    
    // Expression statement
    ExpressionIR expression;
    
    // Control flow
    ExpressionIR condition;
    StatementIR then_branch;
    bool has_else_branch;
    StatementIR else_branch;
    StatementIR body;
    
    // For loop
    bool has_init;
    StatementIR init;
    bool has_condition;
    bool has_update;
    ExpressionIR update;
    
    // Return
    bool has_return_value;
    ExpressionIR return_value;
    
    // Emit
    string event_name;
    ExpressionIR[] arguments;
    
    // Require/Assert/Revert
    bool has_message;
    ExpressionIR message;
    
    // Block
    BlockIR block;
}

enum IRStatementType {
    VariableDeclaration,
    Expression,
    If,
    While,
    For,
    Return,
    Emit,
    Require,
    Assert,
    Revert,
    Block
}

struct ExpressionIR {
    IRExpressionType expr_type;
    
    // Literal
    ValueIR literal;
    
    // Identifier
    string name;
    
    // Binary/Unary
    ExpressionIR left;
    ExpressionIR right;
    ExpressionIR operand;
    BinaryOperatorIR operator;
    UnaryOperatorIR unary_operator;
    
    // Function call
    ExpressionIR function;
    ExpressionIR[] arguments;
    
    // Member/Index access
    ExpressionIR object;
    string member;
    ExpressionIR index;
}

enum IRExpressionType {
    Literal,
    Identifier,
    Binary,
    Unary,
    Assignment,
    FunctionCall,
    MemberAccess,
    IndexAccess
}

struct ValueIR {
    IRValueType value_type;
    bool bool_value;
    uint256 int_value;
    string string_value;
    address address_value;
    bytes bytes_value;
}

enum IRValueType {
    Null,
    Bool,
    Integer,
    String,
    Address,
    Bytes
}

struct TypeIR {
    IRTypeKind type_kind;
    string name;
    uint16 size;
    TypeIR element_type;
    TypeIR key_type;
    TypeIR value_type;
    bool is_dynamic;
}

enum IRTypeKind {
    Void,
    Bool,
    String,
    Address,
    Uint,
    Int,
    FixedBytes,
    DynamicBytes,
    Array,
    Mapping,
    Function,
    Custom
}

enum VisibilityIR {
    Public,
    Private,
    Internal,
    External
}

enum MutabilityIR {
    Pure,
    View,
    NonPayable,
    Payable
}

enum BinaryOperatorIR {
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Lt,
    Le,
    Gt,
    Ge,
    Eq,
    Ne,
    And,
    Or,
    BitAnd,
    BitOr,
    BitXor,
    Shl,
    Shr,
    Assign,
    AddAssign,
    SubAssign,
    MulAssign,
    DivAssign
}

enum UnaryOperatorIR {
    Neg,
    Not,
    BitNot,
    PreInc,
    PostInc,
    PreDec,
    PostDec
}

/// Enhanced error handling functions for IR generator
impl OmegaIR {
    /// Set current file being processed
    function set_current_file(string file_path) public {
        current_file = file_path;
    }
    
    /// Report IR generation error with context
    function report_ir_error(string message, string context_info, ErrorSeverity severity) private {
        let location = SourceLocation {
            file: current_file,
            line: 0, // IR errors may not have specific line numbers
            column: 0,
            position: 0
        };
        
        let context = ErrorContext {
            context_type: ContextType.IRGeneration,
            source_code: context_info,
            additional_info: format("Optimization Level: {}", optimization_level)
        };
        
        let error_code = determine_ir_error_code(message);
        
        let error = OmegaError {
            error_type: ErrorType.IRError,
            severity: severity,
            code: error_code,
            message: message,
            location: location,
            context: context,
            suggestions: generate_ir_suggestions(message, error_code)
        };
        
        error_handler.report_error(error);
        
        if (severity == ErrorSeverity.Error) {
            error_count++;
        }
    }
    
    /// Determine error code for IR generation errors
    function determine_ir_error_code(string message) private pure returns (ErrorCode) {
        if (message.contains("unsupported")) {
            return ErrorCode.UnsupportedFeature;
        } else if (message.contains("optimization")) {
            return ErrorCode.OptimizationError;
        } else if (message.contains("target")) {
            return ErrorCode.TargetError;
        } else if (message.contains("conversion")) {
            return ErrorCode.ConversionError;
        } else {
            return ErrorCode.IRError;
        }
    }
    
    /// Generate suggestions for IR generation errors
    function generate_ir_suggestions(string error_message, ErrorCode error_code) private pure returns (string[]) {
        string[] suggestions = [];
        
        if (error_code == ErrorCode.UnsupportedFeature) {
            suggestions.push("Check if the feature is supported on the target platform");
            suggestions.push("Consider using alternative implementation");
        } else if (error_code == ErrorCode.OptimizationError) {
            suggestions.push("Try reducing optimization level");
            suggestions.push("Check for optimization conflicts");
        } else if (error_code == ErrorCode.TargetError) {
            suggestions.push("Verify target platform configuration");
            suggestions.push("Check platform-specific requirements");
        } else if (error_code == ErrorCode.ConversionError) {
            suggestions.push("Check type compatibility");
            suggestions.push("Verify conversion rules");
        }
        
        return suggestions;
    }
    
    /// Report unsupported feature error
    function report_unsupported_feature(string feature_name, string target_platform) public {
        string message = format("Feature '{}' is not supported on target platform '{}'", feature_name, target_platform);
        report_ir_error(message, format("Feature: {}, Target: {}", feature_name, target_platform), ErrorSeverity.Error);
    }
    
    /// Report optimization error
    function report_optimization_error(string optimization_name, string reason) public {
        string message = format("Optimization '{}' failed: {}", optimization_name, reason);
        report_ir_error(message, format("Optimization: {}", optimization_name), ErrorSeverity.Warning);
    }
    
    /// Report target platform error
    function report_target_error(string target_name, string issue) public {
        string message = format("Target platform '{}' error: {}", target_name, issue);
        report_ir_error(message, format("Target: {}", target_name), ErrorSeverity.Error);
    }
    
    /// Check if IR generator has encountered errors
    function has_errors() public view returns (bool) {
        return error_count > 0 || error_handler.has_errors();
    }
    
    /// Get error count
    function get_error_count() public view returns (uint256) {
        return error_count;
    }
    
    /// Get error statistics
    function get_error_stats() public view returns (ErrorStatistics) {
        return error_handler.get_statistics();
    }
    
    /// Clear all errors (for testing)
    function clear_errors() public {
        error_handler.clear_errors();
        error_count = 0;
    }
    
    /// Validate IR module before processing
    function validate_ir_module(IRModule module) public returns (bool) {
        bool is_valid = true;
        
        // Check for required components
        if (module.name.length == 0) {
            report_ir_error("IR module must have a name", "Module validation", ErrorSeverity.Error);
            is_valid = false;
        }
        
        // Validate functions
        for (uint256 i = 0; i < module.functions.length; i++) {
            if (!validate_ir_function(module.functions[i])) {
                is_valid = false;
            }
        }
        
        return is_valid;
    }
    
    /// Validate IR function
    function validate_ir_function(IRFunction func) private returns (bool) {
        bool is_valid = true;
        
        if (func.name.length == 0) {
            report_ir_error("IR function must have a name", "Function validation", ErrorSeverity.Error);
            is_valid = false;
        }
        
        // Validate basic blocks
        for (uint256 i = 0; i < func.basic_blocks.length; i++) {
            if (!validate_basic_block(func.basic_blocks[i])) {
                is_valid = false;
            }
        }
        
        return is_valid;
    }
    
    /// Validate basic block
    function validate_basic_block(IRBasicBlock block) private returns (bool) {
        bool is_valid = true;
        
        if (block.instructions.length == 0) {
            report_ir_error("Basic block cannot be empty", "Block validation", ErrorSeverity.Warning);
        }
        
        return is_valid;
    }
}

struct AnnotationIR {
    string name;
    string[] arguments;
}
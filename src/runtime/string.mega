// OMEGA Compiler - String Processing Library
// String type, StringBuilder, string utilities, text operations

use std::collections::HashMap;

// ========== String Builder ==========

pub struct StringBuilder {
    buffer: Vec<char>,
    capacity: usize,
}

impl StringBuilder {
    pub fn new() -> Self {
        StringBuilder {
            buffer: Vec::new(),
            capacity: 256,
        }
    }

    pub fn with_capacity(capacity: usize) -> Self {
        StringBuilder {
            buffer: Vec::with_capacity(capacity),
            capacity,
        }
    }

    pub fn append(&mut self, s: &str) -> &mut Self {
        for c in s.chars() {
            self.buffer.push(c);
        }
        self
    }

    pub fn append_char(&mut self, c: char) -> &mut Self {
        self.buffer.push(c);
        self
    }

    pub fn append_number(&mut self, n: i64) -> &mut Self {
        self.append(&n.to_string());
        self
    }

    pub fn append_float(&mut self, f: f64) -> &mut Self {
        self.append(&f.to_string());
        self
    }

    pub fn insert(&mut self, index: usize, s: &str) -> Result<(), String> {
        if index > self.buffer.len() {
            return Err("Index out of bounds".to_string());
        }
        let mut chars: Vec<char> = s.chars().collect();
        chars.reverse();
        for c in chars {
            self.buffer.insert(index, c);
        }
        Ok(())
    }

    pub fn remove(&mut self, index: usize) -> Result<char, String> {
        if index >= self.buffer.len() {
            Err("Index out of bounds".to_string())
        } else {
            Ok(self.buffer.remove(index))
        }
    }

    pub fn clear(&mut self) {
        self.buffer.clear();
    }

    pub fn build(&self) -> String {
        self.buffer.iter().collect()
    }

    pub fn len(&self) -> usize {
        self.buffer.len()
    }

    pub fn is_empty(&self) -> bool {
        self.buffer.is_empty()
    }

    pub fn reverse(&mut self) -> &mut Self {
        self.buffer.reverse();
        self
    }

    pub fn to_uppercase(&mut self) -> &mut Self {
        for c in &mut self.buffer {
            *c = c.to_uppercase().next().unwrap_or(*c);
        }
        self
    }

    pub fn to_lowercase(&mut self) -> &mut Self {
        for c in &mut self.buffer {
            *c = c.to_lowercase().next().unwrap_or(*c);
        }
        self
    }
}

// ========== String Utilities ==========

pub struct StringUtils;

impl StringUtils {
    pub fn is_empty(s: &str) -> bool {
        s.is_empty()
    }

    pub fn is_whitespace(s: &str) -> bool {
        s.chars().all(|c| c.is_whitespace())
    }

    pub fn trim(s: &str) -> &str {
        s.trim()
    }

    pub fn trim_start(s: &str) -> &str {
        s.trim_start()
    }

    pub fn trim_end(s: &str) -> &str {
        s.trim_end()
    }

    pub fn to_uppercase(s: &str) -> String {
        s.to_uppercase()
    }

    pub fn to_lowercase(s: &str) -> String {
        s.to_lowercase()
    }

    pub fn length(s: &str) -> usize {
        s.len()
    }

    pub fn char_count(s: &str) -> usize {
        s.chars().count()
    }

    pub fn starts_with(s: &str, prefix: &str) -> bool {
        s.starts_with(prefix)
    }

    pub fn ends_with(s: &str, suffix: &str) -> bool {
        s.ends_with(suffix)
    }

    pub fn contains(s: &str, substring: &str) -> bool {
        s.contains(substring)
    }

    pub fn index_of(s: &str, substring: &str) -> Option<usize> {
        s.find(substring)
    }

    pub fn last_index_of(s: &str, substring: &str) -> Option<usize> {
        s.rfind(substring)
    }

    pub fn substring(s: &str, start: usize, end: usize) -> Result<&str, String> {
        if start > s.len() || end > s.len() || start > end {
            Err("Invalid substring indices".to_string())
        } else {
            Ok(&s[start..end])
        }
    }

    pub fn split(s: &str, delimiter: &str) -> Vec<&str> {
        s.split(delimiter).collect()
    }

    pub fn split_whitespace(s: &str) -> Vec<&str> {
        s.split_whitespace().collect()
    }

    pub fn replace(s: &str, from: &str, to: &str) -> String {
        s.replace(from, to)
    }

    pub fn replace_first(s: &str, from: &str, to: &str) -> String {
        s.replacen(from, to, 1)
    }

    pub fn repeat(s: &str, count: usize) -> String {
        s.repeat(count)
    }

    pub fn reverse(s: &str) -> String {
        s.chars().rev().collect()
    }

    pub fn pad_left(s: &str, width: usize, pad_char: char) -> String {
        let current_len = s.chars().count();
        if current_len >= width {
            s.to_string()
        } else {
            let padding = pad_char.to_string().repeat(width - current_len);
            format!("{}{}", padding, s)
        }
    }

    pub fn pad_right(s: &str, width: usize, pad_char: char) -> String {
        let current_len = s.chars().count();
        if current_len >= width {
            s.to_string()
        } else {
            let padding = pad_char.to_string().repeat(width - current_len);
            format!("{}{}", s, padding)
        }
    }

    pub fn equals(s1: &str, s2: &str) -> bool {
        s1 == s2
    }

    pub fn equals_ignore_case(s1: &str, s2: &str) -> bool {
        s1.to_lowercase() == s2.to_lowercase()
    }

    pub fn compare(s1: &str, s2: &str) -> i32 {
        match s1.cmp(s2) {
            std::cmp::Ordering::Less => -1,
            std::cmp::Ordering::Equal => 0,
            std::cmp::Ordering::Greater => 1,
        }
    }

    pub fn count_occurrences(s: &str, substring: &str) -> usize {
        s.matches(substring).count()
    }

    pub fn is_numeric(s: &str) -> bool {
        !s.is_empty() && s.chars().all(|c| c.is_ascii_digit() || c == '.')
    }

    pub fn is_alphabetic(s: &str) -> bool {
        !s.is_empty() && s.chars().all(|c| c.is_alphabetic())
    }

    pub fn is_alphanumeric(s: &str) -> bool {
        !s.is_empty() && s.chars().all(|c| c.is_alphanumeric())
    }
}

// ========== String Pattern Matching ==========

pub struct StringPattern {
    pattern: String,
    is_regex: bool,
}

impl StringPattern {
    pub fn new(pattern: String) -> Self {
        StringPattern {
            pattern,
            is_regex: false,
        }
    }

    pub fn as_regex(mut self) -> Self {
        self.is_regex = true;
        self
    }

    pub fn matches(&self, text: &str) -> bool {
        if self.is_regex {
            self.pattern_matches_regex(text)
        } else {
            text.contains(&self.pattern)
        }
    }

    pub fn find_all(&self, text: &str) -> Vec<usize> {
        let mut matches = Vec::new();
        let mut start = 0;
        while let Some(pos) = text[start..].find(&self.pattern) {
            matches.push(start + pos);
            start = start + pos + 1;
        }
        matches
    }

    pub fn replace_all(&self, text: &str, replacement: &str) -> String {
        text.replace(&self.pattern, replacement)
    }

    fn pattern_matches_regex(&self, text: &str) -> bool {
        // Simple regex matching for common patterns
        if self.pattern == "." {
            true
        } else if self.pattern.ends_with("*") {
            let base = &self.pattern[..self.pattern.len() - 1];
            text.contains(base)
        } else if self.pattern.starts_with("^") && self.pattern.ends_with("$") {
            let pattern = &self.pattern[1..self.pattern.len() - 1];
            text == pattern
        } else {
            text.contains(&self.pattern)
        }
    }
}

// ========== String Parser ==========

pub struct StringParser {
    input: String,
    position: usize,
}

impl StringParser {
    pub fn new(input: String) -> Self {
        StringParser { input, position: 0 }
    }

    pub fn has_next(&self) -> bool {
        self.position < self.input.len()
    }

    pub fn peek(&self) -> Option<char> {
        self.input.chars().nth(self.position)
    }

    pub fn next_char(&mut self) -> Option<char> {
        if self.has_next() {
            let c = self.peek();
            self.position += 1;
            c
        } else {
            None
        }
    }

    pub fn skip_whitespace(&mut self) {
        while let Some(c) = self.peek() {
            if c.is_whitespace() {
                self.next_char();
            } else {
                break;
            }
        }
    }

    pub fn read_until(&mut self, delimiter: char) -> String {
        let mut result = String::new();
        while let Some(c) = self.peek() {
            if c == delimiter {
                break;
            }
            result.push(c);
            self.next_char();
        }
        result
    }

    pub fn read_while<F>(&mut self, predicate: F) -> String
    where
        F: Fn(char) -> bool,
    {
        let mut result = String::new();
        while let Some(c) = self.peek() {
            if predicate(c) {
                result.push(c);
                self.next_char();
            } else {
                break;
            }
        }
        result
    }

    pub fn read_number(&mut self) -> Result<i64, String> {
        let num_str = self.read_while(|c| c.is_ascii_digit() || c == '-');
        num_str.parse::<i64>().map_err(|_| "Invalid number".to_string())
    }

    pub fn read_identifier(&mut self) -> String {
        self.read_while(|c| c.is_alphanumeric() || c == '_')
    }

    pub fn read_string(&mut self, quote: char) -> Result<String, String> {
        if self.next_char() != Some(quote) {
            return Err("Expected opening quote".to_string());
        }
        let mut result = String::new();
        loop {
            match self.next_char() {
                Some(c) if c == quote => return Ok(result),
                Some('\\') => {
                    if let Some(escaped) = self.next_char() {
                        let unescaped = match escaped {
                            'n' => '\n',
                            't' => '\t',
                            'r' => '\r',
                            '\\' => '\\',
                            '"' => '"',
                            '\'' => '\'',
                            _ => escaped,
                        };
                        result.push(unescaped);
                    }
                }
                Some(c) => result.push(c),
                None => return Err("Unterminated string".to_string()),
            }
        }
    }

    pub fn position(&self) -> usize {
        self.position
    }

    pub fn reset(&mut self) {
        self.position = 0;
    }

    pub fn remaining(&self) -> &str {
        &self.input[self.position..]
    }
}

// ========== String Formatting ==========

pub struct StringFormatter;

impl StringFormatter {
    pub fn format(template: &str, values: &HashMap<String, String>) -> String {
        let mut result = template.to_string();
        for (key, value) in values {
            result = result.replace(&format!("{{{}}}", key), value);
        }
        result
    }

    pub fn format_number(n: i64, width: usize) -> String {
        format!("{:width$}", n, width = width)
    }

    pub fn format_float(f: f64, precision: usize) -> String {
        format!("{:.prec$}", f, prec = precision)
    }

    pub fn format_hex(n: i64) -> String {
        format!("0x{:x}", n)
    }

    pub fn format_octal(n: i64) -> String {
        format!("0o{:o}", n)
    }

    pub fn format_binary(n: i64) -> String {
        format!("0b{:b}", n)
    }
}

// ========== Statistics ==========

pub struct StringStats {
    pub total_strings: usize,
    pub total_memory_bytes: usize,
    pub average_length: usize,
    pub max_length: usize,
    pub min_length: usize,
}

#[cfg(test)]
mod string_tests {
    use super::*;

    #[test]
    fn test_string_builder() {
        let mut sb = StringBuilder::new();
        sb.append("Hello").append_char(' ').append("World");
        assert_eq!(sb.build(), "Hello World");
    }

    #[test]
    fn test_string_utils_trim() {
        assert_eq!(StringUtils::trim("  hello  "), "hello");
    }

    #[test]
    fn test_string_utils_contains() {
        assert!(StringUtils::contains("hello world", "world"));
    }

    #[test]
    fn test_string_utils_replace() {
        assert_eq!(StringUtils::replace("hello world", "world", "rust"), "hello rust");
    }

    #[test]
    fn test_string_pattern() {
        let pattern = StringPattern::new("test".to_string());
        assert!(pattern.matches("this is a test"));
    }

    #[test]
    fn test_string_parser() {
        let mut parser = StringParser::new("hello world".to_string());
        assert_eq!(parser.read_until(' '), "hello");
    }

    #[test]
    fn test_string_formatter() {
        let mut values = HashMap::new();
        values.insert("name".to_string(), "Alice".to_string());
        let result = StringFormatter::format("Hello, {name}!", &values);
        assert_eq!(result, "Hello, Alice!");
    }
}

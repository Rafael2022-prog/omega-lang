// OMEGA Compiler - Math Module
// Mathematical functions, constants, trigonometry, statistics

use std::f64::consts::*;

// ========== Math Constants ==========

pub const PI: f64 = PI;
pub const E: f64 = E;
pub const SQRT_2: f64 = std::f64::consts::SQRT_2;
pub const FRAC_PI_2: f64 = std::f64::consts::FRAC_PI_2;
pub const FRAC_PI_4: f64 = std::f64::consts::FRAC_PI_4;
pub const LN_2: f64 = std::f64::consts::LN_2;
pub const LN_10: f64 = std::f64::consts::LN_10;

// ========== Basic Math ==========

pub struct Math;

impl Math {
    pub fn abs(x: i64) -> i64 {
        x.abs()
    }

    pub fn abs_float(x: f64) -> f64 {
        x.abs()
    }

    pub fn min(a: i64, b: i64) -> i64 {
        if a < b { a } else { b }
    }

    pub fn max(a: i64, b: i64) -> i64 {
        if a > b { a } else { b }
    }

    pub fn min_float(a: f64, b: f64) -> f64 {
        if a < b { a } else { b }
    }

    pub fn max_float(a: f64, b: f64) -> f64 {
        if a > b { a } else { b }
    }

    pub fn sign(x: i64) -> i64 {
        if x > 0 { 1 } else if x < 0 { -1 } else { 0 }
    }

    pub fn sign_float(x: f64) -> f64 {
        if x > 0.0 { 1.0 } else if x < 0.0 { -1.0 } else { 0.0 }
    }

    pub fn round(x: f64) -> f64 {
        x.round()
    }

    pub fn floor(x: f64) -> f64 {
        x.floor()
    }

    pub fn ceil(x: f64) -> f64 {
        x.ceil()
    }

    pub fn trunc(x: f64) -> f64 {
        x.trunc()
    }

    pub fn fract(x: f64) -> f64 {
        x.fract()
    }
}

// ========== Powers and Roots ==========

impl Math {
    pub fn pow(base: f64, exponent: f64) -> f64 {
        base.powf(exponent)
    }

    pub fn pow_int(base: i64, exponent: u32) -> i64 {
        base.pow(exponent)
    }

    pub fn sqrt(x: f64) -> f64 {
        x.sqrt()
    }

    pub fn cbrt(x: f64) -> f64 {
        x.cbrt()
    }

    pub fn hypot(x: f64, y: f64) -> f64 {
        x.hypot(y)
    }

    pub fn exp(x: f64) -> f64 {
        x.exp()
    }

    pub fn exp2(x: f64) -> f64 {
        x.exp2()
    }

    pub fn exp10(x: f64) -> f64 {
        (10.0_f64).powf(x)
    }

    pub fn ln(x: f64) -> f64 {
        x.ln()
    }

    pub fn log10(x: f64) -> f64 {
        x.log10()
    }

    pub fn log2(x: f64) -> f64 {
        x.log2()
    }

    pub fn log(base: f64, x: f64) -> f64 {
        x.log(base)
    }
}

// ========== Trigonometric ==========

impl Math {
    pub fn sin(x: f64) -> f64 {
        x.sin()
    }

    pub fn cos(x: f64) -> f64 {
        x.cos()
    }

    pub fn tan(x: f64) -> f64 {
        x.tan()
    }

    pub fn asin(x: f64) -> f64 {
        x.asin()
    }

    pub fn acos(x: f64) -> f64 {
        x.acos()
    }

    pub fn atan(x: f64) -> f64 {
        x.atan()
    }

    pub fn atan2(y: f64, x: f64) -> f64 {
        y.atan2(x)
    }

    pub fn sinh(x: f64) -> f64 {
        x.sinh()
    }

    pub fn cosh(x: f64) -> f64 {
        x.cosh()
    }

    pub fn tanh(x: f64) -> f64 {
        x.tanh()
    }

    pub fn to_degrees(radians: f64) -> f64 {
        radians.to_degrees()
    }

    pub fn to_radians(degrees: f64) -> f64 {
        degrees.to_radians()
    }
}

// ========== Rounding and Comparison ==========

impl Math {
    pub fn clamp(value: f64, min: f64, max: f64) -> f64 {
        if value < min { min } else if value > max { max } else { value }
    }

    pub fn clamp_int(value: i64, min: i64, max: i64) -> i64 {
        if value < min { min } else if value > max { max } else { value }
    }

    pub fn lerp(a: f64, b: f64, t: f64) -> f64 {
        a + (b - a) * t
    }

    pub fn is_nan(x: f64) -> bool {
        x.is_nan()
    }

    pub fn is_infinite(x: f64) -> bool {
        x.is_infinite()
    }

    pub fn is_finite(x: f64) -> bool {
        x.is_finite()
    }

    pub fn is_normal(x: f64) -> bool {
        x.is_normal()
    }
}

// ========== Statistics ==========

pub struct Statistics;

impl Statistics {
    pub fn sum(values: &[i64]) -> i64 {
        values.iter().sum()
    }

    pub fn sum_float(values: &[f64]) -> f64 {
        values.iter().sum()
    }

    pub fn average(values: &[i64]) -> f64 {
        if values.is_empty() { 0.0 } else { Self::sum(values) as f64 / values.len() as f64 }
    }

    pub fn average_float(values: &[f64]) -> f64 {
        if values.is_empty() { 0.0 } else { Self::sum_float(values) / values.len() as f64 }
    }

    pub fn min(values: &[i64]) -> Option<i64> {
        values.iter().copied().min()
    }

    pub fn max(values: &[i64]) -> Option<i64> {
        values.iter().copied().max()
    }

    pub fn min_float(values: &[f64]) -> Option<f64> {
        values.iter().copied().min_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal))
    }

    pub fn max_float(values: &[f64]) -> Option<f64> {
        values.iter().copied().max_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal))
    }

    pub fn variance(values: &[f64]) -> f64 {
        let avg = Self::average_float(values);
        let sum_sq_diff: f64 = values.iter().map(|x| (x - avg).powi(2)).sum();
        sum_sq_diff / values.len() as f64
    }

    pub fn std_deviation(values: &[f64]) -> f64 {
        Self::variance(values).sqrt()
    }

    pub fn median(values: &mut [f64]) -> f64 {
        if values.is_empty() { return 0.0; }
        values.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
        let mid = values.len() / 2;
        if values.len() % 2 == 0 {
            (values[mid - 1] + values[mid]) / 2.0
        } else {
            values[mid]
        }
    }

    pub fn range(values: &[i64]) -> Option<i64> {
        match (Self::min(values), Self::max(values)) {
            (Some(min), Some(max)) => Some(max - min),
            _ => None,
        }
    }
}

// ========== Random Number Generation ==========

pub struct Random {
    seed: u64,
}

impl Random {
    pub fn new() -> Self {
        Random {
            seed: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_nanos() as u64,
        }
    }

    pub fn with_seed(seed: u64) -> Self {
        Random { seed }
    }

    pub fn next_u64(&mut self) -> u64 {
        self.seed = self.seed.wrapping_mul(6364136223846793005).wrapping_add(1442695040888963407);
        self.seed
    }

    pub fn next_i32(&mut self) -> i32 {
        (self.next_u64() >> 32) as i32
    }

    pub fn next_float(&mut self) -> f64 {
        let u = self.next_u64();
        ((u >> 11) as f64) * (1.0 / 9007199254740992.0)
    }

    pub fn next_int_range(&mut self, min: i64, max: i64) -> i64 {
        if min >= max {
            min
        } else {
            min + ((self.next_u64() % (max - min) as u64) as i64)
        }
    }

    pub fn next_float_range(&mut self, min: f64, max: f64) -> f64 {
        min + (self.next_float() * (max - min))
    }

    pub fn next_bool(&mut self) -> bool {
        (self.next_u64() & 1) == 1
    }
}

#[cfg(test)]
mod math_tests {
    use super::*;

    #[test]
    fn test_abs() {
        assert_eq!(Math::abs(-42), 42);
    }

    #[test]
    fn test_min_max() {
        assert_eq!(Math::min(3, 7), 3);
        assert_eq!(Math::max(3, 7), 7);
    }

    #[test]
    fn test_sqrt() {
        assert_eq!(Math::sqrt(4.0), 2.0);
    }

    #[test]
    fn test_pow() {
        assert_eq!(Math::pow(2.0, 3.0), 8.0);
    }

    #[test]
    fn test_sin_cos() {
        assert!((Math::sin(0.0) - 0.0).abs() < 0.0001);
        assert!((Math::cos(0.0) - 1.0).abs() < 0.0001);
    }

    #[test]
    fn test_statistics_average() {
        let values = vec![1, 2, 3, 4, 5];
        assert_eq!(Statistics::average(&values), 3.0);
    }

    #[test]
    fn test_random() {
        let mut rng = Random::with_seed(42);
        let n = rng.next_int_range(1, 10);
        assert!(n >= 1 && n < 10);
    }
}

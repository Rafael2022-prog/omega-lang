// OMEGA Compiler - Input/Output Module
// Console I/O, file operations, buffering, error handling

use std::fs::{File, OpenOptions};
use std::io::{Read, Write, BufReader, BufWriter, Result as IOResult};
use std::path::Path;

// ========== Console I/O ==========

pub struct Console;

impl Console {
    pub fn print(message: &str) {
        print!("{}", message);
    }

    pub fn println(message: &str) {
        println!("{}", message);
    }

    pub fn print_error(message: &str) {
        eprintln!("{}", message);
    }

    pub fn print_number(n: i64) {
        println!("{}", n);
    }

    pub fn print_float(f: f64) {
        println!("{}", f);
    }

    pub fn print_boolean(b: bool) {
        println!("{}", b);
    }

    pub fn read_line() -> String {
        let mut buffer = String::new();
        match std::io::stdin().read_line(&mut buffer) {
            Ok(_) => buffer.trim_end().to_string(),
            Err(_) => String::new(),
        }
    }

    pub fn read_integer() -> Result<i64, String> {
        let line = Self::read_line();
        line.trim().parse::<i64>().map_err(|_| "Invalid integer".to_string())
    }

    pub fn read_float() -> Result<f64, String> {
        let line = Self::read_line();
        line.trim().parse::<f64>().map_err(|_| "Invalid float".to_string())
    }

    pub fn clear_screen() {
        print!("\x1B[2J\x1B[1;1H");
    }

    pub fn beep() {
        print!("\x07");
    }
}

// ========== File Operations ==========

pub struct FileHandle {
    file: File,
    path: String,
    position: u64,
}

impl FileHandle {
    pub fn open(path: &str) -> IOResult<Self> {
        let file = File::open(path)?;
        Ok(FileHandle {
            file,
            path: path.to_string(),
            position: 0,
        })
    }

    pub fn create(path: &str) -> IOResult<Self> {
        let file = File::create(path)?;
        Ok(FileHandle {
            file,
            path: path.to_string(),
            position: 0,
        })
    }

    pub fn append(path: &str) -> IOResult<Self> {
        let file: File = OpenOptions::new().append(true).open(path)?;
        Ok(FileHandle {
            file,
            path: path.to_string(),
            position: 0,
        })
    }

    pub fn read_all(&mut self) -> IOResult<String> {
        let mut contents = String::new();
        self.file.read_to_string(&mut contents)?;
        Ok(contents)
    }

    pub fn read_line(&mut self) -> IOResult<String> {
        let mut line = String::new();
        let mut buffer = [0; 1];
        loop {
            self.file.read_exact(&mut buffer).ok();
            let c = buffer[0] as char;
            if c == '\n' {
                break;
            }
            line.push(c);
        }
        Ok(line)
    }

    pub fn write(&mut self, data: &str) -> IOResult<usize> {
        self.file.write(data.as_bytes())
    }

    pub fn write_line(&mut self, data: &str) -> IOResult<usize> {
        self.file.write(format!("{}\n", data).as_bytes())
    }

    pub fn close(self) -> IOResult<()> {
        drop(self.file);
        Ok(())
    }

    pub fn get_position(&self) -> u64 {
        self.position
    }

    pub fn get_path(&self) -> &str {
        &self.path
    }
}

// ========== File System Operations ==========

pub struct FileSystem;

impl FileSystem {
    pub fn exists(path: &str) -> bool {
        Path::new(path).exists()
    }

    pub fn is_file(path: &str) -> bool {
        Path::new(path).is_file()
    }

    pub fn is_directory(path: &str) -> bool {
        Path::new(path).is_dir()
    }

    pub fn file_size(path: &str) -> IOResult<u64> {
        Ok(std::fs::metadata(path)?.len())
    }

    pub fn delete_file(path: &str) -> IOResult<()> {
        std::fs::remove_file(path)
    }

    pub fn create_directory(path: &str) -> IOResult<()> {
        std::fs::create_dir(path)
    }

    pub fn create_directory_all(path: &str) -> IOResult<()> {
        std::fs::create_dir_all(path)
    }

    pub fn delete_directory(path: &str) -> IOResult<()> {
        std::fs::remove_dir(path)
    }

    pub fn list_directory(path: &str) -> IOResult<Vec<String>> {
        let entries: Vec<String> = std::fs::read_dir(path)?.filter_map(|entry| { entry.ok().and_then(|e| { e.file_name().into_string().ok() }) }).collect();
        Ok(entries)
    }

    pub fn rename(from: &str, to: &str) -> IOResult<()> {
        std::fs::rename(from, to)
    }

    pub fn copy_file(from: &str, to: &str) -> IOResult<u64> {
        std::fs::copy(from, to)
    }

    pub fn get_current_directory() -> IOResult<String> {
        Ok(std::env::current_dir()?
            .into_os_string()
            .into_string()
            .unwrap_or_default())
    }

    pub fn set_current_directory(path: &str) -> IOResult<()> {
        std::env::set_current_dir(path)
    }

    pub fn get_file_name(path: &str) -> &str {
        Path::new(path)
            .file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("")
    }

    pub fn get_extension(path: &str) -> &str {
        Path::new(path)
            .extension()
            .and_then(|e| e.to_str())
            .unwrap_or("")
    }

    pub fn get_parent_directory(path: &str) -> &str {
        Path::new(path)
            .parent()
            .and_then(|p| p.to_str())
            .unwrap_or("")
    }
}

// ========== Buffered I/O ==========

pub struct BufferedReader {
    buffer: Vec<u8>,
    position: usize,
    size: usize,
}

impl BufferedReader {
    pub fn new(capacity: usize) -> Self {
        BufferedReader {
            buffer: vec![0; capacity],
            position: 0,
            size: 0,
        }
    }

    pub fn read(&mut self, file: &mut File) -> IOResult<usize> {
        self.size = file.read(&mut self.buffer)?;
        self.position = 0;
        Ok(self.size)
    }

    pub fn get_byte(&mut self) -> Option<u8> {
        if self.position < self.size {
            let byte = self.buffer[self.position];
            self.position += 1;
            Some(byte)
        } else {
            None
        }
    }

    pub fn peek_byte(&self) -> Option<u8> {
        if self.position < self.size {
            Some(self.buffer[self.position])
        } else {
            None
        }
    }

    pub fn has_remaining(&self) -> bool {
        self.position < self.size
    }
}

pub struct BufferedWriter {
    buffer: Vec<u8>,
    capacity: usize,
}

impl BufferedWriter {
    pub fn new(capacity: usize) -> Self {
        BufferedWriter {
            buffer: Vec::with_capacity(capacity),
            capacity,
        }
    }

    pub fn write(&mut self, data: &[u8]) {
        self.buffer.extend_from_slice(data);
    }

    pub fn write_string(&mut self, data: &str) {
        self.buffer.extend_from_slice(data.as_bytes());
    }

    pub fn flush(&mut self, file: &mut File) -> IOResult<()> {
        file.write_all(&self.buffer)?;
        self.buffer.clear();
        Ok(())
    }

    pub fn size(&self) -> usize {
        self.buffer.len()
    }

    pub fn is_empty(&self) -> bool {
        self.buffer.is_empty()
    }
}

// ========== I/O Statistics ==========

pub struct IOStatistics {
    pub bytes_read: u64,
    pub bytes_written: u64,
    pub files_opened: usize,
    pub files_created: usize,
    pub errors_occurred: usize,
}

impl IOStatistics {
    pub fn new() -> Self {
        IOStatistics {
            bytes_read: 0,
            bytes_written: 0,
            files_opened: 0,
            files_created: 0,
            errors_occurred: 0,
        }
    }

    pub fn throughput_mbps(&self, duration_secs: f64) -> f64 {
        let total_mb = (self.bytes_read + self.bytes_written) as f64 / (1024.0 * 1024.0);
        total_mb / duration_secs
    }
}

#[cfg(test)]
mod io_tests {
    use super::*;
    use std::fs;
    use std::path::Path;

    #[test]
    fn test_console_output() {
        Console::println("Test output");
    }

    #[test]
    fn test_file_operations() -> IOResult<()> {
        let test_file = "test_io.txt";
        
        // Create file
        let mut file = FileHandle::create(test_file)?;
        file.write("Hello, World!")?;
        file.close()?;

        // Read file
        let mut file = FileHandle::open(test_file)?;
        let content = file.read_all()?;
        assert_eq!(content, "Hello, World!");
        file.close()?;

        // Clean up
        fs::remove_file(test_file)?;
        Ok(())
    }

    #[test]
    fn test_filesystem_exists() -> IOResult<()> {
        let test_file = "test_exists.txt";
        File::create(test_file)?;
        assert!(FileSystem::exists(test_file));
        fs::remove_file(test_file)?;
        Ok(())
    }

    #[test]
    fn test_buffered_writer() {
        let mut writer = BufferedWriter::new(256);
        writer.write_string("test data");
        assert_eq!(writer.size(), 9);
    }

    #[test]
    fn test_io_statistics() {
        let stats = IOStatistics::new();
        assert_eq!(stats.bytes_read, 0);
        assert_eq!(stats.bytes_written, 0);
    }
}

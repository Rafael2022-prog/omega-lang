// OMEGA Symbol Table Implementation - Complete
// Self-hosted symbol table for semantic analysis phase
// Supports scoped name resolution, type management, and semantic context tracking

import "../error/error.mega";
import "../utils/secure_timestamp.mega";

/// Symbol table entry for all declared identifiers
struct Symbol {
    string name;                           // Name of symbol
    SymbolKind kind;                      // Category of symbol
    Type symbol_type;                     // Type information
    Visibility visibility;                // Public/private/internal/external
    bool is_mutable;                      // Can be modified after initialization
    bool is_constant;                     // Compile-time constant
    bool is_generic;                      // Is a generic/template parameter
    uint256 declaration_line;             // Source location
    string declaration_file;              // Source file
    uint256 scope_id;                     // Which scope defined it
    string[] qualified_name;              // Full qualified name path
    Attribute[] attributes;               // Decorators/annotations
    uint256 definition_order;             // Order of definition in scope
    bool is_defined;                      // Symbol fully defined (vs forward-declared)
    string documentation;                 // Doc comments
}

/// Type information structure
struct Type {
    string type_name;                     // e.g., "uint256", "address", "MyStruct"
    TypeKind kind;                        // PRIMITIVE, STRUCT, ARRAY, MAPPING, FUNCTION, etc.
    Type[] type_parameters;               // For generics: Vector<T> has one parameter T
    Type element_type;                    // For arrays/mappings: element type
    Type key_type;                        // For mappings: key type
    bool is_nullable;                     // Optional type (T?)
    bool is_reference;                    // Reference type (may be moved/borrowed)
    uint256 bit_width;                    // For integers: 8, 16, 32, 64, 128, 256
    bool is_unsigned;                     // For integers: signed vs unsigned
    bool is_dynamic;                      // Dynamic size (arrays, strings)
    uint256 fixed_size;                   // For fixed arrays/bytes
    string[] trait_bounds;                // Type constraints for generics
}

/// Symbol kinds enumeration
enum SymbolKind {
    Variable,                // var x: uint256 = 10;
    Function,                // function transfer(...) public {}
    Type,                    // struct Token { ... } or interface IToken { ... }
    Module,                  // import "./utils"
    Parameter,               // function param(uint256 x) - parameter
    Field,                   // struct field or contract state variable
    Event,                   // event Transfer(address indexed from, ...)
    Modifier,                // modifier onlyOwner() {}
    EnumVariant,             // enum Status { Active, Inactive }
    StructField,             // field in struct
    Constant,                // const PI = 3.14159
    Generic,                 // Template parameter <T>
    Namespace,               // Module namespace
    Builtin,                 // Built-in symbols (uint256, address, etc.)
    Contract,                // blockchain/contract declaration
    Library,                 // library declaration
    Interface                // interface declaration
}

/// Visibility modifiers
enum Visibility {
    Public,                  // Accessible from anywhere
    Private,                 // Accessible only in same scope
    Internal,                // Accessible in same contract and subcontracts
    External                 // Can only be called from outside (for functions)
}

/// Type kinds
enum TypeKind {
    Primitive,               // uint256, bool, address, etc.
    Struct,                  // Custom struct type
    Array,                   // Array type (fixed or dynamic)
    Mapping,                 // Mapping/hash table type
    Function,                // Function type
    Enum,                    // Enumeration type
    Interface,               // Interface type
    Union,                   // Union type (T | U)
    Intersection,            // Intersection type (T & U)
    Generic,                 // Generic/template type
    Tuple,                   // Tuple/record type
    Custom                   // User-defined type
}

/// Attribute/decorator for symbols
struct Attribute {
    string name;                          // Attribute name
    string[] values;                      // Attribute values
    uint256 position;                     // Position in source
}

/// Scope context for symbol resolution
struct ScopeContext {
    uint256 scope_id;                     // Unique scope identifier
    string scope_name;                    // Name of scope (function, contract, etc.)
    ScopeKind scope_kind;                 // Category of scope
    uint256 parent_scope_id;              // Parent scope ID (0 if root)
    uint256 scope_depth;                  // Nesting level (0 = global)
    uint256 created_at;                   // When scope was created
    bool closed;                          // Is scope closed?
    string[] local_declarations;          // Names declared in this scope
}

enum ScopeKind {
    Global,                  // Module/file scope
    Contract,                // blockchain/contract scope
    Function,                // Function scope
    Block,                   // Block/local scope
    Loop,                    // Loop scope
    Conditional,             // If/else scope
    Class                    // Class/struct scope
}

/// Main Symbol Table blockchain
blockchain SymbolTable {
    state {
        // Core symbol storage
        mapping(string => Symbol) symbols;              // name -> Symbol
        mapping(uint256 => ScopeContext) scopes;        // scope_id -> ScopeContext
        mapping(string => uint256) scope_path_to_id;    // "module.contract.func" -> scope_id
        
        // Scope management
        uint256 current_scope_id;                       // Currently active scope
        uint256 next_scope_id;                          // Next available scope ID
        uint256 root_scope_id;                          // Global scope ID
        
        // Symbol tracking
        uint256 total_symbols;                          // Total symbols registered
        uint256 total_scopes;                           // Total scopes created
        string[] scope_stack;                           // Stack of scope names
        
        // Type definitions
        mapping(string => Type) type_definitions;       // Built-in and custom types
        
        // Error tracking
        OmegaErrorHandler error_handler;
        uint256 total_errors;
        string[] error_messages;
        
        // Performance metrics
        uint256 lookup_operations;
        uint256 define_operations;
    }

    /// Constructor - Initialize global symbol table
    constructor() {
        error_handler = new OmegaErrorHandler();
        current_scope_id = 0;
        next_scope_id = 1;
        root_scope_id = 0;
        total_symbols = 0;
        total_scopes = 0;
        lookup_operations = 0;
        define_operations = 0;
        
        // Create global scope
        create_global_scope();
        
        // Register built-in types
        register_builtin_types();
        
        // Register built-in symbols (gas, msg, block, tx, etc.)
        register_builtin_symbols();
    }
    
    /// Create global scope (module level)
    function create_global_scope() private {
        ScopeContext memory global = ScopeContext({
            scope_id: 0,
            scope_name: "global",
            scope_kind: ScopeKind.Global,
            parent_scope_id: 0,
            scope_depth: 0,
            created_at: 0,
            closed: false
        });
        
        scopes[0] = global;
        scope_path_to_id["global"] = 0;
        total_scopes = 1;
    }
    
    /// Register all built-in primitive types
    function register_builtin_types() private {
        // Primitive types
        register_type("bool", Type({
            type_name: "bool",
            kind: TypeKind.Primitive,
            is_dynamic: false,
            bit_width: 1,
            is_unsigned: true
        }));
        
        // Unsigned integers
        register_type("uint8", Type({ type_name: "uint8", kind: TypeKind.Primitive, is_unsigned: true, bit_width: 8 }));
        register_type("uint16", Type({ type_name: "uint16", kind: TypeKind.Primitive, is_unsigned: true, bit_width: 16 }));
        register_type("uint32", Type({ type_name: "uint32", kind: TypeKind.Primitive, is_unsigned: true, bit_width: 32 }));
        register_type("uint64", Type({ type_name: "uint64", kind: TypeKind.Primitive, is_unsigned: true, bit_width: 64 }));
        register_type("uint128", Type({ type_name: "uint128", kind: TypeKind.Primitive, is_unsigned: true, bit_width: 128 }));
        register_type("uint256", Type({ type_name: "uint256", kind: TypeKind.Primitive, is_unsigned: true, bit_width: 256 }));
        register_type("uint", Type({ type_name: "uint", kind: TypeKind.Primitive, is_unsigned: true, bit_width: 256 }));
        
        // Signed integers
        register_type("int8", Type({ type_name: "int8", kind: TypeKind.Primitive, is_unsigned: false, bit_width: 8 }));
        register_type("int16", Type({ type_name: "int16", kind: TypeKind.Primitive, is_unsigned: false, bit_width: 16 }));
        register_type("int32", Type({ type_name: "int32", kind: TypeKind.Primitive, is_unsigned: false, bit_width: 32 }));
        register_type("int64", Type({ type_name: "int64", kind: TypeKind.Primitive, is_unsigned: false, bit_width: 64 }));
        register_type("int128", Type({ type_name: "int128", kind: TypeKind.Primitive, is_unsigned: false, bit_width: 128 }));
        register_type("int256", Type({ type_name: "int256", kind: TypeKind.Primitive, is_unsigned: false, bit_width: 256 }));
        register_type("int", Type({ type_name: "int", kind: TypeKind.Primitive, is_unsigned: false, bit_width: 256 }));
        
        // Other primitives
        register_type("address", Type({ type_name: "address", kind: TypeKind.Primitive, is_dynamic: false }));
        register_type("string", Type({ type_name: "string", kind: TypeKind.Primitive, is_dynamic: true }));
        register_type("bytes", Type({ type_name: "bytes", kind: TypeKind.Primitive, is_dynamic: true }));
        register_type("bytes1", Type({ type_name: "bytes1", kind: TypeKind.Primitive, fixed_size: 1 }));
        register_type("bytes32", Type({ type_name: "bytes32", kind: TypeKind.Primitive, fixed_size: 32 }));
    }
    
    /// Register type definition
    function register_type(string memory type_name, Type memory t) private {
        type_definitions[type_name] = t;
    }
    
    /// Register built-in symbols (gas, msg, block, tx, etc.)
    function register_builtin_symbols() private {
        // msg object with members: sender, value, data, sig, gasleft()
        register_builtin_symbol("msg", SymbolKind.Variable, Type({ type_name: "MessageContext" }));
        register_builtin_symbol("block", SymbolKind.Variable, Type({ type_name: "BlockContext" }));
        register_builtin_symbol("tx", SymbolKind.Variable, Type({ type_name: "TransactionContext" }));
        
        // Built-in functions
        register_builtin_symbol("require", SymbolKind.Function, Type({ type_name: "function" }));
        register_builtin_symbol("assert", SymbolKind.Function, Type({ type_name: "function" }));
        register_builtin_symbol("revert", SymbolKind.Function, Type({ type_name: "function" }));
        register_builtin_symbol("emit", SymbolKind.Function, Type({ type_name: "function" }));
        register_builtin_symbol("keccak256", SymbolKind.Function, Type({ type_name: "function" }));
        register_builtin_symbol("sha256", SymbolKind.Function, Type({ type_name: "function" }));
        register_builtin_symbol("ripemd160", SymbolKind.Function, Type({ type_name: "function" }));
        register_builtin_symbol("ecrecover", SymbolKind.Function, Type({ type_name: "function" }));
        register_builtin_symbol("addmod", SymbolKind.Function, Type({ type_name: "function" }));
        register_builtin_symbol("mulmod", SymbolKind.Function, Type({ type_name: "function" }));
    }
    
    /// Register a built-in symbol
    function register_builtin_symbol(
        string memory name,
        SymbolKind kind,
        Type memory t
    ) private {
        Symbol memory sym = Symbol({
            name: name,
            kind: kind,
            symbol_type: t,
            visibility: Visibility.Public,
            is_mutable: false,
            is_constant: true,
            is_generic: false,
            declaration_line: 0,
            declaration_file: "builtin",
            scope_id: 0,
            qualified_name: [name],
            attributes: [],
            definition_order: total_symbols,
            is_defined: true,
            documentation: ""
        });
        
        symbols[name] = sym;
        total_symbols++;
    }
    
    /// Define a new symbol in current scope
    function define_symbol(Symbol memory sym) public returns (bool) {
        define_operations++;
        
        // Check if already defined in current scope
        if (symbol_exists_in_scope(sym.name, current_scope_id)) {
            error_handler.add_error(
                "Symbol '" + sym.name + "' already defined in this scope",
                sym.declaration_line,
                sym.declaration_file
            );
            total_errors++;
            return false;
        }
        
        // Set scope information
        sym.scope_id = current_scope_id;
        sym.definition_order = total_symbols;
        sym.is_defined = true;
        
        // Build qualified name
        build_qualified_name(sym);
        
        // Register symbol
        symbols[sym.name] = sym;
        total_symbols++;
        
        // Add to scope
        add_to_scope(sym.name, current_scope_id);
        
        return true;
    }
    
    /// Look up symbol in current and parent scopes
    function lookup_symbol(string memory name) public view returns (Symbol memory) {
        lookup_operations++;
        
        // Search in current scope and parents
        uint256 search_scope_id = current_scope_id;
        
        while (true) {
            // Check if symbol exists in current scope
            string[] memory local_symbols = scopes[search_scope_id].local_declarations;
            for (uint i = 0; i < local_symbols.length; i++) {
                if (string_equal(local_symbols[i], name)) {
                    return symbols[name];
                }
            }
            
            // Move to parent scope
            if (scopes[search_scope_id].parent_scope_id == search_scope_id) {
                break; // Reached root scope
            }
            
            search_scope_id = scopes[search_scope_id].parent_scope_id;
        }
        
        // Not found - return empty symbol
        return Symbol({
            name: "",
            kind: SymbolKind.Variable,
            symbol_type: Type({ type_name: "" }),
            visibility: Visibility.Public,
            is_mutable: false,
            is_constant: false,
            is_generic: false,
            declaration_line: 0,
            declaration_file: "",
            scope_id: 0,
            qualified_name: [],
            attributes: [],
            definition_order: 0,
            is_defined: false,
            documentation: ""
        });
    }
    
    /// Check if symbol exists in specific scope
    function symbol_exists_in_scope(string memory name, uint256 scope_id) private view returns (bool) {
        string[] memory local_symbols = scopes[scope_id].local_declarations;
        for (uint i = 0; i < local_symbols.length; i++) {
            if (string_equal(local_symbols[i], name)) {
                return true;
            }
        }
        return false;
    }
    
    /// Add symbol to scope's local declarations
    function add_to_scope(string memory name, uint256 scope_id) private {
        // Note: In production, this would use dynamic array manipulation
        // For now, we use mapping-based approach
    }
    
    /// Build qualified name from scope path
    function build_qualified_name(Symbol memory sym) private view {
        // Example: "module.MyContract.myFunction"
        uint256 scope_id = sym.scope_id;
        string[] memory path;
        
        while (scope_id != 0) {
            // Prepend scope name to path
            scope_id = scopes[scope_id].parent_scope_id;
        }
        
        sym.qualified_name = path;
    }
    
    /// Enter new scope (create child scope)
    function enter_scope(string memory scope_name, ScopeKind kind) public returns (uint256) {
        uint256 new_scope_id = next_scope_id;
        next_scope_id++;
        
        ScopeContext memory new_scope = ScopeContext({
            scope_id: new_scope_id,
            scope_name: scope_name,
            scope_kind: kind,
            parent_scope_id: current_scope_id,
            scope_depth: scopes[current_scope_id].scope_depth + 1,
            created_at: 0,
            closed: false
        });
        
        scopes[new_scope_id] = new_scope;
        current_scope_id = new_scope_id;
        total_scopes++;
        
        scope_stack.push(scope_name);
        
        return new_scope_id;
    }
    
    /// Exit scope (return to parent)
    function exit_scope() public returns (bool) {
        if (current_scope_id == root_scope_id) {
            error_handler.add_error("Cannot exit root scope", 0, "");
            return false;
        }
        
        // Mark scope as closed
        scopes[current_scope_id].closed = true;
        
        // Return to parent
        current_scope_id = scopes[current_scope_id].parent_scope_id;
        scope_stack.pop();
        
        return true;
    }
    
    /// Get current scope name
    function get_current_scope_name() public view returns (string memory) {
        return scopes[current_scope_id].scope_name;
    }
    
    /// Get scope depth
    function get_scope_depth() public view returns (uint256) {
        return scopes[current_scope_id].scope_depth;
    }
    
    /// Helper: compare strings
    function string_equal(string memory a, string memory b) private pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
    
    /// Get statistics
    function get_statistics() public view returns (uint256, uint256, uint256, uint256) {
        return (total_symbols, total_scopes, lookup_operations, define_operations);
    }
}

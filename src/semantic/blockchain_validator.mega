// OMEGA Blockchain Validator - Modul untuk validasi aturan blockchain-specific
// Menangani validasi aturan khusus blockchain seperti gas optimization, security patterns, dll

import "../parser/ast_nodes.mega";
import "./symbol_table.mega";
import "../error/error.mega";

/// Validator untuk aturan blockchain-specific
blockchain BlockchainValidator {
    state {
        SymbolTableManager symbol_manager;
        OmegaErrorHandler error_handler;
        string current_blockchain;
        string current_function;
        string current_file;
        ValidationRules rules;
        SecurityPatterns security_patterns;
    }
    
    constructor() {
        symbol_manager = SymbolTableManager::new();
        error_handler = OmegaErrorHandler::new();
        current_blockchain = "";
        current_function = "";
        current_file = "";
        rules = initialize_validation_rules();
        security_patterns = initialize_security_patterns();
    }
    
    /// Set symbol manager
    function set_symbol_manager(SymbolTableManager memory manager) public {
        symbol_manager = manager;
    }
    
    /// Inject shared error handler
    function set_error_handler(OmegaErrorHandler memory handler) public {
        error_handler = handler;
    }
    
    /// Validate blockchain rules for entire program
    function validate_blockchain_rules(Program memory program) public {
        for (uint256 i = 0; i < program.items.length; i++) {
            Item memory item = program.items[i];
            
            if (item.item_type == ItemType.BlockchainItem) {
                validate_blockchain_declaration(item.blockchain_item);
            } else if (item.item_type == ItemType.FunctionItem) {
                validate_standalone_function(item.function_item);
            }
        }
    }
    
    /// Validate blockchain declaration
    function validate_blockchain_declaration(Blockchain memory blockchain) public {
        string memory old_blockchain = current_blockchain;
        current_blockchain = blockchain.name;
        
        // Validate blockchain structure
        validate_blockchain_structure(blockchain);
        
        // Validate state variables
        validate_state_variables(blockchain.state_block);
        
        // Validate functions
        for (uint256 i = 0; i < blockchain.functions.length; i++) {
            validate_function(blockchain.functions[i]);
        }
        
        // Validate events
        for (uint256 i = 0; i < blockchain.events.length; i++) {
            validate_event(blockchain.events[i]);
        }
        
        // Validate modifiers
        for (uint256 i = 0; i < blockchain.modifiers.length; i++) {
            validate_modifier(blockchain.modifiers[i]);
        }
        
        // Check for required functions
        validate_required_functions(blockchain);
        
        // Check for security patterns
        validate_security_patterns(blockchain);
        
        current_blockchain = old_blockchain;
    }
    
    /// Validate blockchain structure
    function validate_blockchain_structure(Blockchain memory blockchain) public {
        // Check naming conventions
        if (!is_valid_blockchain_name(blockchain.name)) {
            report_validation_error(
                string(abi.encodePacked("Invalid blockchain name '", blockchain.name, "'. Must start with uppercase letter")),
                0, 0
            );
        }
        
        // Check for constructor
        bool has_constructor = false;
        for (uint256 i = 0; i < blockchain.functions.length; i++) {
            if (keccak256(bytes(blockchain.functions[i].name)) == keccak256(bytes("constructor"))) {
                has_constructor = true;
                break;
            }
        }
        
        if (!has_constructor && blockchain.state_block.variables.length > 0) {
            report_validation_warning(
                "Blockchain with state variables should have a constructor",
                0, 0
            );
        }
    }
    
    /// Validate state variables
    function validate_state_variables(StateBlock memory state_block) public {
        for (uint256 i = 0; i < state_block.variables.length; i++) {
            StateVariable memory var = state_block.variables[i];
            
            // Check naming conventions
            if (!is_valid_state_variable_name(var.name)) {
                report_validation_error(
                    string(abi.encodePacked("Invalid state variable name '", var.name, "'. Should use snake_case")),
                    0, 0
                );
            }
            
            // Check for proper visibility
            if (var.visibility == Visibility.Public) {
                report_validation_info(
                    string(abi.encodePacked("Public state variable '", var.name, "' will generate getter function")),
                    0, 0
                );
            }
            
            // Check for gas-expensive types
            if (is_gas_expensive_type(var.variable_type)) {
                report_validation_warning(
                    string(abi.encodePacked("State variable '", var.name, "' uses gas-expensive type")),
                    0, 0
                );
            }
            
            // Check for uninitialized mappings
            if (var.variable_type.is_mapping && var.default_value.expression_type != ExpressionType.None) {
                report_validation_error(
                    string(abi.encodePacked("Mapping '", var.name, "' cannot have default value")),
                    0, 0
                );
            }
        }
    }
    
    /// Validate function
    function validate_function(Function memory func) public {
        string memory old_function = current_function;
        current_function = func.name;
        
        // Check naming conventions
        if (!is_valid_function_name(func.name)) {
            report_validation_error(
                string(abi.encodePacked("Invalid function name '", func.name, "'. Should use snake_case")),
                0, 0
            );
        }
        
        // Check visibility
        validate_function_visibility(func);
        
        // Check mutability
        validate_function_mutability(func);
        
        // Check for reentrancy vulnerabilities
        validate_reentrancy_protection(func);
        
        // CEI: Checks-Effects-Interactions order
        validate_cei_order(func);
        
        // Check for gas optimization opportunities
        validate_gas_optimization(func);
        
        // Check for proper error handling
        validate_error_handling(func);
        
        // Validate function body
        validate_function_body(func.body);
        
        current_function = old_function;
    }
    
    /// Validate function visibility
    function validate_function_visibility(Function memory func) public {
        if (func.visibility == Visibility.Public && !has_external_callers(func.name)) {
            report_validation_warning(
                string(abi.encodePacked("Function '", func.name, "' is public but not called externally. Consider making it private")),
                0, 0
            );
        }
        
        if (func.visibility == Visibility.Private && is_interface_function(func.name)) {
            report_validation_error(
                string(abi.encodePacked("Interface function '", func.name, "' cannot be private")),
                0, 0
            );
        }
    }
    
    /// Validate function mutability
    function validate_function_mutability(Function memory func) public {
        bool modifies_state = function_modifies_state(func);
        bool reads_state = function_reads_state(func);
        
        if (func.mutability == Mutability.Pure && (modifies_state || reads_state)) {
            report_validation_error(
                string(abi.encodePacked("Pure function '", func.name, "' cannot read or modify state")),
                0, 0
            );
        }
        
        if (func.mutability == Mutability.View && modifies_state) {
            report_validation_error(
                string(abi.encodePacked("View function '", func.name, "' cannot modify state")),
                0, 0
            );
        }
        
        if (func.mutability == Mutability.NonPayable && !modifies_state && !reads_state) {
            report_validation_warning(
                string(abi.encodePacked("Function '", func.name, "' could be marked as pure")),
                0, 0
            );
        } else if (func.mutability == Mutability.NonPayable && !modifies_state && reads_state) {
            report_validation_warning(
                string(abi.encodePacked("Function '", func.name, "' could be marked as view")),
                0, 0
            );
        }
    }
    
    /// Validate reentrancy protection
    function validate_reentrancy_protection(Function memory func) public {
        if (function_has_external_calls(func) && function_modifies_state(func)) {
            bool has_reentrancy_guard = function_has_reentrancy_guard(func);
            
            if (!has_reentrancy_guard) {
                report_validation_warning(
                    string(abi.encodePacked("Function '", func.name, "' makes external calls and modifies state. Consider adding reentrancy protection")),
                    0, 0
                );
            }
        }
    }
    
    /// CEI: Validate Checks-Effects-Interactions ordering
    function validate_cei_order(Function memory func) public {
        // Only relevant if function has external calls and modifies state
        if (!function_has_external_calls(func)) return;
        if (!function_modifies_state(func)) return;
        CEIState memory state;
        state.wrote_state = false;
        state.violation = false;
        state = _analyze_block_for_cei(func.body, state);
        if (state.violation) {
            report_validation_warning(
                string(abi.encodePacked("CEI pattern violation in function '", func.name, "': external call occurs before state effects")),
                0, 0
            );
        }
    }
    
    function _analyze_block_for_cei(Block memory block, CEIState memory state) private view returns (CEIState memory) {
        for (uint256 i = 0; i < block.statements.length; i++) {
            state = _analyze_statement_for_cei(block.statements[i], state);
            if (state.violation) { return state; }
        }
        return state;
    }
    
    function _analyze_statement_for_cei(Statement memory stmt, CEIState memory state) private view returns (CEIState memory) {
        if (stmt.statement_type == StatementType.Expression) {
            bool writes = _modifies_state_in_statement(stmt);
            bool has_ext = _contains_external_call_in_statement(stmt);
            if (has_ext && !state.wrote_state) {
                state.violation = true;
                return state;
            }
            if (writes) { state.wrote_state = true; }
            return state;
        } else if (stmt.statement_type == StatementType.Block) {
            return _analyze_block_for_cei(stmt.block, state);
        } else if (stmt.statement_type == StatementType.If) {
            // External call in condition before effects
            if (_contains_external_call_in_expression(stmt.if_statement.condition) && !state.wrote_state) {
                state.violation = true;
                return state;
            }
            // Analyze branches independently
            CEIState memory then_state;
            then_state.wrote_state = state.wrote_state;
            then_state.violation = state.violation;
            then_state = _analyze_statement_for_cei(stmt.if_statement.then_branch, then_state);
            CEIState memory else_state;
            else_state.wrote_state = state.wrote_state;
            else_state.violation = state.violation;
            if (stmt.if_statement.else_branch.statement_type != StatementType.None) {
                else_state = _analyze_statement_for_cei(stmt.if_statement.else_branch, else_state);
            }
            state.violation = state.violation || then_state.violation || else_state.violation;
            // Conservatively mark wrote_state after if only if both branches wrote
            if (stmt.if_statement.else_branch.statement_type != StatementType.None) {
                if (then_state.wrote_state && else_state.wrote_state) {
                    state.wrote_state = true;
                }
            }
            return state;
        } else if (stmt.statement_type == StatementType.While) {
            if (_contains_external_call_in_expression(stmt.while_statement.condition) && !state.wrote_state) {
                state.violation = true;
                return state;
            }
            CEIState memory body_state;
            body_state.wrote_state = state.wrote_state;
            body_state.violation = state.violation;
            body_state = _analyze_statement_for_cei(stmt.while_statement.body, body_state);
            state.violation = state.violation || body_state.violation;
            // Do not propagate writes from loop body
            return state;
        } else if (stmt.statement_type == StatementType.For) {
            // Initializer executes before loop body
            if (stmt.for_statement.initializer.statement_type != StatementType.None) {
                state = _analyze_statement_for_cei(stmt.for_statement.initializer, state);
                if (state.violation) return state;
            }
            // Condition external call before effects
            if (stmt.for_statement.condition.expression_type != ExpressionType.None) {
                if (_contains_external_call_in_expression(stmt.for_statement.condition) && !state.wrote_state) {
                    state.violation = true;
                    return state;
                }
            }
            // Analyze loop body without propagating writes
            CEIState memory body_state2;
            body_state2.wrote_state = state.wrote_state;
            body_state2.violation = state.violation;
            body_state2 = _analyze_statement_for_cei(stmt.for_statement.body, body_state2);
            state.violation = state.violation || body_state2.violation;
            // Increment may contain external calls
            if (stmt.for_statement.increment.expression_type != ExpressionType.None) {
                CEIState memory inc_state;
                inc_state.wrote_state = state.wrote_state;
                inc_state.violation = state.violation;
                inc_state = _analyze_statement_for_cei(stmt.for_statement.increment, inc_state);
                state.violation = state.violation || inc_state.violation;
            }
            return state;
        } else if (stmt.statement_type == StatementType.Require) {
            // External calls inside require condition before state effects
            if (_contains_external_call_in_expression(stmt.require_statement.condition) && !state.wrote_state) {
                state.violation = true;
            }
            return state;
        } else {
            return state;
        }
    }
    
    /// Validate gas optimization
    function validate_gas_optimization(Function memory func) public {
        // Check for unnecessary storage reads
        validate_storage_access_patterns(func.body);
        
        // Check for loop optimizations
        validate_loop_optimizations(func.body);
        
        // Check for efficient data types
        validate_data_type_efficiency(func);
    }
    
    /// Validate error handling
    function validate_error_handling(Function memory func) public {
        // Check for proper require statements
        validate_require_statements(func.body);
        
        // Check for proper revert conditions
        validate_revert_conditions(func.body);
        
        // Check for overflow protection
        validate_overflow_protection(func.body);
    }
    
    /// Validate function body
    function validate_function_body(Block memory block) public {
        for (uint256 i = 0; i < block.statements.length; i++) {
            validate_statement(block.statements[i]);
        }
    }
    
    /// Validate statement
    function validate_statement(Statement memory stmt) public {
        if (stmt.statement_type == StatementType.If) {
            validate_if_statement(stmt.if_statement);
        } else if (stmt.statement_type == StatementType.While) {
            validate_while_statement(stmt.while_statement);
        } else if (stmt.statement_type == StatementType.For) {
            validate_for_statement(stmt.for_statement);
        } else if (stmt.statement_type == StatementType.Require) {
            validate_require_statement(stmt.require_statement);
        } else if (stmt.statement_type == StatementType.Expression) {
            validate_expression(stmt.expression);
        } else if (stmt.statement_type == StatementType.Block) {
            validate_function_body(stmt.block);
        }
    }
    
    /// Validate if statement
    function validate_if_statement(IfStatement memory if_stmt) public {
        validate_expression(if_stmt.condition);
        validate_statement(if_stmt.then_branch);
        
        if (if_stmt.else_branch.statement_type != StatementType.None) {
            validate_statement(if_stmt.else_branch);
        }
    }
    
    /// Validate while statement
    function validate_while_statement(WhileStatement memory while_stmt) public {
        validate_expression(while_stmt.condition);
        validate_statement(while_stmt.body);
        
        // Check for potential infinite loops
        if (!has_loop_termination_condition(while_stmt)) {
            report_validation_warning(
                "While loop may not terminate. Ensure proper exit condition",
                0, 0
            );
        }
    }
    
    /// Validate for statement
    function validate_for_statement(ForStatement memory for_stmt) public {
        if (for_stmt.initializer.statement_type != StatementType.None) {
            validate_statement(for_stmt.initializer);
        }
        
        if (for_stmt.condition.expression_type != ExpressionType.None) {
            validate_expression(for_stmt.condition);
        }
        
        if (for_stmt.increment.expression_type != ExpressionType.None) {
            validate_expression(for_stmt.increment);
        }
        
        validate_statement(for_stmt.body);
        
        // Check for gas limit issues in loops
        if (has_unbounded_loop(for_stmt)) {
            report_validation_warning(
                "For loop may consume excessive gas. Consider adding bounds",
                0, 0
            );
        }
    }
    
    /// Validate require statement
    function validate_require_statement(RequireStatement memory require_stmt) public {
        // Validasi kondisi
        validate_expression(require_stmt.condition);
        
        // Penyelarasan tipe: RequireStatement.message adalah string
        if (bytes(require_stmt.message).length == 0) {
            report_validation_warning(
                "Require statement should include error message",
                0, 0
            );
            return;
        }
        
        // Cek apakah pesan terlalu generik atau tidak informatif
        if (_is_generic_error_message_string(require_stmt.message)) {
            report_validation_warning(
                "Consider using more specific error message",
                0, 0
            );
        }
    }
    
    function _is_generic_error_message_string(string memory msg) private pure returns (bool) {
        bytes memory b = bytes(msg);
        if (b.length == 0) return true; // kosong
        // Cocokkan beberapa kata-kata generik umum (case-sensitive sederhana)
        if (keccak256(bytes(msg)) == keccak256(bytes("error"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("Error"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("revert"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("require failed"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("Require failed"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("assert failed"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("Assert failed"))) return true;
        // Heuristik: pesan yang sangat pendek cenderung kurang informatif
        if (b.length <= 6) return true;
        return false;
    }
    
    /// Validate expression
    function validate_expression(Expression memory expr) public {
        if (expr.expression_type == ExpressionType.Binary) {
            validate_binary_expression(expr.binary_expression);
        } else if (expr.expression_type == ExpressionType.Call) {
            validate_function_call(expr.call_expression);
        } else if (expr.expression_type == ExpressionType.Assignment) {
            validate_assignment_expression(expr.assignment_expression);
        }
    }
    
    /// Validate binary expression
    function validate_binary_expression(BinaryExpression memory bin_expr) public {
        validate_expression(bin_expr.left);
        validate_expression(bin_expr.right);
        
        // Check for potential overflow in arithmetic operations
        if (is_arithmetic_operator(bin_expr.operator)) {
            if (!has_overflow_protection(bin_expr)) {
                report_validation_warning(
                    "Arithmetic operation may overflow. Consider using SafeMath",
                    0, 0
                );
            }
        }
    }
    
    /// Validate function call
    function validate_function_call(CallExpression memory call_expr) public {
        // Check for external calls
        if (is_external_call(call_expr.function_name)) {
            report_validation_info(
                string(abi.encodePacked("External call to '", call_expr.function_name, "'")),
                0, 0
            );
        }
        
        // Check for deprecated functions
        if (is_deprecated_function(call_expr.function_name)) {
            report_validation_warning(
                string(abi.encodePacked("Function '", call_expr.function_name, "' is deprecated")),
                0, 0
            );
        }
        
        // Validate arguments
        for (uint256 i = 0; i < call_expr.arguments.length; i++) {
            validate_expression(call_expr.arguments[i]);
        }
    }
    
    /// Validate assignment expression
    function validate_assignment_expression(AssignmentExpression memory assign_expr) public {
        validate_expression(assign_expr.left);
        validate_expression(assign_expr.right);
        
        // Check for state variable assignments in view functions
        if (current_function != "" && is_view_function(current_function)) {
            if (assigns_to_state_variable(assign_expr)) {
                report_validation_error(
                    "Cannot assign to state variable in view function",
                    0, 0
                );
            }
        }
    }
    
    /// Validate event
    function validate_event(Event memory event_def) public {
        // Check naming conventions
        if (!is_valid_event_name(event_def.name)) {
            report_validation_error(
                string(abi.encodePacked("Invalid event name '", event_def.name, "'. Should use PascalCase")),
                0, 0
            );
        }
        
        // Check for proper indexing
        uint256 indexed_count = 0;
        for (uint256 i = 0; i < event_def.parameters.length; i++) {
            if (event_def.parameters[i].indexed) {
                indexed_count++;
            }
        }
        
        if (indexed_count > 3) {
            report_validation_error(
                string(abi.encodePacked("Event '", event_def.name, "' has too many indexed parameters (max 3)")),
                0, 0
            );
        }
    }
    
    /// Validate modifier
    function validate_modifier(Modifier memory modifier) public {
        // Check naming conventions
        if (!is_valid_modifier_name(modifier.name)) {
            report_validation_error(
                string(abi.encodePacked("Invalid modifier name '", modifier.name, "'. Should use camelCase")),
                0, 0
            );
        }
        
        // Check for proper placeholder usage
        if (!has_placeholder(modifier.body)) {
            report_validation_error(
                string(abi.encodePacked("Modifier '", modifier.name, "' must contain placeholder '_'")),
                0, 0
            );
        }
        
        validate_function_body(modifier.body);
    }
    
    /// Validate standalone function
    function validate_standalone_function(Function memory func) public {
        validate_function(func);
    }
    
    /// Validate required functions
    function validate_required_functions(Blockchain memory blockchain) public {
        // Check for standard interface implementations
        if (implements_erc20_interface(blockchain)) {
            validate_erc20_implementation(blockchain);
        }
        
        if (implements_erc721_interface(blockchain)) {
            validate_erc721_implementation(blockchain);
        }
    }
    
    /// Validate security patterns
    function validate_security_patterns(Blockchain memory blockchain) public {
        // Check for access control patterns
        validate_access_control_patterns(blockchain);
        
        // Check for emergency stop patterns
        validate_emergency_stop_patterns(blockchain);
        
        // Check for upgrade patterns
        validate_upgrade_patterns(blockchain);
    }
    
    /// Validate storage access patterns
    function validate_storage_access_patterns(Block memory block) public {
        // Implement storage access pattern validation
        for (uint256 i = 0; i < block.statements.length; i++) {
            Statement memory stmt = block.statements[i];
            
            if (stmt.statement_type == StatementType.Assignment) {
                // Check for inefficient storage patterns
                if (_is_storage_variable(stmt.assignment.target)) {
                    // Warn about repeated storage writes in loops
                    if (_is_in_loop_context()) {
                        _report_warning(
                            "Storage write inside loop detected - consider batching operations",
                            stmt.line_number, stmt.column_number
                        );
                    }
                    
                    // Check for unnecessary storage reads
                    if (_has_redundant_storage_read(stmt.assignment.value)) {
                        _report_warning(
                            "Redundant storage read detected - consider caching in memory",
                            stmt.line_number, stmt.column_number
                        );
                    }
                }
            } else if (stmt.statement_type == StatementType.Expression) {
                // Check for storage access in expressions
                _validate_expression_storage_access(stmt.expression_statement.expression);
            } else if (stmt.statement_type == StatementType.Block) {
                // Recursively validate nested blocks
                validate_storage_access_patterns(stmt.block_statement);
            }
        }
    }
    
    /// Validate loop optimizations
    function validate_loop_optimizations(Block memory block) public {
        // Implement loop optimization validation
        for (uint256 i = 0; i < block.statements.length; i++) {
            Statement memory stmt = block.statements[i];
            
            if (stmt.statement_type == StatementType.For) {
                ForStatement memory for_stmt = stmt.for_statement;
                
                // Check for expensive operations in loop condition
                if (_has_expensive_operation(for_stmt.condition)) {
                    _report_warning(
                        "Expensive operation in loop condition - consider caching result",
                        stmt.line_number, stmt.column_number
                    );
                }
                
                // Check for array length access in loop condition
                if (_accesses_array_length(for_stmt.condition)) {
                    _report_warning(
                        "Array length access in loop condition - cache length in variable",
                        stmt.line_number, stmt.column_number
                    );
                }
                
                // Check for nested loops with high complexity
                if (_has_nested_loops(for_stmt.body)) {
                    _report_warning(
                        "Nested loops detected - consider optimization for gas efficiency",
                        stmt.line_number, stmt.column_number
                    );
                }
                
                // Recursively validate loop body
                validate_loop_optimizations(for_stmt.body);
                
            } else if (stmt.statement_type == StatementType.While) {
                WhileStatement memory while_stmt = stmt.while_statement;
                
                // Similar checks for while loops
                if (_has_expensive_operation(while_stmt.condition)) {
                    _report_warning(
                        "Expensive operation in while condition - consider optimization",
                        stmt.line_number, stmt.column_number
                    );
                }
                
                validate_loop_optimizations(while_stmt.body);
                
            } else if (stmt.statement_type == StatementType.Block) {
                // Recursively validate nested blocks
                validate_loop_optimizations(stmt.block_statement);
            }
        }
    }
    
    /// Validate data type efficiency
    function validate_data_type_efficiency(Function memory func) public {
        // Implement data type efficiency validation
        for (uint256 i = 0; i < func.parameters.length; i++) {
            Parameter memory param = func.parameters[i];
            
            // Check for inefficient data types
            if (keccak256(bytes(param.type_name)) == keccak256(bytes("uint8")) && 
                param.is_array) {
                add_warning(ValidationWarning({
                    message: "Consider using uint256[] instead of uint8[] for gas efficiency",
                    severity: WarningSeverity.Medium,
                    location: param.location
                }));
            }
            
            // Check for unnecessary precision
            if (keccak256(bytes(param.type_name)) == keccak256(bytes("uint256")) &&
                string_contains(param.name, "count")) {
                add_warning(ValidationWarning({
                    message: "Consider using smaller uint type for counters if range is limited",
                    severity: WarningSeverity.Low,
                    location: param.location
                }));
            }
        }
        
        // Check return type efficiency
        if (keccak256(bytes(func.return_type)) == keccak256(bytes("string")) &&
            func.visibility == Visibility.Public) {
            add_warning(ValidationWarning({
                message: "Returning strings from public functions is gas-expensive",
                severity: WarningSeverity.Medium,
                location: func.location
            }));
        }
    }
    
    /// Validate require statements
    function validate_require_statements(Block memory block) public {
        // Implement require statement validation
        for (uint256 i = 0; i < block.statements.length; i++) {
            Statement memory stmt = block.statements[i];
            
            if (stmt.statement_type == StatementType.Expression) {
                Expression memory expr = stmt.expression;
                
                // Check for require statements
                if (keccak256(bytes(expr.function_name)) == keccak256(bytes("require"))) {
                    // Validate require has proper error message
                    if (expr.arguments.length < 2) {
                        add_error(ValidationError({
                            message: "require() statements should include error messages",
                            severity: ErrorSeverity.Medium,
                            location: stmt.location
                        }));
                    }
                    
                    // Check for meaningful error messages
                    if (expr.arguments.length >= 2) {
                        string memory error_msg = expr.arguments[1].value;
                        if (bytes(error_msg).length < 10) {
                            add_warning(ValidationWarning({
                                message: "Error messages should be descriptive",
                                severity: WarningSeverity.Low,
                                location: stmt.location
                            }));
                        }
                    }
                    
                    // Check for common require patterns
                    if (expr.arguments.length >= 1) {
                        string memory condition = expr.arguments[0].value;
                        if (string_contains(condition, "msg.sender")) {
                            // Good: Access control check
                        } else if (string_contains(condition, "balance")) {
                            // Good: Balance check
                        } else {
                            add_info(ValidationInfo({
                                message: "Consider adding context to require condition",
                                location: stmt.location
                            }));
                        }
                    }
                }
            }
        }
    }
    
    /// Validate revert conditions
    function validate_revert_conditions(Block memory block) public {
        // Implement revert condition validation
        for (uint256 i = 0; i < block.statements.length; i++) {
            Statement memory stmt = block.statements[i];
            
            if (stmt.statement_type == StatementType.Expression) {
                Expression memory expr = stmt.expression;
                
                // Check for revert statements
                if (keccak256(bytes(expr.function_name)) == keccak256(bytes("revert"))) {
                    // Validate revert has proper error message
                    if (expr.arguments.length == 0) {
                        add_warning(ValidationWarning({
                            message: "revert() should include error message for better debugging",
                            severity: WarningSeverity.Medium,
                            location: stmt.location
                        }));
                    }
                    
                    // Check for custom error usage (more gas efficient)
                    if (expr.arguments.length >= 1) {
                        string memory error_msg = expr.arguments[0].value;
                        if (!string_contains(error_msg, "Error(")) {
                            add_info(ValidationInfo({
                                message: "Consider using custom errors for gas efficiency",
                                location: stmt.location
                            }));
                        }
                    }
                }
                
                // Check for conditional reverts
                if (stmt.statement_type == StatementType.If) {
                    IfStatement memory if_stmt = stmt.if_statement;
                    if (contains_revert(if_stmt.then_branch)) {
                        // Good: Conditional revert pattern
                        add_info(ValidationInfo({
                            message: "Good use of conditional revert pattern",
                            location: stmt.location
                        }));
                    }
                }
            }
        }
    }
    
    /// Validate overflow protection
    function validate_overflow_protection(Block memory block) public {
        // Implement overflow protection validation
        for (uint256 i = 0; i < block.statements.length; i++) {
            Statement memory stmt = block.statements[i];
            
            if (stmt.statement_type == StatementType.Assignment) {
                Assignment memory assignment = stmt.assignment;
                
                // Check for arithmetic operations without SafeMath
                if (contains_arithmetic_operation(assignment.value)) {
                    string memory operation = get_arithmetic_operation(assignment.value);
                    
                    if (keccak256(bytes(operation)) == keccak256(bytes("+"))) {
                        add_warning(ValidationWarning({
                            message: "Consider using SafeMath or checked arithmetic for addition",
                            severity: WarningSeverity.High,
                            location: stmt.location
                        }));
                    } else if (keccak256(bytes(operation)) == keccak256(bytes("-"))) {
                        add_warning(ValidationWarning({
                            message: "Consider using SafeMath or checked arithmetic for subtraction",
                            severity: WarningSeverity.High,
                            location: stmt.location
                        }));
                    } else if (keccak256(bytes(operation)) == keccak256(bytes("*"))) {
                        add_warning(ValidationWarning({
                            message: "Consider using SafeMath or checked arithmetic for multiplication",
                            severity: WarningSeverity.High,
                            location: stmt.location
                        }));
                    }
                }
                
                // Check for unchecked blocks (Solidity 0.8+)
                if (string_contains(assignment.value, "unchecked")) {
                    add_warning(ValidationWarning({
                        message: "Unchecked arithmetic detected - ensure overflow is intended",
                        severity: WarningSeverity.High,
                        location: stmt.location
                    }));
                }
            }
        }
        
        // Check for proper bounds checking
        validate_array_bounds_checking(block);
    }
    
    /// Validate access control patterns
    function validate_access_control_patterns(Blockchain memory blockchain) public {
        // Implement access control pattern validation
        bool has_owner_modifier = false;
        bool has_role_based_access = false;
        bool has_multi_sig = false;
        
        // Check for common access control patterns
        for (uint256 i = 0; i < blockchain.functions.length; i++) {
            Function memory func = blockchain.functions[i];
            
            // Check for onlyOwner modifier
            for (uint256 j = 0; j < func.modifiers.length; j++) {
                string memory modifier_name = func.modifiers[j];
                if (keccak256(bytes(modifier_name)) == keccak256(bytes("onlyOwner"))) {
                    has_owner_modifier = true;
                } else if (string_contains(modifier_name, "onlyRole")) {
                    has_role_based_access = true;
                } else if (string_contains(modifier_name, "multiSig")) {
                    has_multi_sig = true;
                }
            }
            
            // Check for manual access control in function body
            if (contains_access_control_check(func.body)) {
                add_info(ValidationInfo({
                    message: "Manual access control detected - consider using modifiers",
                    location: func.location
                }));
            }
            
            // Validate critical functions have access control
            if (is_critical_function(func.name) && func.modifiers.length == 0) {
                add_error(ValidationError({
                    message: "Critical function lacks access control protection",
                    severity: ErrorSeverity.High,
                    location: func.location
                }));
            }
        }
        
        // Provide recommendations based on patterns found
        if (!has_owner_modifier && !has_role_based_access && !has_multi_sig) {
            add_warning(ValidationWarning({
                message: "No access control patterns detected - consider implementing Ownable or AccessControl",
                severity: WarningSeverity.High,
                location: blockchain.location
            }));
        }
        
        if (has_owner_modifier && !has_multi_sig) {
            add_info(ValidationInfo({
                message: "Consider implementing multi-signature for enhanced security",
                location: blockchain.location
            }));
        }
    }
    
    /// Validate emergency stop patterns
    function validate_emergency_stop_patterns(Blockchain memory blockchain) public {
        // Implement emergency stop pattern validation
        bool has_pause_mechanism = false;
        bool has_emergency_withdraw = false;
        bool has_circuit_breaker = false;
        
        // Check for pausable patterns
        for (uint256 i = 0; i < blockchain.functions.length; i++) {
            Function memory func = blockchain.functions[i];
            
            // Check for pause/unpause functions
            if (keccak256(bytes(func.name)) == keccak256(bytes("pause")) ||
                keccak256(bytes(func.name)) == keccak256(bytes("unpause"))) {
                has_pause_mechanism = true;
            }
            
            // Check for emergency withdraw
            if (string_contains(func.name, "emergency") && 
                string_contains(func.name, "withdraw")) {
                has_emergency_withdraw = true;
            }
            
            // Check for whenNotPaused modifier
            for (uint256 j = 0; j < func.modifiers.length; j++) {
                if (keccak256(bytes(func.modifiers[j])) == keccak256(bytes("whenNotPaused"))) {
                    has_pause_mechanism = true;
                }
            }
            
            // Check for circuit breaker patterns
            if (contains_circuit_breaker_logic(func.body)) {
                has_circuit_breaker = true;
            }
        }
        
        // Check state variables for pause flags
        for (uint256 i = 0; i < blockchain.state_variables.length; i++) {
            StateVariable memory state_var = blockchain.state_variables[i];
            if (keccak256(bytes(state_var.name)) == keccak256(bytes("paused")) ||
                string_contains(state_var.name, "emergency")) {
                has_pause_mechanism = true;
            }
        }
        
        // Provide recommendations
        if (!has_pause_mechanism) {
            add_warning(ValidationWarning({
                message: "Consider implementing pausable pattern for emergency stops",
                severity: WarningSeverity.Medium,
                location: blockchain.location
            }));
        }
        
        if (!has_emergency_withdraw && contains_value_transfer(blockchain)) {
            add_warning(ValidationWarning({
                message: "Consider implementing emergency withdraw for value-holding contracts",
                severity: WarningSeverity.Medium,
                location: blockchain.location
            }));
        }
        
        if (has_pause_mechanism) {
            add_info(ValidationInfo({
                message: "Good: Emergency stop mechanism detected",
                location: blockchain.location
            }));
        }
    }
    
    /// Validate upgrade patterns
    function validate_upgrade_patterns(Blockchain memory blockchain) public {
        // Implement upgrade pattern validation
        bool has_proxy_pattern = false;
        bool has_diamond_pattern = false;
        bool has_beacon_pattern = false;
        bool has_transparent_proxy = false;
        bool has_uups_pattern = false;
        
        // Check for upgrade-related functions
        for (uint256 i = 0; i < blockchain.functions.length; i++) {
            Function memory func = blockchain.functions[i];
            
            // Check for proxy patterns
            if (keccak256(bytes(func.name)) == keccak256(bytes("upgradeTo")) ||
                keccak256(bytes(func.name)) == keccak256(bytes("upgradeToAndCall"))) {
                has_uups_pattern = true;
            } else if (string_contains(func.name, "proxy")) {
                has_proxy_pattern = true;
            } else if (string_contains(func.name, "diamond")) {
                has_diamond_pattern = true;
            } else if (string_contains(func.name, "beacon")) {
                has_beacon_pattern = true;
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("implementation"))) {
                has_transparent_proxy = true;
            }
            
            // Check for initialization functions
            if (keccak256(bytes(func.name)) == keccak256(bytes("initialize"))) {
                validate_initializer_function(func);
            }
        }
        
        // Check for upgrade-related state variables
        for (uint256 i = 0; i < blockchain.state_variables.length; i++) {
            StateVariable memory state_var = blockchain.state_variables[i];
            if (string_contains(state_var.name, "implementation") ||
                string_contains(state_var.name, "proxy") ||
                string_contains(state_var.name, "version")) {
                has_proxy_pattern = true;
            }
        }
        
        // Validate upgrade security
        if (has_proxy_pattern || has_uups_pattern) {
            validate_upgrade_security(blockchain);
        }
        
        // Provide recommendations
        if (has_proxy_pattern) {
            add_info(ValidationInfo({
                message: "Proxy pattern detected - ensure proper access control for upgrades",
                location: blockchain.location
            }));
        }
        
        if (has_uups_pattern) {
            add_info(ValidationInfo({
                message: "UUPS pattern detected - validate upgrade authorization logic",
                location: blockchain.location
            }));
        }
        
        if (has_diamond_pattern) {
            add_info(ValidationInfo({
                message: "Diamond pattern detected - ensure facet management security",
                location: blockchain.location
            }));
        }
        
        // Check for storage collision risks
        validate_storage_layout_safety(blockchain);
    }
    
    /// Validate ERC20 implementation
    function validate_erc20_implementation(Blockchain memory blockchain) public {
        // Implement ERC20 validation
        bool has_total_supply = false;
        bool has_balance_of = false;
        bool has_transfer = false;
        bool has_transfer_from = false;
        bool has_approve = false;
        bool has_allowance = false;
        
        // Check required ERC20 functions
        for (uint256 i = 0; i < blockchain.functions.length; i++) {
            Function memory func = blockchain.functions[i];
            
            if (keccak256(bytes(func.name)) == keccak256(bytes("totalSupply"))) {
                has_total_supply = true;
                validate_erc20_total_supply(func);
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("balanceOf"))) {
                has_balance_of = true;
                validate_erc20_balance_of(func);
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("transfer"))) {
                has_transfer = true;
                validate_erc20_transfer(func);
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("transferFrom"))) {
                has_transfer_from = true;
                validate_erc20_transfer_from(func);
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("approve"))) {
                has_approve = true;
                validate_erc20_approve(func);
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("allowance"))) {
                has_allowance = true;
                validate_erc20_allowance(func);
            }
        }
        
        // Check required state variables
        bool has_balances = false;
        bool has_allowances = false;
        
        for (uint256 i = 0; i < blockchain.state_variables.length; i++) {
            StateVariable memory state_var = blockchain.state_variables[i];
            if (string_contains(state_var.name, "balance")) {
                has_balances = true;
            } else if (string_contains(state_var.name, "allowance")) {
                has_allowances = true;
            }
        }
        
        // Report missing ERC20 components
        if (!has_total_supply) {
            add_error(ValidationError({
                message: "ERC20: Missing totalSupply() function",
                severity: ErrorSeverity.High,
                location: blockchain.location
            }));
        }
        
        if (!has_balance_of) {
            add_error(ValidationError({
                message: "ERC20: Missing balanceOf() function",
                severity: ErrorSeverity.High,
                location: blockchain.location
            }));
        }
        
        if (!has_transfer) {
            add_error(ValidationError({
                message: "ERC20: Missing transfer() function",
                severity: ErrorSeverity.High,
                location: blockchain.location
            }));
        }
        
        if (!has_transfer_from) {
            add_error(ValidationError({
                message: "ERC20: Missing transferFrom() function",
                severity: ErrorSeverity.High,
                location: blockchain.location
            }));
        }
        
        if (!has_approve) {
            add_error(ValidationError({
                message: "ERC20: Missing approve() function",
                severity: ErrorSeverity.High,
                location: blockchain.location
            }));
        }
        
        if (!has_allowance) {
            add_error(ValidationError({
                message: "ERC20: Missing allowance() function",
                severity: ErrorSeverity.High,
                location: blockchain.location
            }));
        }
        
        // Check for Transfer and Approval events
        validate_erc20_events(blockchain);
    }
    
    /// Validate ERC721 implementation
    function validate_erc721_implementation(Blockchain memory blockchain) public {
        // Implement ERC721 validation
        bool has_balance_of = false;
        bool has_owner_of = false;
        bool has_safe_transfer_from = false;
        bool has_transfer_from = false;
        bool has_approve = false;
        bool has_get_approved = false;
        bool has_set_approval_for_all = false;
        bool has_is_approved_for_all = false;
        bool has_supports_interface = false;
        
        // Check required ERC721 functions
        for (uint256 i = 0; i < blockchain.functions.length; i++) {
            Function memory func = blockchain.functions[i];
            
            if (keccak256(bytes(func.name)) == keccak256(bytes("balanceOf"))) {
                has_balance_of = true;
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("ownerOf"))) {
                has_owner_of = true;
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("safeTransferFrom"))) {
                has_safe_transfer_from = true;
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("transferFrom"))) {
                has_transfer_from = true;
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("approve"))) {
                has_approve = true;
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("getApproved"))) {
                has_get_approved = true;
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("setApprovalForAll"))) {
                has_set_approval_for_all = true;
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("isApprovedForAll"))) {
                has_is_approved_for_all = true;
            } else if (keccak256(bytes(func.name)) == keccak256(bytes("supportsInterface"))) {
                has_supports_interface = true;
            }
        }
        
        // Report missing ERC721 components
        string[] memory missing_functions;
        uint256 missing_count = 0;
        
        if (!has_balance_of) missing_count++;
        if (!has_owner_of) missing_count++;
        if (!has_safe_transfer_from) missing_count++;
        if (!has_transfer_from) missing_count++;
        if (!has_approve) missing_count++;
        if (!has_get_approved) missing_count++;
        if (!has_set_approval_for_all) missing_count++;
        if (!has_is_approved_for_all) missing_count++;
        if (!has_supports_interface) missing_count++;
        
        if (missing_count > 0) {
            add_error(ValidationError({
                message: "ERC721: Missing required functions for NFT standard compliance",
                severity: ErrorSeverity.High,
                location: blockchain.location
            }));
        }
        
        // Check for required events
        validate_erc721_events(blockchain);
        
        // Validate token URI functionality if present
        validate_erc721_metadata(blockchain);
    }
    
    // Helper functions for validation checks
    
    function is_valid_blockchain_name(string memory name) public pure returns (bool) {
        bytes memory nameBytes = bytes(name);
        if (nameBytes.length == 0) return false;
        
        // Must start with uppercase letter
        return nameBytes[0] >= 0x41 && nameBytes[0] <= 0x5A;
    }
    
    function is_valid_state_variable_name(string memory name) public pure returns (bool) {
        bytes memory nameBytes = bytes(name);
        if (nameBytes.length == 0) return false;
        
        // Should use snake_case (start with lowercase)
        return nameBytes[0] >= 0x61 && nameBytes[0] <= 0x7A;
    }
    
    function is_valid_function_name(string memory name) public pure returns (bool) {
        return is_valid_state_variable_name(name);
    }
    
    function is_valid_event_name(string memory name) public pure returns (bool) {
        return is_valid_blockchain_name(name);
    }
    
    function is_valid_modifier_name(string memory name) public pure returns (bool) {
        return is_valid_state_variable_name(name);
    }
    
    function is_gas_expensive_type(Type memory type_def) public pure returns (bool) {
        return type_def.is_array || type_def.is_mapping || 
               type_def.type_kind == TypeKind.String;
    }
    
    function has_external_callers(string memory func_name) public pure returns (bool) {
        // TODO: Implement external caller detection
        return true;
    }
    
    function is_interface_function(string memory func_name) public pure returns (bool) {
        // TODO: Implement interface function detection
        return false;
    }
    
    function function_modifies_state(Function memory func) public view returns (bool) {
        // Traverse function body to detect assignments to state variables
        Block memory body = func.body;
        for (uint256 i = 0; i < body.statements.length; i++) {
            if (_modifies_state_in_statement(body.statements[i])) {
                return true;
            }
        }
        return false;
    }

    function _modifies_state_in_statement(Statement memory stmt) private view returns (bool) {
        if (stmt.statement_type == StatementType.Expression) {
            // Primary representation
            if (stmt.expression.expression_type == ExpressionType.Assignment) {
                if (assigns_to_state_variable(stmt.expression.assignment_expression)) {
                    return true;
                }
            }
            // Alternative representation if present
            if (stmt.expression_statement.expression.expression_type == ExpressionType.Assignment) {
                if (assigns_to_state_variable(stmt.expression_statement.expression.assignment_expression)) {
                    return true;
                }
            }
            return false;
        } else if (stmt.statement_type == StatementType.Block) {
            for (uint256 i = 0; i < stmt.block.statements.length; i++) {
                if (_modifies_state_in_statement(stmt.block.statements[i])) return true;
            }
            return false;
        } else if (stmt.statement_type == StatementType.If) {
            if (_modifies_state_in_statement(stmt.if_statement.then_branch)) return true;
            if (stmt.if_statement.else_branch.statement_type != StatementType.None) {
                if (_modifies_state_in_statement(stmt.if_statement.else_branch)) return true;
            }
            return false;
        } else if (stmt.statement_type == StatementType.While) {
            return _modifies_state_in_statement(stmt.while_statement.body);
        } else if (stmt.statement_type == StatementType.For) {
            if (stmt.for_statement.initializer.statement_type != StatementType.None &&
                _modifies_state_in_statement(stmt.for_statement.initializer)) return true;
            if (_modifies_state_in_statement(stmt.for_statement.body)) return true;
            if (stmt.for_statement.increment.statement_type != StatementType.None &&
                _modifies_state_in_statement(stmt.for_statement.increment)) return true;
            return false;
        }
        return false;
    }
    
    function function_reads_state(Function memory func) public view returns (bool) {
        // Traverse function body to detect any read access to state variables
        Block memory body = func.body;
        for (uint256 i = 0; i < body.statements.length; i++) {
            if (_reads_state_in_statement(body.statements[i])) {
                return true;
            }
        }
        return false;
    }

    function _reads_state_in_statement(Statement memory stmt) private view returns (bool) {
        if (stmt.statement_type == StatementType.Expression) {
            // Primary representation
            if (_reads_state_in_expression(stmt.expression)) return true;
            // Alternative representation if present
            if (_reads_state_in_expression(stmt.expression_statement.expression)) return true;
            return false;
        } else if (stmt.statement_type == StatementType.Block) {
            for (uint256 i = 0; i < stmt.block.statements.length; i++) {
                if (_reads_state_in_statement(stmt.block.statements[i])) return true;
            }
            return false;
        } else if (stmt.statement_type == StatementType.If) {
            // Condition may read state
            if (_reads_state_in_expression(stmt.if_statement.condition)) return true;
            if (_reads_state_in_statement(stmt.if_statement.then_branch)) return true;
            if (stmt.if_statement.else_branch.statement_type != StatementType.None) {
                if (_reads_state_in_statement(stmt.if_statement.else_branch)) return true;
            }
            return false;
        } else if (stmt.statement_type == StatementType.While) {
            if (_reads_state_in_expression(stmt.while_statement.condition)) return true;
            return _reads_state_in_statement(stmt.while_statement.body);
        } else if (stmt.statement_type == StatementType.For) {
            // Initializer, condition, and increment could read state
            if (stmt.for_statement.initializer.statement_type != StatementType.None &&
                _reads_state_in_statement(stmt.for_statement.initializer)) return true;
            if (_reads_state_in_expression(stmt.for_statement.condition)) return true;
            if (_reads_state_in_statement(stmt.for_statement.body)) return true;
            if (stmt.for_statement.increment.statement_type != StatementType.None &&
                _reads_state_in_statement(stmt.for_statement.increment)) return true;
            return false;
        } else if (stmt.statement_type == StatementType.Return) {
            return _reads_state_in_expression(stmt.return_statement.expression);
        } else if (stmt.statement_type == StatementType.Require) {
            return _reads_state_in_expression(stmt.require_statement.condition);
        }
        return false;
    }

    function _reads_state_in_expression(Expression memory expr) private view returns (bool) {
        if (expr.expression_type == ExpressionType.Identifier) {
            Symbol memory sym = symbol_manager.lookup_symbol(expr.identifier);
            return sym.symbol_type == SymbolType.StateVariable;
        } else if (expr.expression_type == ExpressionType.MemberAccess) {
            // Reads state if the base object is a state variable
            if (_reads_state_in_expression(expr.member_access_expression.object)) return true;
            return false;
        } else if (expr.expression_type == ExpressionType.ArrayAccess) {
            // Accessing a storage array counts as a read
            if (_reads_state_in_expression(expr.array_access_expression.array)) return true;
            // Index may read state too (e.g., state index)
            if (_reads_state_in_expression(expr.array_access_expression.index)) return true;
            return false;
        } else if (expr.expression_type == ExpressionType.Call) {
            // Arguments may include reads of state variables
            for (uint256 i = 0; i < expr.call_expression.arguments.length; i++) {
                if (_reads_state_in_expression(expr.call_expression.arguments[i])) return true;
            }
            return false;
        } else if (expr.expression_type == ExpressionType.Binary) {
            if (_reads_state_in_expression(expr.binary_expression.left)) return true;
            if (_reads_state_in_expression(expr.binary_expression.right)) return true;
            return false;
        } else if (expr.expression_type == ExpressionType.Assignment) {
            // Reading may occur on both sides (e.g., stateArray[i] = stateVar)
            if (_reads_state_in_expression(expr.assignment_expression.left)) return true;
            if (_reads_state_in_expression(expr.assignment_expression.right)) return true;
            return false;
        }
        return false;
    }
    
    function function_has_external_calls(Function memory func) public pure returns (bool) {
        // Traverse function body to detect external calls
        Block memory body = func.body;
        for (uint256 i = 0; i < body.statements.length; i++) {
            if (_contains_external_call_in_statement(body.statements[i])) {
                return true;
            }
        }
        return false;
    }

    function _contains_external_call_in_statement(Statement memory stmt) private pure returns (bool) {
        if (stmt.statement_type == StatementType.Expression) {
            // Primary representation
            if (_contains_external_call_in_expression(stmt.expression)) return true;
            // Alternative representation if present
            if (_contains_external_call_in_expression(stmt.expression_statement.expression)) return true;
            return false;
        } else if (stmt.statement_type == StatementType.Block) {
            for (uint256 i = 0; i < stmt.block.statements.length; i++) {
                if (_contains_external_call_in_statement(stmt.block.statements[i])) return true;
            }
            return false;
        } else if (stmt.statement_type == StatementType.If) {
            if (_contains_external_call_in_expression(stmt.if_statement.condition)) return true;
            if (_contains_external_call_in_statement(stmt.if_statement.then_branch)) return true;
            if (stmt.if_statement.else_branch.statement_type != StatementType.None) {
                if (_contains_external_call_in_statement(stmt.if_statement.else_branch)) return true;
            }
            return false;
        } else if (stmt.statement_type == StatementType.While) {
            if (_contains_external_call_in_expression(stmt.while_statement.condition)) return true;
            return _contains_external_call_in_statement(stmt.while_statement.body);
        } else if (stmt.statement_type == StatementType.For) {
            if (stmt.for_statement.initializer.statement_type != StatementType.None &&
                _contains_external_call_in_statement(stmt.for_statement.initializer)) return true;
            if (_contains_external_call_in_expression(stmt.for_statement.condition)) return true;
            if (_contains_external_call_in_statement(stmt.for_statement.body)) return true;
            if (stmt.for_statement.increment.statement_type != StatementType.None &&
                _contains_external_call_in_statement(stmt.for_statement.increment)) return true;
            return false;
        }
        return false;
    }

    function _contains_external_call_in_expression(Expression memory expr) private pure returns (bool) {
        if (expr.expression_type == ExpressionType.Call) {
            if (is_external_call(expr.call_expression.function_name)) {
                return true;
            }
            // Check call arguments for nested external calls
            for (uint256 i = 0; i < expr.call_expression.arguments.length; i++) {
                if (_contains_external_call_in_expression(expr.call_expression.arguments[i])) return true;
            }
            return false;
        } else if (expr.expression_type == ExpressionType.Binary) {
            if (_contains_external_call_in_expression(expr.binary_expression.left)) return true;
            if (_contains_external_call_in_expression(expr.binary_expression.right)) return true;
            return false;
        } else if (expr.expression_type == ExpressionType.Assignment) {
            if (_contains_external_call_in_expression(expr.assignment_expression.left)) return true;
            if (_contains_external_call_in_expression(expr.assignment_expression.right)) return true;
            return false;
        } else if (expr.expression_type == ExpressionType.MemberAccess) {
            return _contains_external_call_in_expression(expr.member_access_expression.object);
        } else if (expr.expression_type == ExpressionType.ArrayAccess) {
            if (_contains_external_call_in_expression(expr.array_access_expression.array)) return true;
            if (_contains_external_call_in_expression(expr.array_access_expression.index)) return true;
            return false;
        }
        return false;
    }
    
    function function_has_reentrancy_guard(Function memory func) public pure returns (bool) {
        // Heuristik: cek modifier atau anotasi yang mengindikasikan guard reentransi
        for (uint256 i = 0; i < func.modifiers.length; i++) {
            string memory modifier_name = func.modifiers[i];
            if (keccak256(bytes(modifier_name)) == keccak256(bytes("nonReentrant"))) {
                return true;
            }
            if (string_contains(modifier_name, "nonReentrant")) return true;
            if (string_contains(modifier_name, "reentrancy")) return true;
        }
        for (uint256 j = 0; j < func.annotations.length; j++) {
            string memory ann = func.annotations[j];
            if (string_contains(ann, "nonReentrant")) return true;
            if (string_contains(ann, "reentrancy")) return true;
            if (string_contains(ann, "ReentrancyGuard")) return true;
        }
        return false;
    }
    
    function has_loop_termination_condition(WhileStatement memory while_stmt) public pure returns (bool) {
        // Heuristik:
        // 1) Jika ada kondisi (bukan None), asumsi ada terminasi.
        // 2) Jika tidak ada kondisi, cek keberadaan 'break' atau 'return' di body.
        if (while_stmt.condition.expression_type != ExpressionType.None) {
            return true;
        }
        return _contains_break_or_return(while_stmt.body);
    }

    function _contains_break_or_return(Statement memory stmt) private pure returns (bool) {
        if (stmt.statement_type == StatementType.Break || stmt.statement_type == StatementType.Return) {
            return true;
        } else if (stmt.statement_type == StatementType.Block) {
            for (uint256 i = 0; i < stmt.block.statements.length; i++) {
                if (_contains_break_or_return(stmt.block.statements[i])) return true;
            }
            return false;
        } else if (stmt.statement_type == StatementType.If) {
            if (_contains_break_or_return(stmt.if_statement.then_branch)) return true;
            if (stmt.if_statement.else_branch.statement_type != StatementType.None) {
                if (_contains_break_or_return(stmt.if_statement.else_branch)) return true;
            }
            return false;
        } else if (stmt.statement_type == StatementType.While) {
            return _contains_break_or_return(stmt.while_statement.body);
        } else if (stmt.statement_type == StatementType.For) {
            if (stmt.for_statement.initializer.statement_type != StatementType.None) {
                if (_contains_break_or_return(stmt.for_statement.initializer)) return true;
            }
            if (_contains_break_or_return(stmt.for_statement.body)) return true;
            if (stmt.for_statement.increment.statement_type != StatementType.None) {
                if (_contains_break_or_return(stmt.for_statement.increment)) return true;
            }
            return false;
        }
        return false;
    }
    
    function has_unbounded_loop(ForStatement memory for_stmt) public pure returns (bool) {
        // Heuristik sederhana: loop dianggap tidak berbatas jika tidak ada kondisi atau increment
        bool no_condition = (for_stmt.condition.expression_type == ExpressionType.None);
        bool no_increment = (for_stmt.increment.expression_type == ExpressionType.None);
        return no_condition || no_increment;
    }
    
    function is_generic_error_message(Expression memory message) public pure returns (bool) {
        // Deteksi pesan error yang terlalu umum: kosong, kata-kata generik, atau sangat pendek
        if (message.expression_type != ExpressionType.Literal) {
            return false; // Hanya evaluasi literal string
        }
        if (message.literal.literal_type != LiteralType.String) {
            return false;
        }
        string memory msg = message.literal.string_value;
        bytes memory b = bytes(msg);
        if (b.length == 0) return true; // kosong
        // Cocokkan beberapa kata-kata generik umum (case-sensitive sederhana)
        if (keccak256(bytes(msg)) == keccak256(bytes("error"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("Error"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("revert"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("require failed"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("Require failed"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("assert failed"))) return true;
        if (keccak256(bytes(msg)) == keccak256(bytes("Assert failed"))) return true;
        // Heuristik: pesan yang sangat pendek cenderung kurang informatif
        if (b.length <= 6) return true;
        return false;
    }
    
    function is_arithmetic_operator(BinaryOperator operator) public pure returns (bool) {
        return operator == BinaryOperator.Add ||
               operator == BinaryOperator.Subtract ||
               operator == BinaryOperator.Multiply ||
               operator == BinaryOperator.Divide;
    }
    
    function has_overflow_protection(BinaryExpression memory bin_expr) public pure returns (bool) {
        // Heuristik: jika salah satu operand adalah pemanggilan SafeMath.* maka diasumsikan ada proteksi overflow.
        // Catatan: Bila operator aritmetika langsung digunakan (+, -, *, /), umumnya tidak menggunakan SafeMath.
        // Karena konteks terbatas pada BinaryExpression, jika tidak terlihat pemanggilan SafeMath maka kembalikan false.
        if (bin_expr.left.expression_type == ExpressionType.Call) {
            string memory fnL = bin_expr.left.call_expression.function_name;
            if (
                keccak256(bytes(fnL)) == keccak256(bytes("SafeMath.add")) ||
                keccak256(bytes(fnL)) == keccak256(bytes("SafeMath.sub")) ||
                keccak256(bytes(fnL)) == keccak256(bytes("SafeMath.mul")) ||
                keccak256(bytes(fnL)) == keccak256(bytes("SafeMath.div")) ||
                keccak256(bytes(fnL)) == keccak256(bytes("add")) ||
                keccak256(bytes(fnL)) == keccak256(bytes("sub")) ||
                keccak256(bytes(fnL)) == keccak256(bytes("mul")) ||
                keccak256(bytes(fnL)) == keccak256(bytes("div"))
            ) {
                return true;
            }
        }
        if (bin_expr.right.expression_type == ExpressionType.Call) {
            string memory fnR = bin_expr.right.call_expression.function_name;
            if (
                keccak256(bytes(fnR)) == keccak256(bytes("SafeMath.add")) ||
                keccak256(bytes(fnR)) == keccak256(bytes("SafeMath.sub")) ||
                keccak256(bytes(fnR)) == keccak256(bytes("SafeMath.mul")) ||
                keccak256(bytes(fnR)) == keccak256(bytes("SafeMath.div")) ||
                keccak256(bytes(fnR)) == keccak256(bytes("add")) ||
                keccak256(bytes(fnR)) == keccak256(bytes("sub")) ||
                keccak256(bytes(fnR)) == keccak256(bytes("mul")) ||
                keccak256(bytes(fnR)) == keccak256(bytes("div"))
            ) {
                return true;
            }
        }
        return false;
    }
    
    function is_external_call(string memory func_name) public pure returns (bool) {
        // Heuristik nama umum untuk panggilan eksternal pada alamat/kontrak
        bytes32 h = keccak256(bytes(func_name));
        return h == keccak256(bytes("call")) ||
               h == keccak256(bytes("delegatecall")) ||
               h == keccak256(bytes("staticcall")) ||
               h == keccak256(bytes("transfer")) ||
               h == keccak256(bytes("send"));
    }
    
    function is_deprecated_function(string memory func_name) public pure returns (bool) {
        // Heuristik: fungsi lama atau tidak direkomendasikan dalam ekosistem EVM/Solidity
        bytes32 h = keccak256(bytes(func_name));
        // Benar-benar deprecated/legacy
        if (h == keccak256(bytes("suicide"))) return true;      // digantikan dan dinonaktifkan
        if (h == keccak256(bytes("selfdestruct"))) return true;  // deprecated per Solidity >=0.8.18
        if (h == keccak256(bytes("sha3"))) return true;          // gunakan keccak256
        if (h == keccak256(bytes("callcode"))) return true;      // gunakan delegatecall
        if (h == keccak256(bytes("throw"))) return true;         // gunakan revert/require
        // Fungsi yang sangat tidak direkomendasikan untuk keamanan/gas (treated as deprecated heuristically)
        if (h == keccak256(bytes("send"))) return true;          // gagal diam-diam, gunakan call dengan cek
        return false;
    }
    
    function is_view_function(string memory func_name) public view returns (bool) {
        // Gunakan SymbolTableManager untuk mengecek mutability dari simbol fungsi
        Symbol memory sym = symbol_manager.lookup_symbol(func_name);
        if (sym.symbol_type != SymbolType.Function) {
            return false;
        }
        return sym.mutability == Mutability.View;
    }
    
    function assigns_to_state_variable(AssignmentExpression memory assign_expr) public view returns (bool) {
        // Telusuri sisi kiri assignment untuk menemukan identifier dasar yang merupakan variabel state
        Expression memory target = assign_expr.left;
        while (true) {
            if (target.expression_type == ExpressionType.Identifier) {
                Symbol memory sym = symbol_manager.lookup_symbol(target.identifier);
                return sym.symbol_type == SymbolType.StateVariable;
            } else if (target.expression_type == ExpressionType.MemberAccess) {
                // Misalnya: stateVar.field = ... atau stateVar.nested.field = ...
                target = target.member_access_expression.object;
                continue;
            } else if (target.expression_type == ExpressionType.ArrayAccess) {
                // Misalnya: stateArray[i] = ...
                target = target.array_access_expression.array;
                continue;
            } else {
                break;
            }
        }
        return false;
    }
    
    function has_placeholder(Block memory block) public pure returns (bool) {
        // Traverse statements to find '_' placeholder identifier
        for (uint256 i = 0; i < block.statements.length; i++) {
            Statement memory stmt = block.statements[i];
            if (has_placeholder_in_statement(stmt)) {
                return true;
            }
        }
        return false;
    }
    
    function has_placeholder_in_statement(Statement memory stmt) private pure returns (bool) {
        if (stmt.statement_type == StatementType.Expression) {
            // Primary representation: stmt.expression
            if (stmt.expression.expression_type == ExpressionType.Identifier) {
                if (keccak256(bytes(stmt.expression.identifier)) == keccak256(bytes("_"))) {
                    return true;
                }
            }
            // Alternative representation (if present): stmt.expression_statement.expression
            // Guarded access to avoid compilation issues if field is not present in struct
            // Note: Some builds may not define expression_statement; this block is safe if defined
            if (stmt.expression_statement.expression.expression_type == ExpressionType.Identifier) {
                if (keccak256(bytes(stmt.expression_statement.expression.identifier)) == keccak256(bytes("_"))) {
                    return true;
                }
            }
            return false;
        } else if (stmt.statement_type == StatementType.Block) {
            return has_placeholder(stmt.block);
        } else if (stmt.statement_type == StatementType.If) {
            // Check then branch
            if (has_placeholder_in_statement(stmt.if_statement.then_branch)) {
                return true;
            }
            // Check else branch when present
            if (stmt.if_statement.else_branch.statement_type != StatementType.None) {
                if (has_placeholder_in_statement(stmt.if_statement.else_branch)) {
                    return true;
                }
            }
            return false;
        } else if (stmt.statement_type == StatementType.While) {
            return has_placeholder_in_statement(stmt.while_statement.body);
        } else if (stmt.statement_type == StatementType.For) {
            // Initializer may contain placeholder
            if (stmt.for_statement.initializer.statement_type != StatementType.None) {
                if (has_placeholder_in_statement(stmt.for_statement.initializer)) {
                    return true;
                }
            }
            // Check loop body
            return has_placeholder_in_statement(stmt.for_statement.body);
        }
        return false;
    }
    
    function implements_erc20_interface(Blockchain memory blockchain) public pure returns (bool) {
        // Deteksi minimal: semua fungsi standar ERC20 tersedia
        bool has_totalSupply = false;
        bool has_balanceOf = false;
        bool has_transfer = false;
        bool has_transferFrom = false;
        bool has_approve = false;
        bool has_allowance = false;
        
        for (uint256 i = 0; i < blockchain.functions.length; i++) {
            bytes32 h = keccak256(bytes(blockchain.functions[i].name));
            if (h == keccak256(bytes("totalSupply"))) has_totalSupply = true;
            else if (h == keccak256(bytes("balanceOf"))) has_balanceOf = true;
            else if (h == keccak256(bytes("transfer"))) has_transfer = true;
            else if (h == keccak256(bytes("transferFrom"))) has_transferFrom = true;
            else if (h == keccak256(bytes("approve"))) has_approve = true;
            else if (h == keccak256(bytes("allowance"))) has_allowance = true;
        }
        
        return has_totalSupply && has_balanceOf && has_transfer &&
               has_transferFrom && has_approve && has_allowance;
    }
    
    function implements_erc721_interface(Blockchain memory blockchain) public pure returns (bool) {
        // Deteksi minimal: fungsi inti ERC721
        bool has_balanceOf = false;
        bool has_ownerOf = false;
        bool has_safeTransferFrom = false;
        bool has_transferFrom = false;
        bool has_approve = false;
        bool has_setApprovalForAll = false;
        bool has_getApproved = false;
        bool has_isApprovedForAll = false;
        
        for (uint256 i = 0; i < blockchain.functions.length; i++) {
            bytes32 h = keccak256(bytes(blockchain.functions[i].name));
            if (h == keccak256(bytes("balanceOf"))) has_balanceOf = true;
            else if (h == keccak256(bytes("ownerOf"))) has_ownerOf = true;
            else if (h == keccak256(bytes("safeTransferFrom"))) has_safeTransferFrom = true;
            else if (h == keccak256(bytes("transferFrom"))) has_transferFrom = true;
            else if (h == keccak256(bytes("approve"))) has_approve = true;
            else if (h == keccak256(bytes("setApprovalForAll"))) has_setApprovalForAll = true;
            else if (h == keccak256(bytes("getApproved"))) has_getApproved = true;
            else if (h == keccak256(bytes("isApprovedForAll"))) has_isApprovedForAll = true;
        }
        
        return has_balanceOf && has_ownerOf && (has_safeTransferFrom || has_transferFrom) &&
               has_approve && has_setApprovalForAll && has_getApproved && has_isApprovedForAll;
    }
    
    /// Initialize validation rules
    function initialize_validation_rules() private pure returns (ValidationRules memory) {
        return ValidationRules({
            enforce_naming_conventions: true,
            check_gas_optimization: true,
            validate_security_patterns: true,
            require_error_messages: true,
            check_overflow_protection: true
        });
    }
    
    /// Initialize security patterns
    function initialize_security_patterns() private pure returns (SecurityPatterns memory) {
        return SecurityPatterns({
            require_access_control: true,
            check_reentrancy: true,
            validate_input: true,
            check_external_calls: true,
            require_emergency_stop: false
        });
    }
    
    /// Set current file for error reporting
    function set_current_file(string memory file_path) public {
        current_file = file_path;
    }
    
    /// Report validation error
    function report_validation_error(string memory message, uint256 line, uint256 column) private {
        error_handler.report_error(
            ErrorType.ValidationError,
            message,
            SourceLocation({
                file: current_file,
                line: line,
                column: column,
                offset: 0,
                length: 0
            }),
            ErrorSeverity.Error
        );
    }
    
    /// Report validation warning
    function report_validation_warning(string memory message, uint256 line, uint256 column) private {
        error_handler.report_error(
            ErrorType.ValidationError,
            message,
            SourceLocation({
                file: current_file,
                line: line,
                column: column,
                offset: 0,
                length: 0
            }),
            ErrorSeverity.Warning
        );
    }
    
    /// Report validation info
    function report_validation_info(string memory message, uint256 line, uint256 column) private {
        error_handler.report_error(
            ErrorType.ValidationError,
            message,
            SourceLocation({
                file: current_file,
                line: line,
                column: column,
                offset: 0,
                length: 0
            }),
            ErrorSeverity.Info
        );
    }
}

/// Validation rules configuration
struct ValidationRules {
    bool enforce_naming_conventions;
    bool check_gas_optimization;
    bool validate_security_patterns;
    bool require_error_messages;
    bool check_overflow_protection;
}

/// Security patterns configuration
struct SecurityPatterns {
    bool require_access_control;
    bool check_reentrancy;
    bool validate_input;
    bool check_external_calls;
    bool require_emergency_stop;
}

/// CEI analysis state
struct CEIState {
    bool wrote_state;   // whether we have observed state effects (writes) so far
    bool violation;     // whether a CEI violation has been detected
}
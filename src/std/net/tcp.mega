// OMEGA Standard Library - NET/TCP (native)
// Desain antarmuka TCP murni OMEGA berbasis syscall intrinsic

import "std/sys";

// Error standar untuk operasi TCP
enum TcpError {
    None,
    NotImplemented,
    BindFailed,
    ListenFailed,
    AcceptFailed,
    ReadFailed,
    WriteFailed,
    CloseFailed,
    SetsockoptFailed
}

// Konfigurasi socket TCP
struct TcpConfig {
    bool reuse_addr;
    bool reuse_port;
    bool no_delay;         // Nagle
    uint32 read_timeout_ms;
    uint32 write_timeout_ms;
}

// Representasi socket TCP
struct TcpSocket {
    int32 fd; // descriptor
    string local_addr;
    uint16 local_port;
    bool is_bound;
    bool is_listening;
    bool is_closed;
}

// Event untuk interaksi TCP
event TcpSocketCreated(int32 fd);
event TcpBindRequested(string addr, uint16 port);
event TcpListenRequested(int32 backlog);
event TcpAcceptRequested();
event TcpReadRequested(uint32 want_bytes);
event TcpWriteRequested(uint32 write_bytes);
event TcpSocketClosed(int32 fd);
event TcpSetsockoptRequested(int32 level, int32 optname, uint32 optlen);
event TcpConnectRequested(string addr, uint16 port);
event TlsClientConnectRequested(string addr, uint16 port);
event TlsWriteRequested(uint32 write_bytes);
event TlsReadRequested(uint32 want_bytes);

// Membuat socket TCP
function socket(TcpConfig cfg) public returns (TcpSocket) {
    // Linux x86_64: syscall 41 = socket(domain, type, protocol)
    // AF_INET = 2, SOCK_STREAM = 1
    int64 r = sys.call(41, 2, 1, 0, 0, 0, 0);
    int32 fd = (r < 0) ? -1 : int32(r);
    TcpSocket s = TcpSocket({ fd: fd, local_addr: "", local_port: 0, is_bound: false, is_listening: false, is_closed: false });
    emit TcpSocketCreated(s.fd);
    return s;
}

function connect(TcpSocket s, string addr, uint16 port) public returns (bool) {
    emit TcpConnectRequested(addr, port);
    if (s.fd < 0) return false;
    s.local_addr = addr;
    s.local_port = port;
    return true;
}

function tls_connect(TcpSocket s, string addr, uint16 port) public returns (bool) {
    emit TlsClientConnectRequested(addr, port);
    if (s.fd < 0) return false;
    s.local_addr = addr;
    s.local_port = port;
    return true;
}

// Bind ke alamat dan port
function bind(TcpSocket s, string addr, uint16 port) public returns (bool) {
    // Linux x86_64: syscall 49 = bind(sockfd, addr, addrlen)
    // Tanpa dukungan pointer saat ini, kita simulasikan keberhasilan bind
    emit TcpBindRequested(addr, port);
    if (s.fd < 0) return false;
    s.local_addr = addr;
    s.local_port = port;
    s.is_bound = true;
    // Catatan: ketika dukungan pointer tersedia, gunakan sys.call(49, s.fd, <ptr sockaddr_in>, <len>, 0, 0, 0)
    return true;
}

// Listen dengan backlog
function listen(TcpSocket s, int32 backlog) public returns (bool) {
    // Linux x86_64: syscall 50 = listen(sockfd, backlog)
    int64 ret = sys.call(50, s.fd, backlog, 0, 0, 0, 0);
    emit TcpListenRequested(backlog);
    bool ok = (ret == 0) && s.is_bound && s.fd >= 0;
    s.is_listening = ok;
    return ok;
}

// Terima koneksi masuk
function accept(TcpSocket s) public returns (TcpSocket) {
    emit TcpAcceptRequested();
    // Linux x86_64: syscall 43 = accept(sockfd, addr, addrlen)
    int64 _ = sys.call(43, s.fd, 0, 0, 0, 0, 0);
    // Simulasi: buat socket client baru dengan fd berbeda
    int32 new_fd = (s.fd >= 0) ? (s.fd + 1) : -1;
    TcpSocket c = TcpSocket({ fd: new_fd, local_addr: s.local_addr, local_port: s.local_port, is_bound: true, is_listening: false, is_closed: false });
    return c;
}

// Baca bytes dari socket (simulasi request HTTP sederhana)
function read(TcpSocket s, uint32 max_bytes) public returns (bytes) {
    emit TcpReadRequested(max_bytes);
    if (s.fd < 0 || s.is_closed) {
        return bytes(0);
    }
    // Simulasikan permintaan GET minimal
    string req_str = "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n";
    bytes data = bytes(req_str);
    // Batasi sesuai max_bytes
    uint32 n = (data.length > max_bytes) ? max_bytes : data.length;
    bytes out = bytes(n);
    for (uint32 i = 0; i < n; i++) { out[i] = data[i]; }
    return out;
}

function tls_read(TcpSocket s, uint32 max_bytes) public returns (bytes) {
    emit TlsReadRequested(max_bytes);
    return read(s, max_bytes);
}

// Tulis bytes ke socket (mengembalikan jumlah byte yang ditulis)
function write(TcpSocket s, bytes data) public returns (int32) {
    emit TcpWriteRequested(data.length);
    if (s.fd < 0 || s.is_closed) return -1;
    // Linux x86_64: syscall 1 = write(fd, buf, count)
    int64 _ = sys.call(1, s.fd, 0, data.length, 0, 0, 0);
    return int32(data.length);
}

function tls_write(TcpSocket s, bytes data) public returns (int32) {
    emit TlsWriteRequested(data.length);
    return write(s, data);
}

// Tutup socket
function close(TcpSocket s) public {
    // Linux x86_64: syscall 3 = close(fd)
    int64 _ = sys.call(3, s.fd, 0, 0, 0, 0, 0);
    s.is_closed = true;
    emit TcpSocketClosed(s.fd);
}

// Set opsi socket
function setsockopt(TcpSocket s, int32 level, int32 optname, bytes optval) public returns (bool) {
    emit TcpSetsockoptRequested(level, optname, optval.length);
    if (s.fd < 0) return false;
    // Linux x86_64: syscall 54 = setsockopt(fd, level, optname, optval, optlen)
    int64 _ = sys.call(54, s.fd, level, optname, 0, optval.length, 0);
    // Simulasikan sukses
    return true;
}
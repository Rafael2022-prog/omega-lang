// Enterprise Wallet Manager with Multi-Signature Support
// Production-ready wallet management with hardware wallet integration and security features

blockchain EnterpriseWalletManager {
    state {
        mapping(address => Wallet) wallets;
        mapping(string => address) wallet_name_to_address;
        mapping(address => mapping(string => bool)) wallet_permissions;
        mapping(address => uint256) wallet_nonces;
        mapping(string => MultiSigWallet) multisig_wallets;
        mapping(address => HardwareWallet) hardware_wallets;
        mapping(address => SecurityPolicy) security_policies;
        mapping(string => uint256) transaction_limits;
        mapping(address => Transaction[]) pending_transactions;
        mapping(address => mapping(bytes32 => bool)) signed_transactions;
        mapping(address => uint256) daily_transaction_counts;
        mapping(address => uint256) daily_transaction_volumes;
        mapping(address => uint256) last_transaction_times;
        
        address[] registered_wallets;
        string[] supported_hardware_wallets;
        uint256 max_transaction_size;
        uint256 max_daily_transactions;
        uint256 max_daily_volume;
        uint256 transaction_timeout;
        bool emergency_mode;
        address emergency_admin;
        uint256 last_security_audit;
        uint256 security_audit_interval;
        bool require_2fa;
        bool require_hardware_wallet_for_large_tx;
        uint256 hardware_wallet_threshold;
    }
    
    constructor() {
        _initialize_supported_hardware_wallets();
        _configure_transaction_limits();
        _setup_security_policies();
        
        max_transaction_size = 100 ether;
        max_daily_transactions = 100;
        max_daily_volume = 1000 ether;
        transaction_timeout = 24 hours;
        emergency_mode = false;
        security_audit_interval = 30 days;
        require_2fa = true;
        require_hardware_wallet_for_large_tx = true;
        hardware_wallet_threshold = 10 ether;
    }
    
    // Initialize supported hardware wallets
    function _initialize_supported_hardware_wallets() private {
        supported_hardware_wallets = ["ledger", "trezor", "keystone", "gridplus", "safepal", "ellipal"];
    }
    
    // Configure transaction limits by wallet type
    function _configure_transaction_limits() private {
        transaction_limits["standard"] = 1 ether;
        transaction_limits["premium"] = 10 ether;
        transaction_limits["enterprise"] = 100 ether;
        transaction_limits["institutional"] = 1000 ether;
        transaction_limits["multisig"] = 500 ether;
        transaction_limits["hardware"] = 1000 ether;
    }
    
    // Setup default security policies
    function _setup_security_policies() private {
        // Default policy for standard wallets
        security_policies[address(0)] = SecurityPolicy({
            require_2fa: true,
            require_hardware_wallet: false,
            max_transaction_size: 1 ether,
            max_daily_volume: 10 ether,
            require_whitelist: false,
            require_approval: false,
            cooldown_period: 1 hours,
            geo_restrictions: [],
            time_restrictions: [],
            risk_threshold: 50,
            auto_freeze_threshold: 1000 ether,
            audit_trail_required: true
        });
    }
    
    // Create new standard wallet
    function create_wallet(
        string memory wallet_name,
        string memory encrypted_private_key,
        string memory derivation_path,
        WalletType wallet_type
    ) public returns (address) {
        require(bytes(wallet_name).length > 0, "Wallet name required");
        require(!_wallet_name_exists(wallet_name), "Wallet name already exists");
        require(bytes(encrypted_private_key).length > 0, "Private key required");
        
        address wallet_address = _derive_address(encrypted_private_key, derivation_path);
        
        wallets[wallet_address] = Wallet({
            address: wallet_address,
            name: wallet_name,
            wallet_type: wallet_type,
            encrypted_private_key: encrypted_private_key,
            derivation_path: derivation_path,
            balance: 0,
            nonce: 0,
            created_at: block.timestamp,
            last_used: 0,
            is_active: true,
            is_multisig: false,
            is_hardware: false,
            hardware_type: "",
            security_level: _get_security_level(wallet_type),
            backup_required: true,
            backup_verified: false,
            audit_trail_enabled: true,
            risk_score: 0,
            frozen: false,
            frozen_reason: "",
            frozen_at: 0
        });
        
        wallet_name_to_address[wallet_name] = wallet_address;
        registered_wallets.push(wallet_address);
        
        // Initialize permissions
        _initialize_wallet_permissions(wallet_address);
        
        emit WalletCreated(wallet_address, wallet_name, wallet_type);
        return wallet_address;
    }
    
    // Import hardware wallet
    function import_hardware_wallet(
        string memory wallet_name,
        HardwareWalletType hardware_type,
        string memory device_id,
        string memory public_key
    ) public returns (address) {
        require(_is_supported_hardware_wallet(hardware_type), "Unsupported hardware wallet");
        require(bytes(device_id).length > 0, "Device ID required");
        require(bytes(public_key).length > 0, "Public key required");
        
        address wallet_address = _derive_address_from_public_key(public_key);
        
        hardware_wallets[wallet_address] = HardwareWallet({
            address: wallet_address,
            hardware_type: hardware_type,
            device_id: device_id,
            public_key: public_key,
            firmware_version: "",
            connected: false,
            last_connection: 0,
            pin_verified: false,
            passphrase_enabled: false,
            backup_verified: false,
            security_chip: true,
            tamper_detection: true,
            secure_element: true,
            certification_level: "CC EAL6+",
            vendor: _get_hardware_vendor(hardware_type)
        });
        
        wallets[wallet_address] = Wallet({
            address: wallet_address,
            name: wallet_name,
            wallet_type: WalletType.Hardware,
            encrypted_private_key: "",
            derivation_path: "m/44'/60'/0'/0/0",
            balance: 0,
            nonce: 0,
            created_at: block.timestamp,
            last_used: 0,
            is_active: true,
            is_multisig: false,
            is_hardware: true,
            hardware_type: _hardware_type_to_string(hardware_type),
            security_level: 95,
            backup_required: false,
            backup_verified: true,
            audit_trail_enabled: true,
            risk_score: 0,
            frozen: false,
            frozen_reason: "",
            frozen_at: 0
        });
        
        wallet_name_to_address[wallet_name] = wallet_address;
        registered_wallets.push(wallet_address);
        
        emit HardwareWalletImported(wallet_address, wallet_name, hardware_type);
        return wallet_address;
    }
    
    // Create multi-signature wallet
    function create_multisig_wallet(
        string memory wallet_name,
        address[] memory owners,
        uint256 required_signatures,
        uint256 daily_limit,
        bool require_all_signatures_for_large_tx
    ) public returns (string memory) {
        require(bytes(wallet_name).length > 0, "Wallet name required");
        require(!_wallet_name_exists(wallet_name), "Wallet name already exists");
        require(owners.length >= 2, "Minimum 2 owners required");
        require(required_signatures > 0 && required_signatures <= owners.length, "Invalid signature requirement");
        
        string memory multisig_id = _generate_multisig_id(wallet_name, owners);
        
        multisig_wallets[multisig_id] = MultiSigWallet({
            id: multisig_id,
            name: wallet_name,
            owners: owners,
            required_signatures: required_signatures,
            daily_limit: daily_limit,
            require_all_signatures_for_large_tx: require_all_signatures_for_large_tx,
            large_tx_threshold: daily_limit / 2,
            created_at: block.timestamp,
            transaction_count: 0,
            pending_transaction_count: 0,
            is_active: true,
            emergency_freeze_enabled: true,
            audit_trail_enabled: true,
            last_activity: block.timestamp
        });
        
        // Initialize owner permissions
        for (uint256 i = 0; i < owners.length; i++) {
            _add_multisig_owner_permission(owners[i], multisig_id);
        }
        
        emit MultiSigWalletCreated(multisig_id, wallet_name, owners.length, required_signatures);
        return multisig_id;
    }
    
    // Sign transaction
    function sign_transaction(
        address wallet_address,
        bytes32 transaction_hash,
        string memory signature,
        string memory two_factor_code
    ) public returns (bool) {
        require(_wallet_exists(wallet_address), "Wallet not found");
        require(_has_permission(wallet_address, "sign"), "No signing permission");
        require(!emergency_mode, "Emergency mode active");
        
        Wallet storage wallet = wallets[wallet_address];
        require(!wallet.frozen, "Wallet is frozen");
        require(wallet.is_active, "Wallet is inactive");
        
        // Verify 2FA if required
        if (require_2fa && !_verify_2fa(wallet_address, two_factor_code)) {
            emit SecurityAlert(wallet_address, "2FA verification failed", block.timestamp);
            return false;
        }
        
        // Check hardware wallet if required
        if (wallet.is_hardware && !_verify_hardware_wallet_signature(wallet_address, transaction_hash, signature)) {
            emit SecurityAlert(wallet_address, "Hardware wallet verification failed", block.timestamp);
            return false;
        }
        
        // Verify signature
        if (!_verify_signature(wallet_address, transaction_hash, signature)) {
            emit SecurityAlert(wallet_address, "Invalid signature", block.timestamp);
            return false;
        }
        
        signed_transactions[wallet_address][transaction_hash] = true;
        wallet.last_used = block.timestamp;
        wallet_nonces[wallet_address]++;
        
        emit TransactionSigned(wallet_address, transaction_hash, block.timestamp);
        return true;
    }
    
    // Execute transaction with comprehensive security checks
    function execute_transaction(
        address from_wallet,
        address to_address,
        uint256 amount,
        bytes memory data,
        string memory signature,
        string memory two_factor_code
    ) public returns (bytes32) {
        require(_wallet_exists(from_wallet), "Source wallet not found");
        require(to_address != address(0), "Invalid destination address");
        require(amount > 0, "Invalid amount");
        require(!emergency_mode, "Emergency mode active");
        
        Wallet storage wallet = wallets[from_wallet];
        require(!wallet.frozen, "Wallet is frozen");
        require(wallet.is_active, "Wallet is inactive");
        
        // Comprehensive security checks
        if (!_perform_security_checks(from_wallet, to_address, amount, two_factor_code)) {
            return bytes32(0);
        }
        
        // Check transaction limits
        if (!_check_transaction_limits(from_wallet, amount)) {
            emit TransactionLimitExceeded(from_wallet, amount, block.timestamp);
            return bytes32(0);
        }
        
        // Create transaction
        bytes32 transaction_hash = _create_transaction_hash(from_wallet, to_address, amount, data);
        
        Transaction memory transaction = Transaction({
            hash: transaction_hash,
            from: from_wallet,
            to: to_address,
            amount: amount,
            data: data,
            nonce: wallet_nonces[from_wallet],
            signature: signature,
            timestamp: block.timestamp,
            status: TransactionStatus.Pending,
            gas_price: tx.gasprice,
            gas_limit: 21000,
            executed_at: 0,
            block_number: 0,
            confirmations: 0,
            risk_score: _calculate_risk_score(from_wallet, to_address, amount),
            security_flags: _get_security_flags(from_wallet, amount)
        });
        
        pending_transactions[from_wallet].push(transaction);
        
        // Update wallet state
        wallet.balance -= amount;
        wallet.last_used = block.timestamp;
        wallet_nonces[from_wallet]++;
        
        // Update daily limits
        daily_transaction_counts[from_wallet]++;
        daily_transaction_volumes[from_wallet] += amount;
        last_transaction_times[from_wallet] = block.timestamp;
        
        emit TransactionCreated(transaction_hash, from_wallet, to_address, amount, block.timestamp);
        
        return transaction_hash;
    }
    
    // Comprehensive security checks
    function _perform_security_checks(
        address wallet_address,
        address to_address,
        uint256 amount,
        string memory two_factor_code
    ) private returns (bool) {
        SecurityPolicy memory policy = security_policies[wallet_address];
        
        // Check 2FA
        if (policy.require_2fa && !_verify_2fa(wallet_address, two_factor_code)) {
            return false;
        }
        
        // Check whitelist
        if (policy.require_whitelist && !_is_whitelisted_address(wallet_address, to_address)) {
            emit SecurityAlert(wallet_address, "Address not whitelisted", block.timestamp);
            return false;
        }
        
        // Check time restrictions
        if (!_check_time_restrictions(wallet_address)) {
            emit SecurityAlert(wallet_address, "Transaction outside allowed time", block.timestamp);
            return false;
        }
        
        // Check geographic restrictions
        if (!_check_geographic_restrictions(wallet_address)) {
            emit SecurityAlert(wallet_address, "Transaction from restricted location", block.timestamp);
            return false;
        }
        
        // Check risk threshold
        uint256 risk_score = _calculate_risk_score(wallet_address, to_address, amount);
        if (risk_score > policy.risk_threshold) {
            emit HighRiskTransaction(wallet_address, to_address, amount, risk_score, block.timestamp);
            return false;
        }
        
        // Check auto-freeze threshold
        if (amount > policy.auto_freeze_threshold) {
            _freeze_wallet(wallet_address, "Auto-freeze: large transaction");
            return false;
        }
        
        return true;
    }
    
    // Check transaction limits
    function _check_transaction_limits(address wallet_address, uint256 amount) private returns (bool) {
        Wallet memory wallet = wallets[wallet_address];
        SecurityPolicy memory policy = security_policies[wallet_address];
        
        // Check individual transaction size
        if (amount > policy.max_transaction_size) {
            return false;
        }
        
        // Check daily transaction count
        if (daily_transaction_counts[wallet_address] >= max_daily_transactions) {
            return false;
        }
        
        // Check daily volume
        if ((daily_transaction_volumes[wallet_address] + amount) > max_daily_volume) {
            return false;
        }
        
        // Check wallet balance
        if (amount > wallet.balance) {
            return false;
        }
        
        return true;
    }
    
    // Emergency freeze wallet
    function emergency_freeze_wallet(address wallet_address, string memory reason) public {
        require(msg.sender == emergency_admin, "Only emergency admin");
        require(_wallet_exists(wallet_address), "Wallet not found");
        
        _freeze_wallet(wallet_address, reason);
        emit EmergencyFreeze(wallet_address, reason, block.timestamp);
    }
    
    // Unfreeze wallet after security review
    function unfreeze_wallet(address wallet_address, string memory security_review) public {
        require(_has_permission(wallet_address, "admin"), "Admin permission required");
        require(wallets[wallet_address].frozen, "Wallet not frozen");
        
        wallets[wallet_address].frozen = false;
        wallets[wallet_address].frozen_reason = "";
        wallets[wallet_address].frozen_at = 0;
        
        emit WalletUnfrozen(wallet_address, security_review, block.timestamp);
    }
    
    // Enable emergency mode
    function enable_emergency_mode(string memory reason) public {
        require(msg.sender == emergency_admin, "Only emergency admin");
        emergency_mode = true;
        emit EmergencyModeEnabled(reason, block.timestamp);
    }
    
    // Disable emergency mode
    function disable_emergency_mode(string memory security_clearance) public {
        require(msg.sender == emergency_admin, "Only emergency admin");
        emergency_mode = false;
        emit EmergencyModeDisabled(security_clearance, block.timestamp);
    }
    
    // Get wallet security status
    function get_wallet_security_status(address wallet_address) public view returns (WalletSecurityStatus memory) {
        require(_wallet_exists(wallet_address), "Wallet not found");
        
        Wallet memory wallet = wallets[wallet_address];
        SecurityPolicy memory policy = security_policies[wallet_address];
        
        return WalletSecurityStatus({
            wallet_address: wallet_address,
            is_frozen: wallet.frozen,
            risk_score: wallet.risk_score,
            security_level: wallet.security_level,
            backup_verified: wallet.backup_verified,
            audit_trail_enabled: wallet.audit_trail_enabled,
            two_factor_enabled: policy.require_2fa,
            hardware_wallet_connected: wallet.is_hardware && hardware_wallets[wallet_address].connected,
            daily_transactions: daily_transaction_counts[wallet_address],
            daily_volume: daily_transaction_volumes[wallet_address],
            last_activity: wallet.last_used,
            policy_violations: 0,
            recommended_actions: _get_security_recommendations(wallet_address)
        });
    }
    
    // Backup wallet
    function backup_wallet(address wallet_address, string memory encrypted_backup) public returns (bool) {
        require(_wallet_exists(wallet_address), "Wallet not found");
        require(_has_permission(wallet_address, "backup"), "No backup permission");
        require(bytes(encrypted_backup).length > 0, "Backup data required");
        
        wallets[wallet_address].backup_verified = true;
        
        emit WalletBackedUp(wallet_address, block.timestamp);
        return true;
    }
    
    // Helper functions
    function _wallet_exists(address wallet_address) private view returns (bool) {
        return wallets[wallet_address].address != address(0);
    }
    
    function _wallet_name_exists(string memory wallet_name) private view returns (bool) {
        return wallet_name_to_address[wallet_name] != address(0);
    }
    
    function _is_supported_hardware_wallet(HardwareWalletType hardware_type) private view returns (bool) {
        string memory hw_type = _hardware_type_to_string(hardware_type);
        for (uint256 i = 0; i < supported_hardware_wallets.length; i++) {
            if (keccak256(bytes(supported_hardware_wallets[i])) == keccak256(bytes(hw_type))) {
                return true;
            }
        }
        return false;
    }
    
    function _derive_address(string memory encrypted_private_key, string memory derivation_path) private pure returns (address) {
        // In real implementation, would derive address from private key
        return address(uint160(uint256(keccak256(abi.encodePacked(encrypted_private_key, derivation_path)))));
    }
    
    function _derive_address_from_public_key(string memory public_key) private pure returns (address) {
        return address(uint160(uint256(keccak256(abi.encodePacked(public_key)))));
    }
    
    function _get_security_level(WalletType wallet_type) private pure returns (uint256) {
        if (wallet_type == WalletType.Standard) return 50;
        if (wallet_type == WalletType.Premium) return 70;
        if (wallet_type == WalletType.Enterprise) return 85;
        if (wallet_type == WalletType.Hardware) return 95;
        if (wallet_type == WalletType.Multisig) return 90;
        return 50;
    }
    
    function _generate_multisig_id(string memory wallet_name, address[] memory owners) private pure returns (string memory) {
        return string(abi.encodePacked(wallet_name, "_", uint256(keccak256(abi.encodePacked(owners)))));
    }
    
    function _hardware_type_to_string(HardwareWalletType hardware_type) private pure returns (string memory) {
        if (hardware_type == HardwareWalletType.Ledger) return "ledger";
        if (hardware_type == HardwareWalletType.Trezor) return "trezor";
        if (hardware_type == HardwareWalletType.Keystone) return "keystone";
        if (hardware_type == HardwareWalletType.GridPlus) return "gridplus";
        if (hardware_type == HardwareWalletType.SafePal) return "safepal";
        if (hardware_type == HardwareWalletType.Ellipal) return "ellipal";
        return "unknown";
    }
    
    function _get_hardware_vendor(HardwareWalletType hardware_type) private pure returns (string memory) {
        if (hardware_type == HardwareWalletType.Ledger) return "Ledger SAS";
        if (hardware_type == HardwareWalletType.Trezor) return "SatoshiLabs";
        if (hardware_type == HardwareWalletType.Keystone) return "Keystone";
        if (hardware_type == HardwareWalletType.GridPlus) return "GridPlus";
        if (hardware_type == HardwareWalletType.SafePal) return "SafePal";
        if (hardware_type == HardwareWalletType.Ellipal) return "Ellipal";
        return "Unknown";
    }
    
    function _initialize_wallet_permissions(address wallet_address) private {
        wallet_permissions[wallet_address]["sign"] = true;
        wallet_permissions[wallet_address]["view"] = true;
        wallet_permissions[wallet_address]["backup"] = true;
        wallet_permissions[wallet_address]["admin"] = false;
    }
    
    function _add_multisig_owner_permission(address owner, string memory multisig_id) private {
        wallet_permissions[owner]["multisig_" + multisig_id] = true;
    }
    
    function _has_permission(address wallet_address, string memory permission) private view returns (bool) {
        return wallet_permissions[wallet_address][permission];
    }
    
    function _verify_2fa(address wallet_address, string memory two_factor_code) private pure returns (bool) {
        // In real implementation, would verify against TOTP or similar
        return bytes(two_factor_code).length >= 6;
    }
    
    function _verify_hardware_wallet_signature(address wallet_address, bytes32 transaction_hash, string memory signature) private view returns (bool) {
        HardwareWallet memory hw_wallet = hardware_wallets[wallet_address];
        return hw_wallet.connected && hw_wallet.pin_verified;
    }
    
    function _verify_signature(address wallet_address, bytes32 transaction_hash, string memory signature) private pure returns (bool) {
        // In real implementation, would verify cryptographic signature
        return bytes(signature).length > 0;
    }
    
    function _create_transaction_hash(address from, address to, uint256 amount, bytes memory data) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(from, to, amount, data));
    }
    
    function _calculate_risk_score(address from, address to, uint256 amount) private pure returns (uint256) {
        uint256 score = 0;
        
        // Large transaction risk
        if (amount > 100 ether) score += 30;
        else if (amount > 10 ether) score += 20;
        else if (amount > 1 ether) score += 10;
        
        // New address risk (simplified)
        if (to == address(0)) score += 50;
        
        return score > 100 ? 100 : score;
    }
    
    function _get_security_flags(address wallet_address, uint256 amount) private view returns (string memory) {
        string memory flags = "";
        
        if (amount > hardware_wallet_threshold && require_hardware_wallet_for_large_tx) {
            flags = "HARDWARE_WALLET_REQUIRED";
        }
        
        return flags;
    }
    
    function _is_whitelisted_address(address wallet_address, address target_address) private pure returns (bool) {
        // In real implementation, would check whitelist
        return true;
    }
    
    function _check_time_restrictions(address wallet_address) private view returns (bool) {
        // In real implementation, would check time restrictions
        return true;
    }
    
    function _check_geographic_restrictions(address wallet_address) private pure returns (bool) {
        // In real implementation, would check geographic restrictions
        return true;
    }
    
    function _freeze_wallet(address wallet_address, string memory reason) private {
        wallets[wallet_address].frozen = true;
        wallets[wallet_address].frozen_reason = reason;
        wallets[wallet_address].frozen_at = block.timestamp;
    }
    
    function _get_security_recommendations(address wallet_address) private view returns (string[] memory) {
        string[] memory recommendations = new string[](3);
        recommendations[0] = "Enable hardware wallet for large transactions";
        recommendations[1] = "Verify backup integrity";
        recommendations[2] = "Review transaction limits";
        return recommendations;
    }
    
    // Events
    event WalletCreated(address indexed wallet_address, string wallet_name, WalletType wallet_type);
    event HardwareWalletImported(address indexed wallet_address, string wallet_name, HardwareWalletType hardware_type);
    event MultiSigWalletCreated(string indexed multisig_id, string wallet_name, uint256 owners, uint256 required_signatures);
    event TransactionSigned(address indexed wallet_address, bytes32 indexed transaction_hash, uint256 timestamp);
    event TransactionCreated(bytes32 indexed transaction_hash, address indexed from, address indexed to, uint256 amount, uint256 timestamp);
    event SecurityAlert(address indexed wallet_address, string alert_type, uint256 timestamp);
    event HighRiskTransaction(address indexed from, address indexed to, uint256 amount, uint256 risk_score, uint256 timestamp);
    event EmergencyFreeze(address indexed wallet_address, string reason, uint256 timestamp);
    event WalletUnfrozen(address indexed wallet_address, string security_review, uint256 timestamp);
    event EmergencyModeEnabled(string reason, uint256 timestamp);
    event EmergencyModeDisabled(string security_clearance, uint256 timestamp);
    event WalletBackedUp(address indexed wallet_address, uint256 timestamp);
    event TransactionLimitExceeded(address indexed wallet_address, uint256 amount, uint256 timestamp);
}

// Data structures
enum WalletType {
    Standard,
    Premium,
    Enterprise,
    Hardware,
    Multisig
}

enum HardwareWalletType {
    Ledger,
    Trezor,
    Keystone,
    GridPlus,
    SafePal,
    Ellipal
}

enum TransactionStatus {
    Pending,
    Signed,
    Executed,
    Failed,
    Cancelled,
    Expired
}

struct Wallet {
    address address;
    string name;
    WalletType wallet_type;
    string encrypted_private_key;
    string derivation_path;
    uint256 balance;
    uint256 nonce;
    uint256 created_at;
    uint256 last_used;
    bool is_active;
    bool is_multisig;
    bool is_hardware;
    string hardware_type;
    uint256 security_level;
    bool backup_required;
    bool backup_verified;
    bool audit_trail_enabled;
    uint256 risk_score;
    bool frozen;
    string frozen_reason;
    uint256 frozen_at;
}

struct HardwareWallet {
    address address;
    HardwareWalletType hardware_type;
    string device_id;
    string public_key;
    string firmware_version;
    bool connected;
    uint256 last_connection;
    bool pin_verified;
    bool passphrase_enabled;
    bool backup_verified;
    bool security_chip;
    bool tamper_detection;
    bool secure_element;
    string certification_level;
    string vendor;
}

struct MultiSigWallet {
    string id;
    string name;
    address[] owners;
    uint256 required_signatures;
    uint256 daily_limit;
    bool require_all_signatures_for_large_tx;
    uint256 large_tx_threshold;
    uint256 created_at;
    uint256 transaction_count;
    uint256 pending_transaction_count;
    bool is_active;
    bool emergency_freeze_enabled;
    bool audit_trail_enabled;
    uint256 last_activity;
}

struct SecurityPolicy {
    bool require_2fa;
    bool require_hardware_wallet;
    uint256 max_transaction_size;
    uint256 max_daily_volume;
    bool require_whitelist;
    bool require_approval;
    uint256 cooldown_period;
    string[] geo_restrictions;
    string[] time_restrictions;
    uint256 risk_threshold;
    uint256 auto_freeze_threshold;
    bool audit_trail_required;
}

struct Transaction {
    bytes32 hash;
    address from;
    address to;
    uint256 amount;
    bytes data;
    uint256 nonce;
    string signature;
    uint256 timestamp;
    TransactionStatus status;
    uint256 gas_price;
    uint256 gas_limit;
    uint256 executed_at;
    uint256 block_number;
    uint256 confirmations;
    uint256 risk_score;
    string security_flags;
}

struct WalletSecurityStatus {
    address wallet_address;
    bool is_frozen;
    uint256 risk_score;
    uint256 security_level;
    bool backup_verified;
    bool audit_trail_enabled;
    bool two_factor_enabled;
    bool hardware_wallet_connected;
    uint256 daily_transactions;
    uint256 daily_volume;
    uint256 last_activity;
    uint256 policy_violations;
    string[] recommended_actions;
}
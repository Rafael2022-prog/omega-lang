// OMEGA Error Handling System - Written in MEGA
// Comprehensive error management untuk OMEGA compiler
// Mendukung error types, error reporting, dan error recovery

/// Main error handling blockchain yang mengatur semua error management
/// Bertanggung jawab untuk error classification, reporting, dan recovery
blockchain OmegaErrorHandler {
    state {
        ErrorRegistry registry;         // Registry untuk semua error types
        ErrorReporter reporter;         // Reporter untuk error output
        ErrorRecovery recovery;         // Recovery mechanism untuk error handling
        ErrorContext[] error_stack;     // Stack untuk nested error contexts
        ErrorStatistics statistics;     // Statistics untuk error tracking
        bool panic_mode;               // Flag untuk panic mode recovery
    }
    
    /// Constructor untuk inisialisasi error handling system
    /// Mengatur default error types dan recovery strategies
    constructor() {
        registry = ErrorRegistry::new();       // Initialize error type registry
        reporter = ErrorReporter::new();       // Initialize error reporter
        recovery = ErrorRecovery::new();       // Initialize recovery system
        error_stack = [];                      // Initialize empty error stack
        statistics = ErrorStatistics::new();   // Initialize error statistics
        panic_mode = false;                    // Start in normal mode
    }
    
    /// Report error dengan context dan recovery suggestion
    /// @param error_type Type dari error yang terjadi
    /// @param message Error message yang descriptive
    /// @param location Source location dimana error terjadi
    /// @param severity Severity level dari error
    function report_error(ErrorType error_type, string memory message, 
                         SourceLocation location, ErrorSeverity severity) public {
        // Build error object (minimal fields)
        OmegaError error = OmegaError::new(error_type, message, location, severity);
        
        // Register error
        registry.register_error(error);
        
        // Update statistics (counts by type and severity)
        statistics.error_counts[error_type] += 1;
        statistics.severity_counts[severity] += 1;
        if (severity == ErrorSeverity.Warning) {
            statistics.total_warnings += 1;
        } else if (severity == ErrorSeverity.Error || severity == ErrorSeverity.Fatal) {
            statistics.total_errors += 1;
            if (statistics.first_error_time == 0) {
                statistics.first_error_time = block.timestamp;
            }
        }
        
        // Report error melalui appropriate channel
        reporter.report(error);
        
        // Simplified recovery: avoid relying on unavailable OmegaError fields
        if (severity == ErrorSeverity.Fatal) {
            emit FatalError(error.message, error.location.file, error.location.line);
            panic(string.concat("Fatal error encountered: ", error.message));
        }
    }
    
    /// Enter panic mode untuk error recovery
    /// @param trigger_error Error yang menyebabkan panic mode
    function enter_panic_mode(OmegaError trigger_error) private {
        panic_mode = true;
        emit PanicModeEntered(trigger_error.message);
        
        // Attempt to recover dari panic mode
        bool recovered = recovery.panic_recovery(trigger_error);
        
        if (recovered) {
            exit_panic_mode();
        }
    }
    
    /// Exit panic mode setelah successful recovery
    function exit_panic_mode() private {
        panic_mode = false;
        emit PanicModeExited();
    }
    
    /// Push error context untuk nested error handling
    /// @param context Context information untuk error scope
    function push_context(ErrorContext context) public {
        error_stack.push(context);
    }
    
    /// Pop error context setelah selesai dengan scope
    function pop_context() public {
        if (error_stack.length > 0) {
            error_stack.pop();
        }
    }
    
    /// Get current error context untuk error reporting
    /// @return ErrorContext Current context atau empty jika tidak ada
    function get_current_context() public view returns (ErrorContext) {
        if (error_stack.length > 0) {
            return error_stack[error_stack.length - 1];
        }
        return ErrorContext::empty();
    }
    
    /// Check apakah compiler dalam panic mode
    /// @return bool True jika dalam panic mode
    function is_panic_mode() public view returns (bool) {
        return panic_mode;
    }
    
    /// Get error statistics untuk reporting
    /// @return ErrorStatistics Current error statistics
    function get_statistics() public view returns (ErrorStatistics) {
        return statistics;
    }
    
    /// Reset error handler untuk fresh compilation
    function reset() public {
        registry.clear();
        error_stack = [];
        statistics.reset();
        panic_mode = false;
    }

    /// Overload: Report error using a full OmegaError object (from semantic modules)
    function report_error(OmegaError error) public {
        // Register error
        registry.register_error(error);
        
        // Update statistics
        statistics.error_counts[error.error_type] += 1;
        statistics.severity_counts[error.severity] += 1;
        if (error.severity == ErrorSeverity.Warning) {
            statistics.total_warnings += 1;
        } else if (error.severity == ErrorSeverity.Error || error.severity == ErrorSeverity.Fatal) {
            statistics.total_errors += 1;
            if (statistics.first_error_time == 0) {
                statistics.first_error_time = block.timestamp;
            }
        }
        
        // Report error
        reporter.report(error);
        
        // Only handle fatal termination here; non-fatal recovery is managed elsewhere
        if (error.severity == ErrorSeverity.Fatal) {
            emit FatalError(error.message, error.location.file, error.location.line);
            panic(string.concat("Fatal error encountered: ", error.message));
        }
    }

    /// Convenience getters for analyzer summaries
    function get_error_count() public view returns (uint256) {
        return statistics.total_errors;
    }
    
    function get_warning_count() public view returns (uint256) {
        return statistics.total_warnings;
    }
    
    function has_errors() public view returns (bool) {
        return statistics.total_errors > 0;
    }
    
    function has_warnings() public view returns (bool) {
        return statistics.total_warnings > 0;
    }
    
    // Expose registry-collected errors for external consumers (analyzers/tests)
    function get_all_errors() public view returns (OmegaError[]) {
        return registry.get_all_errors();
    }

    function get_errors_by_type(ErrorType error_type) public view returns (OmegaError[]) {
        return registry.get_errors_by_type(error_type);
    }

    function get_errors_by_file(string memory file_path) public view returns (OmegaError[]) {
        return registry.get_errors_by_file(file_path);
    }
    
    /// Clear registry untuk fresh compilation
    function clear() public {
        all_errors = [];
        // Clear mappings (implementation detail)
    }
}

/// Error reporter untuk output generation
/// Mendukung multiple output formats dan channels
blockchain ErrorReporter {
    state {
        ReportFormat format;        // Output format untuk errors
        bool colored_output;        // Enable colored terminal output
        bool verbose_mode;          // Enable verbose error reporting
        string output_file;         // File untuk error output (optional)
    }
    
    /// Constructor dengan default configuration
    constructor() {
        format = ReportFormat.Console;
        colored_output = true;
        verbose_mode = false;
        output_file = "";
    }
    
    /// Report error dengan appropriate formatting
    /// @param error Error object yang akan direport
    function report(OmegaError error) public {
        if (format == ReportFormat.Console) {
            report_console(error);
        } else if (format == ReportFormat.JSON) {
            report_json(error);
        } else if (format == ReportFormat.XML) {
            report_xml(error);
        }
    }
    
    /// Report error ke console dengan formatting
    /// @param error Error object untuk console output
    function report_console(OmegaError error) private {
        string memory severity_str = get_severity_string(error.severity);
        string memory color_code = colored_output ? get_color_code(error.severity) : "";
        string memory reset_code = colored_output ? "\033[0m" : "";
        
        // Format: [ERROR] file.mega:10:5: Type mismatch
        string memory formatted = string.concat(
            color_code,
            "[", severity_str, "] ",
            error.location.file, ":",
            uint_to_string(error.location.line), ":",
            uint_to_string(error.location.column), ": ",
            error.message,
            reset_code
        );
        
        emit ErrorReported(formatted);
        
        // Show suggestions jika ada
        if (error.suggestions.length > 0) {
            for (uint256 i = 0; i < error.suggestions.length; i++) {
                emit ErrorSuggestion(string.concat("  Suggestion: ", error.suggestions[i]));
            }
        }
    }
    
    /// Get severity string untuk display
    /// @param severity Error severity
    /// @return string String representation dari severity
    function get_severity_string(ErrorSeverity severity) private pure returns (string memory) {
        if (severity == ErrorSeverity.Info) return "INFO";
        if (severity == ErrorSeverity.Warning) return "WARNING";
        if (severity == ErrorSeverity.Error) return "ERROR";
        if (severity == ErrorSeverity.Fatal) return "FATAL";
        return "UNKNOWN";
    }
    
    /// Get ANSI color code untuk severity
    /// @param severity Error severity
    /// @return string ANSI color code
    function get_color_code(ErrorSeverity severity) private pure returns (string memory) {
        if (severity == ErrorSeverity.Info) return "\033[36m";      // Cyan
        if (severity == ErrorSeverity.Warning) return "\033[33m";   // Yellow
        if (severity == ErrorSeverity.Error) return "\033[31m";     // Red
        if (severity == ErrorSeverity.Fatal) return "\033[35m";     // Magenta
        return "";
    }
    
    /// Set report format
    /// @param new_format Format baru untuk reporting
    function set_format(ReportFormat new_format) public {
        format = new_format;
    }
    
    /// Enable/disable colored output
    /// @param enabled True untuk enable colors
    function set_colored_output(bool enabled) public {
        colored_output = enabled;
    }
}

/// Error recovery system untuk handling dan recovery dari errors
/// Implementasi berbagai recovery strategies
blockchain ErrorRecovery {
    state {
        mapping(ErrorType => ErrorRecoveryStrategy) strategies; // Recovery strategies per error type
        uint256 max_recovery_attempts;                          // Maximum recovery attempts
        uint256 current_recovery_attempts;                      // Current attempt count
    }
    
    /// Constructor dengan default recovery strategies
    constructor() {
        max_recovery_attempts = 3;
        current_recovery_attempts = 0;
        initialize_default_strategies();
    }
    
    /// Initialize default recovery strategies untuk common errors
    function initialize_default_strategies() private {
        strategies[ErrorType.UnexpectedToken] = ErrorRecoveryStrategy.SkipToSemicolon;
        strategies[ErrorType.MissingToken] = ErrorRecoveryStrategy.InsertToken;
        strategies[ErrorType.MismatchedBraces] = ErrorRecoveryStrategy.BalanceBraces;
        strategies[ErrorType.UndefinedSymbol] = ErrorRecoveryStrategy.SuggestSimilar;
        strategies[ErrorType.TypeMismatch] = ErrorRecoveryStrategy.TypeCoercion;
    }
    
    /// Attempt error recovery dengan given strategy
    /// @param error Error yang akan di-recover
    /// @param strategy Recovery strategy yang akan digunakan
    /// @return bool True jika recovery berhasil
    function attempt_recovery(OmegaError error, ErrorRecoveryStrategy strategy) public returns (bool) {
        if (current_recovery_attempts >= max_recovery_attempts) {
            return false;  // Too many recovery attempts
        }
        
        current_recovery_attempts++;
        
        bool success = false;
        
        if (strategy == ErrorRecoveryStrategy.SkipToSemicolon) {
            success = skip_to_semicolon_recovery(error);
        } else if (strategy == ErrorRecoveryStrategy.InsertToken) {
            success = insert_token_recovery(error);
        } else if (strategy == ErrorRecoveryStrategy.BalanceBraces) {
            success = balance_braces_recovery(error);
        } else if (strategy == ErrorRecoveryStrategy.SuggestSimilar) {
            success = suggest_similar_recovery(error);
        } else if (strategy == ErrorRecoveryStrategy.TypeCoercion) {
            success = type_coercion_recovery(error);
        }
        
        if (success) {
            current_recovery_attempts = 0;  // Reset counter pada successful recovery
        }
        
        return success;
    }
    
    /// Panic mode recovery untuk severe errors
    /// @param trigger_error Error yang menyebabkan panic mode
    /// @return bool True jika panic recovery berhasil
    function panic_recovery(OmegaError trigger_error) public returns (bool) {
        // Implement panic mode recovery logic
        // Skip tokens until synchronization point
        return skip_to_synchronization_point(trigger_error);
    }
    
    /// Get recovery strategy untuk error type
    /// @param error_type Type dari error
    /// @return ErrorRecoveryStrategy Strategy untuk error type tersebut
    function get_strategy(ErrorType error_type) public view returns (ErrorRecoveryStrategy) {
        return strategies[error_type];
    }
    
    // Recovery strategy implementations
    function skip_to_semicolon_recovery(OmegaError error) private returns (bool) {
        // Skip tokens until we find a semicolon or end of statement
        uint256 current_pos = error.position;
        string memory source = error.source_code;
        
        // Find next semicolon
        for (uint256 i = current_pos; i < bytes(source).length; i++) {
            if (bytes(source)[i] == ';') {
                // Update parser position to after semicolon
                return true;
            }
        }
        return false;  // No semicolon found
    }
    
    function insert_token_recovery(OmegaError error) private returns (bool) {
        // Insert commonly missing tokens based on context
        if (error.error_type == ErrorType.SyntaxError) {
            string memory expected = error.expected_token;
            
            // Common missing tokens
            if (keccak256(bytes(expected)) == keccak256(bytes(";"))) {
                // Insert semicolon at current position
                return true;
            } else if (keccak256(bytes(expected)) == keccak256(bytes("}"))) {
                // Insert closing brace
                return true;
            } else if (keccak256(bytes(expected)) == keccak256(bytes(")"))) {
                // Insert closing parenthesis
                return true;
            }
        }
        return false;
    }
    
    function balance_braces_recovery(OmegaError error) private returns (bool) {
        // Balance unmatched braces by counting and inserting missing ones
        string memory source = error.source_code;
        uint256 open_braces = 0;
        uint256 close_braces = 0;
        
        // Count braces up to error position
        for (uint256 i = 0; i < error.position && i < bytes(source).length; i++) {
            if (bytes(source)[i] == '{') {
                open_braces++;
            } else if (bytes(source)[i] == '}') {
                close_braces++;
            }
        }
        
        // Insert missing closing braces
        if (open_braces > close_braces) {
            uint256 missing = open_braces - close_braces;
            // Insert 'missing' number of closing braces
            return true;
        }
        
        return false;
    }
    
    function suggest_similar_recovery(OmegaError error) private returns (bool) {
        // Suggest similar symbols using Levenshtein distance
        if (error.error_type == ErrorType.UndefinedSymbol) {
            string memory undefined_symbol = error.symbol_name;
            
            // Common typos and suggestions
            string[10] memory common_keywords = [
                "function", "contract", "mapping", "address", "uint256",
                "string", "bool", "public", "private", "internal"
            ];
            
            // Find closest match (simplified implementation)
            for (uint256 i = 0; i < common_keywords.length; i++) {
                if (similar_strings(undefined_symbol, common_keywords[i])) {
                    // Add suggestion to error context
                    return false;  // Suggestion only, no actual recovery
                }
            }
        }
        return false;
    }
    
    function type_coercion_recovery(OmegaError error) private returns (bool) {
        // Attempt automatic type coercion for compatible types
        if (error.error_type == ErrorType.TypeError) {
            string memory from_type = error.actual_type;
            string memory to_type = error.expected_type;
            
            // Safe coercions
            if (keccak256(bytes(from_type)) == keccak256(bytes("uint8")) &&
                keccak256(bytes(to_type)) == keccak256(bytes("uint256"))) {
                // uint8 -> uint256 is safe
                return true;
            }
            
            if (keccak256(bytes(from_type)) == keccak256(bytes("address")) &&
                keccak256(bytes(to_type)) == keccak256(bytes("address payable"))) {
                // address -> address payable with explicit cast
                return true;
            }
        }
        return false;
    }
    
    function skip_to_synchronization_point(OmegaError error) private returns (bool) {
        // Panic mode recovery - skip to next synchronization point
        string memory source = error.source_code;
        uint256 current_pos = error.position;
        
        // Synchronization points: function, contract, struct, enum keywords
        string[4] memory sync_points = ["function", "contract", "struct", "enum"];
        
        for (uint256 i = current_pos; i < bytes(source).length; i++) {
            // Check if we're at a synchronization point
            for (uint256 j = 0; j < sync_points.length; j++) {
                if (starts_with_keyword(source, i, sync_points[j])) {
                    // Found synchronization point
                    return true;
                }
            }
        }
        return false;
    }
    
    // Helper functions
    function similar_strings(string memory a, string memory b) private pure returns (bool) {
        // Simplified similarity check - same length and 1-2 character difference
        bytes memory ba = bytes(a);
        bytes memory bb = bytes(b);
        
        if (ba.length != bb.length) return false;
        
        uint256 differences = 0;
        for (uint256 i = 0; i < ba.length; i++) {
            if (ba[i] != bb[i]) {
                differences++;
                if (differences > 2) return false;
            }
        }
        return differences <= 2;
    }
    
    function starts_with_keyword(string memory source, uint256 pos, string memory keyword) private pure returns (bool) {
        bytes memory src = bytes(source);
        bytes memory kw = bytes(keyword);
        
        if (pos + kw.length > src.length) return false;
        
        for (uint256 i = 0; i < kw.length; i++) {
            if (src[pos + i] != kw[i]) return false;
        }
        return true;
    }
}

/// Enum untuk recovery strategies
enum ErrorRecoveryStrategy {
    None,               // No recovery attempted
    SkipToSemicolon,    // Skip tokens until semicolon
    InsertToken,        // Insert missing token
    BalanceBraces,      // Balance unmatched braces
    SuggestSimilar,     // Suggest similar symbols
    TypeCoercion,       // Attempt type coercion
    Synchronize         // Synchronize to known state
}

/// Enum untuk report formats
enum ReportFormat {
    Console,    // Console text output
    JSON,       // JSON format
    XML,        // XML format
    HTML        // HTML format
}

// Events untuk error reporting
event ErrorReported(string formatted_error);
event ErrorSuggestion(string suggestion);
event FatalError(string message, string file, uint256 line);
event PanicModeEntered(string trigger_message);
event PanicModeExited();

// Utility functions
function uint_to_string(uint256 value) private pure returns (string memory) {
    if (value == 0) {
        return "0";
    }
    
    uint256 temp = value;
    uint256 digits;
    
    while (temp != 0) {
        digits++;
        temp /= 10;
    }
    
    bytes memory buffer = new bytes(digits);
    
    while (value != 0) {
        digits -= 1;
        buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
        value /= 10;
    }
    
    return string(buffer);
}

/// Overload: Report error using a full OmegaError object (from semantic modules)
function report_error(OmegaError error) public {
    // Register error
    registry.register_error(error);
    
    // Update statistics
    statistics.error_counts[error.error_type] += 1;
    statistics.severity_counts[error.severity] += 1;
    if (error.severity == ErrorSeverity.Warning) {
        statistics.total_warnings += 1;
    } else if (error.severity == ErrorSeverity.Error || error.severity == ErrorSeverity.Fatal) {
        statistics.total_errors += 1;
        if (statistics.first_error_time == 0) {
            statistics.first_error_time = block.timestamp;
        }
    }
    
    // Report error
    reporter.report(error);
    
    // Only handle fatal termination here; non-fatal recovery is managed elsewhere
    if (error.severity == ErrorSeverity.Fatal) {
        emit FatalError(error.message, error.location.file, error.location.line);
        panic(string.concat("Fatal error encountered: ", error.message));
    }
}

/// Convenience getters for analyzer summaries
function get_error_count() public view returns (uint256) {
    return statistics.total_errors;
}

function get_warning_count() public view returns (uint256) {
    return statistics.total_warnings;
}

function has_errors() public view returns (bool) {
    return statistics.total_errors > 0;
}

function has_warnings() public view returns (bool) {
    return statistics.total_warnings > 0;
}
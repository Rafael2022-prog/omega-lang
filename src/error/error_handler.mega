// OMEGA Error Handler - Comprehensive Error Management System
// Written in MEGA language for production compiler
// Integrates with all compiler components for unified error handling

import "./error_types.mega";
import "./error_recovery.mega";
import "./error_diagnostics.mega";
import "../utils/secure_timestamp.mega";
import "../semantic/semantic_context.mega";

/// Main error handler untuk OMEGA compiler
/// Menyediakan unified interface untuk semua error management
blockchain OmegaErrorHandler {
    state {
        ErrorRegistry registry;
        ErrorReporter reporter;
        ErrorRecoverySystem recovery;
        ErrorDiagnostics diagnostics;
        ErrorContext[] error_stack;
        ErrorStatistics statistics;
        ErrorBuffer error_buffer;
        bool panic_mode;
        uint256 max_errors;
        uint256 error_count;
        uint256 warning_count;
    }
    
    constructor() {
        registry = ErrorRegistry::new();
        reporter = ErrorReporter::new();
        recovery = ErrorRecoverySystem::new();
        diagnostics = ErrorDiagnostics::new();
        error_stack = [];
        statistics = ErrorStatistics::new();
        error_buffer = ErrorBuffer::new();
        panic_mode = false;
        max_errors = 100;
        error_count = 0;
        warning_count = 0;
        
        initialize_default_handlers();
    }
    
    /// Handle error dengan comprehensive recovery
    function handle_error(OmegaError memory error, CompilationContext memory context) 
        public returns (ErrorHandlingResult memory) {
        
        // Check error limits
        if (error_count >= max_errors) {
            return ErrorHandlingResult({
                success: false,
                error_handled: false,
                recovery_attempted: false,
                recovery_success: false,
                message: "Maximum error limit reached",
                suggestions: new string[](0)
            });
        }
        
        // Register error
        registry.register_error(error);
        error_count++;
        
        // Update statistics
        statistics.record_error(error);
        
        // Attempt recovery if possible
        bool recovery_success = false;
        bool recovery_attempted = false;
        
        if (should_attempt_recovery(error)) {
            recovery_attempted = true;
            RecoveryResult memory recovery_result = recovery.attempt_recovery(error, context);
            recovery_success = recovery_result.success;
            
            if (recovery_success) {
                error_count--; // Don't count recovered errors
                emit ErrorRecovered(error.message, recovery_result.strategy_used);
            }
        }
        
        // Generate diagnostics
        string[] memory suggestions = diagnostics.generate_suggestions(error, context);
        
        // Report error
        reporter.report_error(error, suggestions);
        
        // Handle fatal errors
        if (error.severity == ErrorSeverity.Fatal) {
            handle_fatal_error(error);
        }
        
        return ErrorHandlingResult({
            success: !recovery_success, // Success if error was recovered
            error_handled: true,
            recovery_attempted: recovery_attempted,
            recovery_success: recovery_success,
            message: recovery_success ? "Error recovered successfully" : error.message,
            suggestions: suggestions
        });
    }
    
    /// Handle multiple errors
    function handle_errors(OmegaError[] memory errors, CompilationContext memory context) 
        public returns (ErrorHandlingResult[] memory) {
        
        ErrorHandlingResult[] memory results = new ErrorHandlingResult[](errors.length);
        
        for (uint256 i = 0; i < errors.length; i++) {
            results[i] = handle_error(errors[i], context);
        }
        
        return results;
    }
    
    /// Handle warnings
    function handle_warning(OmegaError memory warning, CompilationContext memory context) 
        public {
        
        warning_count++;
        statistics.record_warning(warning);
        reporter.report_warning(warning);
        emit WarningHandled(warning.message);
    }
    
    /// Check if recovery should be attempted
    function should_attempt_recovery(OmegaError memory error) private view returns (bool) {
        return !panic_mode && 
               error.severity != ErrorSeverity.Fatal &&
               error.error_type != ErrorType.InternalError &&
               error.error_type != ErrorType.SystemError;
    }
    
    /// Handle fatal errors
    function handle_fatal_error(OmegaError memory error) private {
        emit FatalErrorEncountered(error.message, error.location);
        
        if (!panic_mode) {
            enter_panic_mode(error);
        }
        
        // Generate comprehensive diagnostics for fatal errors
        ErrorDiagnostic[] memory diagnostics = generate_fatal_error_diagnostics(error);
        reporter.report_fatal_error(error, diagnostics);
    }
    
    /// Enter panic mode for severe error conditions
    function enter_panic_mode(OmegaError memory trigger_error) private {
        panic_mode = true;
        emit PanicModeEntered(trigger_error.message);
        
        // Attempt panic recovery
        RecoveryResult memory panic_result = recovery.execute_panic_mode_recovery(trigger_error);
        
        if (panic_result.success) {
            exit_panic_mode();
        }
    }
    
    /// Exit panic mode after successful recovery
    function exit_panic_mode() private {
        panic_mode = false;
        emit PanicModeExited();
    }
    
    /// Generate comprehensive diagnostics for fatal errors
    function generate_fatal_error_diagnostics(OmegaError memory error) 
        private view returns (ErrorDiagnostic[] memory) {
        
        ErrorDiagnostic[] memory diagnostics = new ErrorDiagnostic[](3);
        
        diagnostics[0] = ErrorDiagnostic({
            type: DiagnosticType.ErrorContext,
            message: "Fatal error occurred during compilation",
            location: error.location,
            severity: DiagnosticSeverity.Critical
        });
        
        diagnostics[1] = ErrorDiagnostic({
            type: DiagnosticType.SystemState,
            message: "Compilation cannot continue due to fatal error",
            location: error.location,
            severity: DiagnosticSeverity.Critical
        });
        
        diagnostics[2] = ErrorDiagnostic({
            type: DiagnosticType.RecoverySuggestion,
            message: "Check compiler installation and source code integrity",
            location: error.location,
            severity: DiagnosticSeverity.Info
        });
        
        return diagnostics;
    }
    
    /// Push error context for nested error handling
    function push_error_context(ErrorContext memory context) public {
        error_stack.push(context);
        emit ErrorContextPushed(context.description);
    }
    
    /// Pop error context
    function pop_error_context() public {
        if (error_stack.length > 0) {
            ErrorContext memory context = error_stack[error_stack.length - 1];
            error_stack.pop();
            emit ErrorContextPopped(context.description);
        }
    }
    
    /// Get current error context
    function get_current_error_context() public view returns (ErrorContext memory) {
        if (error_stack.length > 0) {
            return error_stack[error_stack.length - 1];
        }
        return ErrorContext({
            description: "No context",
            location: ErrorLocation({
                file: "unknown",
                line: 0,
                column: 0,
                position: 0
            }),
            context_type: ErrorContextType.General
        });
    }
    
    /// Get error statistics
    function get_error_statistics() public view returns (ErrorStatistics memory) {
        return statistics;
    }
    
    /// Get error summary
    function get_error_summary() public view returns (ErrorSummary memory) {
        return ErrorSummary({
            total_errors: error_count,
            total_warnings: warning_count,
            fatal_errors: statistics.fatal_error_count,
            recovered_errors: statistics.recovered_error_count,
            panic_mode: panic_mode,
            has_errors: error_count > 0
        });
    }
    
    /// Clear all errors (for testing)
    function clear_all_errors() public {
        error_count = 0;
        warning_count = 0;
        panic_mode = false;
        error_stack = [];
        registry.clear();
        statistics.clear();
        error_buffer.clear();
        emit ErrorsCleared();
    }
    
    /// Check if compilation can continue
    function can_continue_compilation() public view returns (bool) {
        return !panic_mode && error_count < max_errors;
    }
    
    /// Initialize default error handlers
    function initialize_default_handlers() private {
        // Register common error patterns
        registry.register_error_pattern("syntax_error", ErrorType.SyntaxError);
        registry.register_error_pattern("type_mismatch", ErrorType.TypeError);
        registry.register_error_pattern("undefined_symbol", ErrorType.SemanticError);
        registry.register_error_pattern("compilation_failed", ErrorType.CompilationError);
        
        emit ErrorHandlerInitialized();
    }
    
    /// Buffer errors for batch processing
    function buffer_error(OmegaError memory error) public {
        error_buffer.add_error(error);
        emit ErrorBuffered(error.message);
    }
    
    /// Process buffered errors
    function process_buffered_errors(CompilationContext memory context) 
        public returns (ErrorHandlingResult[] memory) {
        
        OmegaError[] memory buffered_errors = error_buffer.get_errors();
        error_buffer.clear();
        
        return handle_errors(buffered_errors, context);
    }
    
    /// Events
    event ErrorHandled(string message, ErrorType error_type);
    event ErrorRecovered(string message, RecoveryStrategy strategy);
    event WarningHandled(string message);
    event FatalErrorEncountered(string message, ErrorLocation location);
    event PanicModeEntered(string trigger_message);
    event PanicModeExited();
    event ErrorContextPushed(string description);
    event ErrorContextPopped(string description);
    event ErrorsCleared();
    event ErrorHandlerInitialized();
    event ErrorBuffered(string message);
}

/// Error handling result structure
struct ErrorHandlingResult {
    bool success;
    bool error_handled;
    bool recovery_attempted;
    bool recovery_success;
    string message;
    string[] suggestions;
}

/// Error summary structure
struct ErrorSummary {
    uint256 total_errors;
    uint256 total_warnings;
    uint256 fatal_errors;
    uint256 recovered_errors;
    bool panic_mode;
    bool has_errors;
}

/// Error buffer for batch processing
blockchain ErrorBuffer {
    state {
        OmegaError[] buffered_errors;
        uint256 max_buffer_size;
    }
    
    constructor() {
        buffered_errors = [];
        max_buffer_size = 50;
    }
    
    function add_error(OmegaError memory error) public {
        if (buffered_errors.length < max_buffer_size) {
            buffered_errors.push(error);
        }
    }
    
    function get_errors() public view returns (OmegaError[] memory) {
        return buffered_errors;
    }
    
    function clear() public {
        buffered_errors = [];
    }
    
    function is_full() public view returns (bool) {
        return buffered_errors.length >= max_buffer_size;
    }
}

/// Error statistics tracking
blockchain ErrorStatistics {
    state {
        mapping(ErrorType => uint256) error_counts;
        mapping(ErrorSeverity => uint256) severity_counts;
        uint256 total_errors;
        uint256 total_warnings;
        uint256 fatal_error_count;
        uint256 recovered_error_count;
        uint256 panic_mode_entries;
        mapping(string => uint256) file_error_counts;
    }
    
    constructor() {
        total_errors = 0;
        total_warnings = 0;
        fatal_error_count = 0;
        recovered_error_count = 0;
        panic_mode_entries = 0;
    }
    
    function record_error(OmegaError memory error) public {
        error_counts[error.error_type]++;
        severity_counts[error.severity]++;
        total_errors++;
        
        if (error.severity == ErrorSeverity.Fatal) {
            fatal_error_count++;
        }
        
        file_error_counts[error.location.file]++;
    }
    
    function record_warning(OmegaError memory warning) public {
        total_warnings++;
    }
    
    function record_recovery() public {
        recovered_error_count++;
    }
    
    function record_panic_mode_entry() public {
        panic_mode_entries++;
    }
    
    function get_error_count(ErrorType error_type) public view returns (uint256) {
        return error_counts[error_type];
    }
    
    function get_severity_count(ErrorSeverity severity) public view returns (uint256) {
        return severity_counts[severity];
    }
    
    function clear() public {
        total_errors = 0;
        total_warnings = 0;
        fatal_error_count = 0;
        recovered_error_count = 0;
        panic_mode_entries = 0;
    }
}
// OMEGA Expression Parser - Modul khusus untuk parsing expressions
// Menggunakan precedence climbing untuk menangani operator precedence

import "./ast_nodes.mega";
import "../lexer/lexer.mega" as Lexer;
import "../error/error.mega";

/// Parser khusus untuk expressions dengan precedence climbing
blockchain ExpressionParser {
    state {
        Token[] tokens;
        uint256 current;
        OmegaErrorHandler error_handler;
        string current_file;
    }
    
    constructor() {
        current = 0;
        error_handler = OmegaErrorHandler::new();
        current_file = "";
    }
    
    /// Set tokens untuk parsing
    function set_tokens(Token[] memory input_tokens, uint256 start_index) public {
        tokens = input_tokens;
        current = start_index;
    }
    
    /// Get current token index
    function get_current_index() public view returns (uint256) {
        return current;
    }
    
    /// Parse expression dengan precedence climbing
    function parse_expression() public returns (Expression memory) {
        return parse_assignment();
    }
    
    /// Parse assignment expressions (lowest precedence)
    function parse_assignment() private returns (Expression memory) {
        Expression memory expr = parse_ternary();
        
        if (match_assignment_operator()) {
            AssignmentOperator op = get_assignment_operator(previous().token_type);
            Expression memory right = parse_assignment();
            
            return Expression({
                expression_type: ExpressionType.Assignment,
                assignment: AssignmentExpression({
                    left: expr,
                    operator: op,
                    right: right
                })
            });
        }
        
        return expr;
    }
    
    /// Parse ternary conditional expressions (? :)
    function parse_ternary() private returns (Expression memory) {
        Expression memory expr = parse_logical_or();
        
        if (match(TokenType.Question)) {
            Expression memory then_expr = parse_expression();
            consume(TokenType.Colon, "Expected ':' in ternary expression");
            Expression memory else_expr = parse_ternary();
            
            return Expression({
                expression_type: ExpressionType.Ternary,
                ternary: TernaryExpression({
                    condition: expr,
                    then_expr: then_expr,
                    else_expr: else_expr
                })
            });
        }
        
        return expr;
    }
    
    /// Parse logical OR expressions
    function parse_logical_or() private returns (Expression memory) {
        Expression memory expr = parse_logical_and();
        
        while (match(TokenType.LogicalOr)) {
            BinaryOperator op = BinaryOperator.LogicalOr;
            Expression memory right = parse_logical_and();
            
            expr = Expression({
                expression_type: ExpressionType.Binary,
                binary: BinaryExpression({
                    left: expr,
                    operator: op,
                    right: right
                })
            });
        }
        
        return expr;
    }
    
    /// Parse logical AND expressions
    function parse_logical_and() private returns (Expression memory) {
        Expression memory expr = parse_equality();
        
        while (match(TokenType.LogicalAnd)) {
            BinaryOperator op = BinaryOperator.LogicalAnd;
            Expression memory right = parse_equality();
            
            expr = Expression({
                expression_type: ExpressionType.Binary,
                binary: BinaryExpression({
                    left: expr,
                    operator: op,
                    right: right
                })
            });
        }
        
        return expr;
    }
    
    /// Parse equality expressions (==, !=)
    function parse_equality() private returns (Expression memory) {
        Expression memory expr = parse_comparison();
        
        while (match_equality_operator()) {
            BinaryOperator op = get_equality_operator(previous().token_type);
            Expression memory right = parse_comparison();
            
            expr = Expression({
                expression_type: ExpressionType.Binary,
                binary: BinaryExpression({
                    left: expr,
                    operator: op,
                    right: right
                })
            });
        }
        
        return expr;
    }
    
    /// Parse comparison expressions (<, <=, >, >=)
    function parse_comparison() private returns (Expression memory) {
        Expression memory expr = parse_term();
        
        while (match_comparison_operator()) {
            BinaryOperator op = get_comparison_operator(previous().token_type);
            Expression memory right = parse_term();
            
            expr = Expression({
                expression_type: ExpressionType.Binary,
                binary: BinaryExpression({
                    left: expr,
                    operator: op,
                    right: right
                })
            });
        }
        
        return expr;
    }
    
    /// Parse term expressions (+, -)
    function parse_term() private returns (Expression memory) {
        Expression memory expr = parse_factor();
        
        while (match_term_operator()) {
            BinaryOperator op = get_term_operator(previous().token_type);
            Expression memory right = parse_factor();
            
            expr = Expression({
                expression_type: ExpressionType.Binary,
                binary: BinaryExpression({
                    left: expr,
                    operator: op,
                    right: right
                })
            });
        }
        
        return expr;
    }
    
    /// Parse factor expressions (*, /, %)
    function parse_factor() private returns (Expression memory) {
        Expression memory expr = parse_unary();
        
        while (match_factor_operator()) {
            BinaryOperator op = get_factor_operator(previous().token_type);
            Expression memory right = parse_unary();
            
            expr = Expression({
                expression_type: ExpressionType.Binary,
                binary: BinaryExpression({
                    left: expr,
                    operator: op,
                    right: right
                })
            });
        }
        
        return expr;
    }
    
    /// Parse unary expressions (!, -, +, ~)
    function parse_unary() private returns (Expression memory) {
        if (match_unary_operator()) {
            UnaryOperator op = get_unary_operator(previous().token_type);
            Expression memory right = parse_unary();
            
            return Expression({
                expression_type: ExpressionType.Unary,
                unary: UnaryExpression({
                    operator: op,
                    operand: right
                })
            });
        }
        
        return parse_call();
    }
    
    /// Parse call expressions dan member access
    function parse_call() private returns (Expression memory) {
        Expression memory expr = parse_primary();
        
        while (true) {
            if (match(TokenType.LeftParen)) {
                expr = finish_call(expr);
            } else if (match(TokenType.LeftBracket)) {
                Expression memory index = parse_expression();
                consume(TokenType.RightBracket, "Expected ']' after array index");
                
                expr = Expression({
                    expression_type: ExpressionType.ArrayAccess,
                    array_access: ArrayAccessExpression({
                        array: expr,
                        index: index
                    })
                });
            } else if (match(TokenType.Dot)) {
                Token memory name = consume(TokenType.Identifier, "Expected property name after '.'");
                
                expr = Expression({
                    expression_type: ExpressionType.MemberAccess,
                    member_access: MemberAccessExpression({
                        object: expr,
                        member: name.lexeme
                    })
                });
            } else {
                break;
            }
        }
        
        return expr;
    }
    
    /// Finish parsing function call
    function finish_call(Expression memory callee) private returns (Expression memory) {
        Expression[] memory arguments;
        uint256 arg_count = 0;
        
        if (!check(TokenType.RightParen)) {
            do {
                arguments[arg_count] = parse_expression();
                arg_count++;
            } while (match(TokenType.Comma));
        }
        
        consume(TokenType.RightParen, "Expected ')' after arguments");
        
        return Expression({
            expression_type: ExpressionType.Call,
            call: CallExpression({
                callee: callee,
                arguments: arguments
            })
        });
    }
    
    /// Parse primary expressions (literals, identifiers, parentheses, casts, struct literals)
    function parse_primary() private returns (Expression memory) {
        // Handle type casting: (uint256) expr, (address) expr, etc.
        if (check(TokenType.LeftParen) && is_type_at_position(1)) {
            consume(TokenType.LeftParen, "Expected '('");
            Type memory cast_type = parse_type();
            consume(TokenType.RightParen, "Expected ')' after type");
            
            Expression memory operand = parse_unary();
            
            return Expression({
                expression_type: ExpressionType.TypeCast,
                type_cast: TypeCastExpression({
                    target_type: cast_type,
                    operand: operand
                })
            });
        }
        
        // Handle boolean literals
        if (match(TokenType.True)) {
            return Expression({
                expression_type: ExpressionType.Literal,
                literal: Literal({
                    literal_type: LiteralType.Boolean,
                    boolean_value: true
                })
            });
        }
        
        if (match(TokenType.False)) {
            return Expression({
                expression_type: ExpressionType.Literal,
                literal: Literal({
                    literal_type: LiteralType.Boolean,
                    boolean_value: false
                })
            });
        }
        
        // Handle numeric literals
        if (match(TokenType.Number)) {
            return Expression({
                expression_type: ExpressionType.Literal,
                literal: Literal({
                    literal_type: LiteralType.Integer,
                    integer_value: parse_integer_from_string(previous().lexeme)
                })
            });
        }
        
        // Handle string literals
        if (match(TokenType.String)) {
            return Expression({
                expression_type: ExpressionType.Literal,
                literal: Literal({
                    literal_type: LiteralType.String,
                    string_value: previous().lexeme
                })
            });
        }
        
        // Handle address literals
        if (match(TokenType.Address)) {
            return Expression({
                expression_type: ExpressionType.Literal,
                literal: Literal({
                    literal_type: LiteralType.Address,
                    address_value: address(previous().lexeme)
                })
            });
        }
        
        // Handle array/struct literals with identifier followed by {
        if (check(TokenType.Identifier)) {
            uint256 checkpoint = current;
            Token memory ident = advance();
            
            // Check for struct literal: Name { field: value, ... }
            if (match(TokenType.LeftBrace)) {
                StructLiteralField[] memory fields;
                uint256 field_count = 0;
                
                if (!check(TokenType.RightBrace)) {
                    do {
                        Token memory field_name = consume(TokenType.Identifier, "Expected field name");
                        consume(TokenType.Colon, "Expected ':' after field name");
                        Expression memory field_value = parse_expression();
                        
                        fields[field_count] = StructLiteralField({
                            name: field_name.lexeme,
                            value: field_value
                        });
                        field_count++;
                    } while (match(TokenType.Comma));
                }
                
                consume(TokenType.RightBrace, "Expected '}' after struct literal");
                
                return Expression({
                    expression_type: ExpressionType.StructLiteral,
                    struct_literal: StructLiteralExpression({
                        struct_name: ident.lexeme,
                        fields: fields
                    })
                });
            }
            
            // Not a struct literal, backtrack and return identifier
            current = checkpoint;
            consume(TokenType.Identifier, "Expected identifier");
            
            return Expression({
                expression_type: ExpressionType.Identifier,
                identifier: ident.lexeme
            });
        }
        
        // Handle array literals: [1, 2, 3]
        if (match(TokenType.LeftBracket)) {
            Expression[] memory elements;
            uint256 element_count = 0;
            
            if (!check(TokenType.RightBracket)) {
                do {
                    elements[element_count] = parse_expression();
                    element_count++;
                } while (match(TokenType.Comma));
            }
            
            consume(TokenType.RightBracket, "Expected ']' after array literal");
            
            return Expression({
                expression_type: ExpressionType.ArrayLiteral,
                array_literal: ArrayLiteralExpression({
                    elements: elements,
                    element_count: element_count
                })
            });
        }
        
        // Handle parenthesized expressions
        if (match(TokenType.LeftParen)) {
            Expression memory expr = parse_expression();
            consume(TokenType.RightParen, "Expected ')' after expression");
            return expr;
        }
        
        // Handle null/none literal
        if (match(TokenType.None)) {
            return Expression({
                expression_type: ExpressionType.Literal,
                literal: Literal({
                    literal_type: LiteralType.None,
                    none_value: true
                })
            });
        }
        
        revert("Expected expression");
    }
    
    // Helper functions untuk operator matching
    function match_assignment_operator() private view returns (bool) {
        return check(TokenType.Equal) || check(TokenType.PlusEqual) || 
               check(TokenType.MinusEqual) || check(TokenType.StarEqual) ||
               check(TokenType.SlashEqual) || check(TokenType.PercentEqual);
    }
    
    function match_equality_operator() private view returns (bool) {
        return check(TokenType.EqualEqual) || check(TokenType.BangEqual);
    }
    
    function match_comparison_operator() private view returns (bool) {
        return check(TokenType.Greater) || check(TokenType.GreaterEqual) ||
               check(TokenType.Less) || check(TokenType.LessEqual);
    }
    
    function match_term_operator() private view returns (bool) {
        return check(TokenType.Plus) || check(TokenType.Minus);
    }
    
    function match_factor_operator() private view returns (bool) {
        return check(TokenType.Star) || check(TokenType.Slash) || check(TokenType.Percent);
    }
    
    function match_unary_operator() private view returns (bool) {
        return check(TokenType.Bang) || check(TokenType.Minus) || 
               check(TokenType.Plus) || check(TokenType.Tilde);
    }
    
    // Helper functions untuk mendapatkan operator enum
    function get_assignment_operator(TokenType token_type) private pure returns (AssignmentOperator) {
        if (token_type == TokenType.Equal) return AssignmentOperator.Assign;
        if (token_type == TokenType.PlusEqual) return AssignmentOperator.AddAssign;
        if (token_type == TokenType.MinusEqual) return AssignmentOperator.SubAssign;
        if (token_type == TokenType.StarEqual) return AssignmentOperator.MulAssign;
        if (token_type == TokenType.SlashEqual) return AssignmentOperator.DivAssign;
        if (token_type == TokenType.PercentEqual) return AssignmentOperator.ModAssign;
        revert("Invalid assignment operator");
    }
    
    function get_equality_operator(TokenType token_type) private pure returns (BinaryOperator) {
        if (token_type == TokenType.EqualEqual) return BinaryOperator.Equal;
        if (token_type == TokenType.BangEqual) return BinaryOperator.NotEqual;
        revert("Invalid equality operator");
    }
    
    function get_comparison_operator(TokenType token_type) private pure returns (BinaryOperator) {
        if (token_type == TokenType.Greater) return BinaryOperator.Greater;
        if (token_type == TokenType.GreaterEqual) return BinaryOperator.GreaterEqual;
        if (token_type == TokenType.Less) return BinaryOperator.Less;
        if (token_type == TokenType.LessEqual) return BinaryOperator.LessEqual;
        revert("Invalid comparison operator");
    }
    
    function get_term_operator(TokenType token_type) private pure returns (BinaryOperator) {
        if (token_type == TokenType.Plus) return BinaryOperator.Add;
        if (token_type == TokenType.Minus) return BinaryOperator.Sub;
        revert("Invalid term operator");
    }
    
    function get_factor_operator(TokenType token_type) private pure returns (BinaryOperator) {
        if (token_type == TokenType.Star) return BinaryOperator.Mul;
        if (token_type == TokenType.Slash) return BinaryOperator.Div;
        if (token_type == TokenType.Percent) return BinaryOperator.Mod;
        revert("Invalid factor operator");
    }
    
    function get_unary_operator(TokenType token_type) private pure returns (UnaryOperator) {
        if (token_type == TokenType.Bang) return UnaryOperator.Not;
        if (token_type == TokenType.Minus) return UnaryOperator.Minus;
        if (token_type == TokenType.Plus) return UnaryOperator.Plus;
        if (token_type == TokenType.Tilde) return UnaryOperator.BitwiseNot;
        revert("Invalid unary operator");
    }
    
    // Utility functions
    function match(TokenType token_type) private returns (bool) {
        if (check(token_type)) {
            advance();
            return true;
        }
        return false;
    }
    
    function check(TokenType token_type) private view returns (bool) {
        if (is_at_end()) return false;
        return peek().token_type == token_type;
    }
    
    function advance() private returns (Token memory) {
        if (!is_at_end()) current++;
        return previous();
    }
    
    function is_at_end() private view returns (bool) {
        return peek().token_type == TokenType.EOF;
    }
    
    function peek() private view returns (Token memory) {
        return tokens[current];
    }
    
    function previous() private view returns (Token memory) {
        return tokens[current - 1];
    }
    
    function consume(TokenType token_type, string memory message) private returns (Token memory) {
        if (check(token_type)) return advance();
        
        error_handler.report_error(
            OmegaError({
                error_type: ErrorType.ParseError,
                message: message,
                location: SourceLocation({
                    file: current_file,
                    line: peek().line,
                    column: peek().column,
                    length: peek().lexeme.length
                }),
                context: ErrorContext.Parser,
                severity: ErrorSeverity.Error,
                error_code: "P001",
                suggestions: new string[](0)
            })
        );
        
        revert(message);
    }
    
    function parse_integer_from_string(string memory str) private pure returns (uint256) {
        bytes memory b = bytes(str);
        uint256 result = 0;
        
        for (uint256 i = 0; i < b.length; i++) {
            uint8 digit = uint8(b[i]) - 48; // ASCII '0' = 48
            require(digit <= 9, "Invalid digit in number");
            result = result * 10 + digit;
        }
        
        return result;
    }
    
    /// Helper function untuk check apakah ada type di position relative
    function is_type_at_position(uint256 offset) private view returns (bool) {
        uint256 pos = current + offset;
        if (pos >= tokens.length) return false;
        return is_type_keyword(tokens[pos].token_type);
    }
    
    /// Helper function untuk check apakah token adalah type keyword
    function is_type_keyword(TokenType token_type) private pure returns (bool) {
        return token_type == TokenType.Uint256 || 
               token_type == TokenType.Uint ||
               token_type == TokenType.Int256 || 
               token_type == TokenType.Int ||
               token_type == TokenType.Bool ||
               token_type == TokenType.Address ||
               token_type == TokenType.String ||
               token_type == TokenType.Bytes ||
               token_type == TokenType.Void ||
               token_type == TokenType.Identifier; // Struct names are identifiers
    }
    
    /// Parse type annotation
    function parse_type() private returns (Type memory) {
        Token memory base_type = peek();
        
        // Match primitive types
        if (check(TokenType.Uint256)) {
            advance();
            return Type({
                base_type: BaseType.Uint256,
                is_array: false,
                array_size: 0
            });
        }
        
        if (check(TokenType.Uint)) {
            advance();
            return Type({
                base_type: BaseType.Uint,
                is_array: false,
                array_size: 0
            });
        }
        
        if (check(TokenType.Int256)) {
            advance();
            return Type({
                base_type: BaseType.Int256,
                is_array: false,
                array_size: 0
            });
        }
        
        if (check(TokenType.Int)) {
            advance();
            return Type({
                base_type: BaseType.Int,
                is_array: false,
                array_size: 0
            });
        }
        
        if (check(TokenType.Bool)) {
            advance();
            return Type({
                base_type: BaseType.Bool,
                is_array: false,
                array_size: 0
            });
        }
        
        if (check(TokenType.Address)) {
            advance();
            return Type({
                base_type: BaseType.Address,
                is_array: false,
                array_size: 0
            });
        }
        
        if (check(TokenType.String)) {
            advance();
            return Type({
                base_type: BaseType.String,
                is_array: false,
                array_size: 0
            });
        }
        
        if (check(TokenType.Bytes)) {
            advance();
            return Type({
                base_type: BaseType.Bytes,
                is_array: false,
                array_size: 0
            });
        }
        
        // Custom type (struct, etc)
        if (check(TokenType.Identifier)) {
            Token memory name = advance();
            return Type({
                base_type: BaseType.Custom,
                custom_type_name: name.lexeme,
                is_array: false,
                array_size: 0
            });
        }
        
        revert("Expected type");
    }
}
/**
 * OMEGA Code Quality CLI
 * Command line interface untuk code quality analysis
 */

import "std/io";
import "std/fs";
import "std/string";
import "std/process";
import "std/env";
import "./omega_code_quality_analyzer.mega";
import "../error/error.mega";

blockchain OmegaCodeQualityCLI {
    state {
        OmegaCodeQualityAnalyzer analyzer;
        CodeQualityCLIConfig config;
    }
    
    constructor() {
        analyzer = new OmegaCodeQualityAnalyzer();
        config = CodeQualityCLIConfig({
            verbose: false,
            output_format: "text",
            auto_fix: false,
            recursive_scan: false,
            quality_threshold: 700, // 700/1000 minimum quality score
            output_file: "",
            show_all_issues: false,
            fail_on_critical: true
        });
    }
    
    /**
     * Main entry point untuk code quality CLI
     */
    function main(string[] args) public {
        if (args.length == 0) {
            print_help();
            return;
        }
        
        string command = args[0];
        
        if (command == "analyze") {
            handle_analyze_command(args);
        } else if (command == "fix") {
            handle_fix_command(args);
        } else if (command == "report") {
            handle_report_command(args);
        } else if (command == "benchmark") {
            handle_benchmark_command(args);
        } else if (command == "help" || command == "--help" || command == "-h") {
            print_help();
        } else if (command == "version" || command == "--version" || command == "-v") {
            print_version();
        } else {
            io::println(format("Error: Unknown command '{}'", command));
            io::println("Use 'omega quality help' for usage information.");
            process::exit(1);
        }
    }
    
    /**
     * Handle analyze command
     */
    function handle_analyze_command(string[] args) private {
        parse_analyze_options(args);
        
        if (args.length < 2) {
            io::println("Error: analyze command requires a file or directory path");
            io::println("Usage: omega quality analyze <file|directory> [options]");
            process::exit(1);
        }
        
        string target_path = args[1];
        
        io::println(format("üîç Starting code quality analysis of '{}'...", target_path));
        
        if (fs::is_file(target_path)) {
            analyze_single_file(target_path);
        } else if (fs::is_directory(target_path)) {
            analyze_directory(target_path);
        } else {
            io::println(format("Error: '{}' is not a valid file or directory", target_path));
            process::exit(1);
        }
    }
    
    /**
     * Handle fix command
     */
    function handle_fix_command(string[] args) private {
        parse_fix_options(args);
        
        if (args.length < 2) {
            io::println("Error: fix command requires a file path");
            io::println("Usage: omega quality fix <file> [options]");
            process::exit(1);
        }
        
        string target_file = args[1];
        
        io::println(format("üîß Starting code quality fixes for '{}'...", target_file));
        
        // Analisis file untuk menemukan issues
        CodeQualityReport memory report = analyzer.analyze_file(target_file);
        
        if (report.total_issues == 0) {
            io::println("‚úÖ No quality issues found. No fixes needed.");
            return;
        }
        
        io::println(format("Found {} quality issues. Applying fixes...", report.total_issues));
        
        // Terapkan perbaikan
        FixResult memory fix_result = apply_quality_fixes(target_file, report);
        
        if (fix_result.success) {
            io::println(format("‚úÖ Successfully applied {} fixes", fix_result.fixes_applied));
            io::println(format("üìÅ Backup saved to: {}", fix_result.backup_path));
            io::println(format("üìä Quality score improved from {} to {}", 
                               fix_result.original_score, fix_result.new_score));
        } else {
            io::println(format("‚ùå Fix failed: {}", fix_result.error_message));
            process::exit(1);
        }
    }
    
    /**
     * Handle report command
     */
    function handle_report_command(string[] args) private {
        if (args.length < 2) {
            io::println("Error: report command requires a quality report file");
            io::println("Usage: omega quality report <quality-report.json> [options]");
            process::exit(1);
        }
        
        string report_file = args[1];
        
        io::println(format("üìä Generating quality report from '{}'...", report_file));
        
        // Baca hasil analisis dari file
        string memory report_data = fs::read_file(report_file);
        CodeQualityReport memory report = parse_quality_report(report_data);
        
        // Generate laporan yang lebih detail
        generate_detailed_quality_report(report);
    }
    
    /**
     * Handle benchmark command
     */
    function handle_benchmark_command(string[] args) private {
        parse_benchmark_options(args);
        
        io::println("üèÉ Starting code quality benchmark...");
        
        // Jalankan benchmark terhadap berbagai contoh kode
        run_quality_benchmarks();
    }
    
    /**
     * Analyze single file
     */
    function analyze_single_file(string file_path) private {
        io::println(format("Analyzing file: {}", file_path));
        
        CodeQualityReport memory report = analyzer.analyze_file(file_path);
        
        print_quality_report(report);
        
        if (config.auto_fix && report.total_issues > 0) {
            io::println("\nüîÑ Auto-fix enabled. Applying fixes...");
            FixResult memory fix_result = apply_quality_fixes(file_path, report);
            
            if (fix_result.success) {
                io::println(format("‚úÖ Applied {} fixes automatically", fix_result.fixes_applied));
            } else {
                io::println(format("‚ùå Auto-fix failed: {}", fix_result.error_message));
            }
        }
        
        // Exit dengan code error jika quality score terlalu rendah
        if (report.quality_score < config.quality_threshold) {
            io::println(format("‚ùå Quality score {} is below threshold {}", report.quality_score, config.quality_threshold));
            if (config.fail_on_critical) {
                process::exit(1);
            }
        }
    }
    
    /**
     * Analyze directory
     */
    function analyze_directory(string dir_path) private {
        io::println(format("Analyzing directory: {}", dir_path));
        
        string[] memory omega_files = find_omega_files(dir_path);
        
        if (omega_files.length == 0) {
            io::println("No OMEGA files found to analyze");
            return;
        }
        
        io::println(format("Found {} OMEGA files to analyze", omega_files.length));
        
        uint256 total_issues = 0;
        uint256 total_files_analyzed = 0;
        uint256 min_quality_score = type(uint256).max;
        uint256 max_quality_score = 0;
        uint256 total_quality_score = 0;
        
        for (uint256 i = 0; i < omega_files.length; i++) {
            io::println(format("\n[{}/{}] Analyzing: {}", i + 1, omega_files.length, omega_files[i]));
            
            CodeQualityReport memory report = analyzer.analyze_file(omega_files[i]);
            
            if (config.verbose) {
                print_quality_report(report);
            } else {
                print_quality_summary(report);
            }
            
            total_issues += report.total_issues;
            total_files_analyzed++;
            min_quality_score = report.quality_score < min_quality_score ? report.quality_score : min_quality_score;
            max_quality_score = report.quality_score > max_quality_score ? report.quality_score : max_quality_score;
            total_quality_score += report.quality_score;
        }
        
        // Print summary
        uint256 avg_quality_score = total_files_analyzed > 0 ? total_quality_score / total_files_analyzed : 0;
        
        io::println("\n" + "=".repeat(60));
        io::println("üìä CODE QUALITY ANALYSIS SUMMARY");
        io::println("=".repeat(60));
        io::println(format("Files analyzed: {}", total_files_analyzed));
        io::println(format("Total issues found: {}", total_issues));
        io::println(format("Average quality score: {}/1000", avg_quality_score));
        io::println(format("Min quality score: {}/1000", min_quality_score));
        io::println(format("Max quality score: {}/1000", max_quality_score));
        io::println(format("Quality threshold: {}/1000", config.quality_threshold));
        
        if (total_issues == 0) {
            io::println("‚úÖ No quality issues found in any files!");
        } else if (avg_quality_score >= config.quality_threshold) {
            io::println("‚ö†Ô∏è  Issues found but overall quality meets threshold");
        } else {
            io::println("‚ùå Overall quality score is below threshold - review required!");
            if (config.fail_on_critical) {
                process::exit(1);
            }
        }
    }
    
    /**
     * Apply quality fixes
     */
    function apply_quality_fixes(string file_path, CodeQualityReport memory report) private returns (FixResult memory) {
        FixResult memory result;
        result.original_score = report.quality_score;
        
        try {
            // Backup file asli
            string memory backup_path = file_path + ".backup";
            fs::copy_file(file_path, backup_path);
            result.backup_path = backup_path;
            
            // Baca konten file
            string memory content = fs::read_file(file_path);
            string memory fixed_content = content;
            
            uint256 fixes_applied = 0;
            
            // Terapkan perbaikan untuk setiap jenis issue
            fixes_applied += fix_naming_issues(fixed_content, report.naming_issues);
            fixes_applied += fix_style_issues(fixed_content, report.style_issues);
            fixes_applied += fix_documentation_issues(fixed_content, report.documentation_issues);
            fixes_applied += fix_length_issues(fixed_content, report.length_issues);
            
            // Tulis kembali file dengan perbaikan
            fs::write_file(file_path, fixed_content);
            
            // Analisis ulang untuk mendapatkan score baru
            CodeQualityReport memory new_report = analyzer.analyze_file(file_path);
            result.new_score = new_report.quality_score;
            result.fixes_applied = fixes_applied;
            result.success = true;
            
        } catch (string memory error) {
            result.success = false;
            result.error_message = error;
        }
        
        return result;
    }
    
    /**
     * Run quality benchmarks
     */
    function run_quality_benchmarks() private {
        io::println("Running quality benchmarks...");
        
        // Test case 1: Perfect quality code
        string memory perfect_code = """
/**
 * Perfect Quality Contract
 * This contract demonstrates perfect code quality
 */
blockchain PerfectContract {
    state {
        address owner;
        uint256 total_supply;
    }
    
    constructor() {
        owner = msg.sender;
        total_supply = 0;
    }
    
    /// @notice Mint new tokens
    /// @param amount The amount of tokens to mint
    function mint(uint256 amount) public {
        require(msg.sender == owner, "Not owner");
        require(amount > 0, "Zero amount");
        
        total_supply += amount;
    }
    
    /// @notice Get the total supply
    /// @return The total token supply
    function get_total_supply() public view returns (uint256) {
        return total_supply;
    }
}
""";
        
        // Test case 2: Poor quality code
        string memory poor_code = """
blockchain badContract {
    state {
        address owner;
        mapping(address => uint256) balances;
        string very_long_variable_name_that_exceeds_recommended_length;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function veryLongFunctionNameThatDoesTooManyThingsAndHasPoorStructure(uint256 amount, address recipient, string memory data, bool flag1, bool flag2, bool flag3) public {
        if (amount > 0) {
            if (recipient != address(0)) {
                if (flag1) {
                    if (flag2) {
                        if (flag3) {
                            balances[recipient] = balances[recipient] + amount + 1000 + 2000 + 3000;
                        }
                    }
                }
            }
        }
    }
}
""";
        
        io::println("\nüìä Benchmark Results:");
        io::println("-".repeat(40));
        
        // Analyze perfect code
        CodeQualityReport memory perfect_report = analyzer.analyze_code(perfect_code, "perfect.mega");
        io::println(format("Perfect Code Score: {}/1000", perfect_report.quality_score));
        io::println(format("Issues Found: {}", perfect_report.total_issues));
        
        // Analyze poor code
        CodeQualityReport memory poor_report = analyzer.analyze_code(poor_code, "poor.mega");
        io::println(format("Poor Code Score: {}/1000", poor_report.quality_score));
        io::println(format("Issues Found: {}", poor_report.total_issues));
        
        io::println("\n‚úÖ Benchmark completed successfully!");
    }
    
    /**
     * Find OMEGA files in directory
     */
    function find_omega_files(string dir_path) private returns (string[] memory) {
        string[] memory files;
        uint256 file_count = 0;
        
        // Cari file dengan ekstensi .mega dan .omega
        string[] memory all_files = fs::list_files(dir_path, config.recursive_scan);
        
        for (uint256 i = 0; i < all_files.length; i++) {
            string memory file = all_files[i];
            if (file.ends_with(".mega") || file.ends_with(".omega")) {
                files[file_count] = file;
                file_count++;
            }
        }
        
        return files;
    }
    
    /**
     * Print quality report
     */
    function print_quality_report(CodeQualityReport memory report) private {
        if (config.output_format == "json") {
            print_json_report(report);
            return;
        }
        
        io::println("\n" + "=".repeat(60));
        io::println("üìä CODE QUALITY REPORT");
        io::println("=".repeat(60));
        io::println(format("File: {}", report.file_path));
        io::println(format("Analysis Time: {}", secure_timestamp::format(report.timestamp)));
        io::println(format("Quality Score: {}/1000", report.quality_score));
        io::println(format("Total Issues: {}", report.total_issues));
        
        if (report.parse_errors.length > 0) {
            io::println("\n‚ùå PARSE ERRORS:");
            io::println("-".repeat(40));
            for (uint256 i = 0; i < report.parse_errors.length; i++) {
                io::println(format("  Line {}: {}", report.parse_errors[i].line, report.parse_errors[i].message));
            }
            return;
        }
        
        if (report.total_issues == 0) {
            io::println("\n‚úÖ No quality issues found!");
            return;
        }
        
        io::println("\nüìã ISSUE BREAKDOWN:");
        io::println("-".repeat(40));
        
        if (report.complexity_issues.length > 0) {
            io::println(format("üî¥ Complexity Issues: {}", report.complexity_issues.length));
            if (config.show_all_issues) {
                for (uint256 i = 0; i < report.complexity_issues.length; i++) {
                    io::println(format("  - {}: complexity score {} (max: {})", 
                                      report.complexity_issues[i].function_name,
                                      report.complexity_issues[i].complexity_score,
                                      report.complexity_issues[i].max_allowed));
                }
            }
        }
        
        if (report.length_issues.length > 0) {
            io::println(format("üü° Length Issues: {}", report.length_issues.length));
            if (config.show_all_issues) {
                for (uint256 i = 0; i < report.length_issues.length; i++) {
                    io::println(format("  - Line {}: {}", 
                                      report.length_issues[i].line_number,
                                      report.length_issues[i].description));
                }
            }
        }
        
        if (report.naming_issues.length > 0) {
            io::println(format("üü° Naming Issues: {}", report.naming_issues.length));
            if (config.show_all_issues) {
                for (uint256 i = 0; i < report.naming_issues.length; i++) {
                    io::println(format("  - Line {}: {} '{}' should be '{}'", 
                                      report.naming_issues[i].line_number,
                                      naming_type_to_string(report.naming_issues[i].identifier_type),
                                      report.naming_issues[i].identifier_name,
                                      report.naming_issues[i].recommendation));
                }
            }
        }
        
        if (report.documentation_issues.length > 0) {
            io::println(format("üü¢ Documentation Issues: {}", report.documentation_issues.length));
        }
        
        if (report.style_issues.length > 0) {
            io::println(format("üü¢ Style Issues: {}", report.style_issues.length));
        }
        
        if (report.security_issues.length > 0) {
            io::println(format("üî¥ Security Issues: {}", report.security_issues.length));
        }
        
        if (report.performance_issues.length > 0) {
            io::println(format("üü° Performance Issues: {}", report.performance_issues.length));
        }
        
        if (report.maintainability_issues.length > 0) {
            io::println(format("üü° Maintainability Issues: {}", report.maintainability_issues.length));
        }
        
        if (report.recommendations.length > 0) {
            io::println("\nüí° RECOMMENDATIONS:");
            io::println("-".repeat(40));
            for (uint256 i = 0; i < report.recommendations.length; i++) {
                io::println(format("  {}. {}", i + 1, report.recommendations[i]));
            }
        }
        
        // Quality score interpretation
        io::println("\nüìà QUALITY SCORE INTERPRETATION:");
        if (report.quality_score >= 900) {
            io::println("  üèÜ Excellent (900-1000) - Production ready code");
        } else if (report.quality_score >= 700) {
            io::println("  ‚úÖ Good (700-899) - Acceptable quality");
        } else if (report.quality_score >= 500) {
            io::println("  ‚ö†Ô∏è  Fair (500-699) - Needs improvement");
        } else {
            io::println("  ‚ùå Poor (0-499) - Requires significant refactoring");
        }
    }
    
    /**
     * Print quality summary
     */
    function print_quality_summary(CodeQualityReport memory report) private {
        string memory status_icon = report.quality_score >= config.quality_threshold ? "‚úÖ" : "‚ùå";
        string memory quality_level = get_quality_level(report.quality_score);
        
        io::println(format("{} {} - Score: {}/1000 ({}), Issues: {}", 
                          status_icon, report.file_path, report.quality_score, 
                          quality_level, report.total_issues));
    }
    
    /**
     * Generate detailed quality report
     */
    function generate_detailed_quality_report(CodeQualityReport memory report) private {
        string memory report_content = format("""
# OMEGA Code Quality Report

**Generated:** {}
**File:** {}
**Quality Score:** {}/1000
**Total Issues:** {}

## Executive Summary

This code quality analysis identified {} issues in the OMEGA smart contract.
The overall quality score is {} out of 1000.

## Issue Breakdown

- **Complexity Issues:** {}
- **Length Issues:** {}
- **Naming Issues:** {}
- **Documentation Issues:** {}
- **Style Issues:** {}
- **Security Issues:** {}
- **Performance Issues:** {}
- **Maintainability Issues:** {}

## Detailed Issues

""", secure_timestamp::format(report.timestamp), report.file_path, report.quality_score, 
        report.total_issues, report.total_issues, report.quality_score,
        report.complexity_issues.length, report.length_issues.length, report.naming_issues.length,
        report.documentation_issues.length, report.style_issues.length, report.security_issues.length,
        report.performance_issues.length, report.maintainability_issues.length);
        
        // Tambahkan detail issues
        if (report.complexity_issues.length > 0) {
            report_content += "\n### Complexity Issues\n\n";
            for (uint256 i = 0; i < report.complexity_issues.length; i++) {
                ComplexityIssue memory issue = report.complexity_issues[i];
                report_content += format("- **{}**: Cyclomatic complexity {} (max: {})\n  - Recommendation: {}\n\n", 
                                       issue.function_name, issue.complexity_score, issue.max_allowed, issue.recommendation);
            }
        }
        
        if (report.naming_issues.length > 0) {
            report_content += "\n### Naming Issues\n\n";
            for (uint256 i = 0; i < report.naming_issues.length; i++) {
                NamingIssue memory issue = report.naming_issues[i];
                report_content += format("- **Line {}**: {} '{}' should follow {} convention\n  - Suggestion: {}\n\n", 
                                       issue.line_number, naming_type_to_string(issue.identifier_type), 
                                       issue.identifier_name, issue.expected_pattern, issue.recommendation);
            }
        }
        
        // Tambahkan rekomendasi
        if (report.recommendations.length > 0) {
            report_content += "\n## Recommendations\n\n";
            for (uint256 i = 0; i < report.recommendations.length; i++) {
                report_content += format("{}. {}\n", i + 1, report.recommendations[i]);
            }
        }
        
        // Simpan laporan
        string memory report_file = "quality-report.md";
        if (bytes(config.output_file).length > 0) {
            report_file = config.output_file;
        }
        
        fs::write_file(report_file, report_content);
        io::println(format("üìÑ Quality report generated: {}", report_file));
    }
    
    /**
     * Apply quality fixes
     */
    function fix_naming_issues(string content, NamingIssue[] issues) private pure returns (uint256) {
        uint256 fixes_applied = 0;
        // Implementasi perbaikan naming conventions
        return fixes_applied;
    }
    
    function fix_style_issues(string content, StyleIssue[] issues) private pure returns (uint256) {
        uint256 fixes_applied = 0;
        // Implementasi perbaikan style issues
        return fixes_applied;
    }
    
    function fix_documentation_issues(string content, DocumentationIssue[] issues) private pure returns (uint256) {
        uint256 fixes_applied = 0;
        // Implementasi perbaikan documentation
        return fixes_applied;
    }
    
    function fix_length_issues(string content, LengthIssue[] issues) private pure returns (uint256) {
        uint256 fixes_applied = 0;
        // Implementasi perbaikan length issues
        return fixes_applied;
    }
    
    /**
     * Parse command options
     */
    function parse_analyze_options(string[] args) private {
        for (uint256 i = 2; i < args.length; i++) {
            string memory arg = args[i];
            
            if (arg == "--verbose" || arg == "-v") {
                config.verbose = true;
            } else if (arg == "--json" || arg == "-j") {
                config.output_format = "json";
            } else if (arg == "--recursive" || arg == "-r") {
                config.recursive_scan = true;
            } else if (arg == "--auto-fix" || arg == "-a") {
                config.auto_fix = true;
            } else if (arg == "--threshold" || arg == "-t") {
                if (i + 1 < args.length) {
                    config.quality_threshold = string::parse_uint(args[i + 1]);
                    i++;
                }
            } else if (arg == "--output" || arg == "-o") {
                if (i + 1 < args.length) {
                    config.output_file = args[i + 1];
                    i++;
                }
            } else if (arg == "--all-issues") {
                config.show_all_issues = true;
            } else if (arg == "--no-fail") {
                config.fail_on_critical = false;
            }
        }
    }
    
    function parse_fix_options(string[] args) private {
        for (uint256 i = 2; i < args.length; i++) {
            string memory arg = args[i];
            
            if (arg == "--dry-run") {
                // Implement dry run mode
            } else if (arg == "--backup-only") {
                // Implement backup only mode
            }
        }
    }
    
    function parse_benchmark_options(string[] args) private {
        for (uint256 i = 1; i < args.length; i++) {
            string memory arg = args[i];
            
            if (arg == "--verbose" || arg == "-v") {
                config.verbose = true;
            }
        }
    }
    
    /**
     * Helper functions
     */
    
    function parse_quality_report(string memory report_data) private pure returns (CodeQualityReport memory) {
        // Implementasi parsing quality report dari JSON
        CodeQualityReport memory report;
        report.file_path = "parsed_from_json";
        report.quality_score = 750;
        report.total_issues = 0;
        report.timestamp = secure_timestamp::now();
        return report;
    }
    
    function get_quality_level(uint256 score) private pure returns (string memory) {
        if (score >= 900) return "Excellent";
        if (score >= 700) return "Good";
        if (score >= 500) return "Fair";
        return "Poor";
    }
    
    function naming_type_to_string(NamingType naming_type) private pure returns (string memory) {
        if (naming_type == NamingType.Function) return "Function";
        if (naming_type == NamingType.Variable) return "Variable";
        if (naming_type == NamingType.Contract) return "Contract";
        if (naming_type == NamingType.Event) return "Event";
        if (naming_type == NamingType.Modifier) return "Modifier";
        return "Unknown";
    }
    
    function print_json_report(CodeQualityReport memory report) private {
        io::println("{\"quality_report\": \"JSON output not fully implemented\"}");
    }
    
    function print_help() private {
        io::println("""
üîç OMEGA Code Quality Analyzer

USAGE:
    omega quality <command> [options]

COMMANDS:
    analyze <file|dir>  Analyze OMEGA files for code quality issues
    fix <file>          Apply automatic fixes for quality issues
    report <file>       Generate detailed quality report
    benchmark           Run quality benchmarks
    help                Show this help message
    version             Show version information

ANALYZE OPTIONS:
    --verbose, -v       Enable verbose output
    --json, -j          Output results in JSON format
    --recursive, -r     Analyze directories recursively
    --auto-fix, -a      Automatically apply fixes for issues
    --threshold, -t     Set quality score threshold (default: 700)
    --output, -o        Save results to file
    --all-issues        Show all individual issues
    --no-fail           Don't fail on low quality scores

EXAMPLES:
    omega quality analyze contracts/
    omega quality analyze contract.mega --verbose --json
    omega quality fix problematic.mega
    omega quality benchmark --verbose
    omega quality report quality-report.json

QUALITY SCORE SCALE:
    900-1000: Excellent - Production ready
    700-899:  Good - Acceptable quality
    500-699:  Fair - Needs improvement
    0-499:    Poor - Requires refactoring

For more information, visit: https://omega-lang.org/quality
""");
    }
    
    function print_version() private {
        io::println("OMEGA Code Quality Analyzer v1.2.0");
        io::println("Built with OMEGA Universal Blockchain Language");
        io::println("Quality analysis powered by native OMEGA engine");
    }
}

// Configuration untuk CLI
struct CodeQualityCLIConfig {
    bool verbose;
    string output_format;
    bool auto_fix;
    bool recursive_scan;
    uint256 quality_threshold;
    string output_file;
    bool show_all_issues;
    bool fail_on_critical;
}

// Hasil perbaikan
struct FixResult {
    bool success;
    string error_message;
    uint256 fixes_applied;
    uint256 original_score;
    uint256 new_score;
    string backup_path;
}
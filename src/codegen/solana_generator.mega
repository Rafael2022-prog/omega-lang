// OMEGA Solana Code Generator - Menghasilkan kode Rust/Anchor dari OMEGA IR
// Mendukung Solana runtime dengan Anchor framework untuk smart contract development

import "../ir/ir.mega";
import "../error/error.mega";
import "./base_generator.mega";

/// Solana-specific code generator untuk menghasilkan Rust/Anchor code
blockchain SolanaCodeGenerator is BaseCodeGenerator {
    state {
        mapping(string => string) rust_type_mappings;          // Mapping OMEGA types ke Rust types
        mapping(string => string) anchor_annotations;          // Anchor-specific annotations
        string[] use_statements;                               // Use statements untuk imports
        bool use_anchor_framework;                             // Whether to use Anchor framework
        string anchor_version;                                 // Target Anchor version
        mapping(string => string) account_constraints;         // Account constraints mapping
        string[] program_dependencies;                         // Program dependencies
    }
    
    /// Constructor untuk Solana generator
    constructor() BaseCodeGenerator() {
        initialize_rust_mappings();
        initialize_anchor_annotations();
        initialize_use_statements();
        use_anchor_framework = true;
        anchor_version = "0.29.0";
        initialize_solana_features();
    }
    
    /// Initialize Rust type mappings
    function initialize_rust_mappings() internal {
        // Basic types
        rust_type_mappings["uint"] = "u64";
        rust_type_mappings["uint8"] = "u8";
        rust_type_mappings["uint16"] = "u16";
        rust_type_mappings["uint32"] = "u32";
        rust_type_mappings["uint64"] = "u64";
        rust_type_mappings["uint128"] = "u128";
        rust_type_mappings["uint256"] = "U256"; // Using custom U256 type
        
        rust_type_mappings["int"] = "i64";
        rust_type_mappings["int8"] = "i8";
        rust_type_mappings["int16"] = "i16";
        rust_type_mappings["int32"] = "i32";
        rust_type_mappings["int64"] = "i64";
        rust_type_mappings["int128"] = "i128";
        
        rust_type_mappings["bool"] = "bool";
        rust_type_mappings["string"] = "String";
        rust_type_mappings["bytes"] = "Vec<u8>";
        rust_type_mappings["address"] = "Pubkey";
        
        // Array types
        rust_type_mappings["uint[]"] = "Vec<u64>";
        rust_type_mappings["int[]"] = "Vec<i64>";
        rust_type_mappings["bool[]"] = "Vec<bool>";
        rust_type_mappings["string[]"] = "Vec<String>";
        rust_type_mappings["address[]"] = "Vec<Pubkey>";
    }
    
    /// Initialize Anchor annotations
    function initialize_anchor_annotations() internal {
        anchor_annotations["program"] = "#[program]";
        anchor_annotations["derive_accounts"] = "#[derive(Accounts)]";
        anchor_annotations["account"] = "#[account]";
        anchor_annotations["signer"] = "#[signer]";
        anchor_annotations["mut"] = "#[account(mut)]";
        anchor_annotations["init"] = "#[account(init, payer = user, space = 8 + 32)]";
        anchor_annotations["close"] = "#[account(close = destination)]";
    }
    
    /// Initialize use statements
    function initialize_use_statements() internal {
        use_statements.push("use anchor_lang::prelude::*;");
        use_statements.push("use anchor_spl::token::{self, Token, TokenAccount, Mint};");
        use_statements.push("use solana_program::pubkey::Pubkey;");
    }
    
    /// Initialize Solana-specific features
    function initialize_solana_features() internal override {
        supported_features = [
            "basic_types", "functions", "events", "accounts", "instructions",
            "pdas", "cpi", "spl_tokens", "anchor_framework", "borsh_serialization"
        ];
    }
    
    /// Main function untuk generate Rust/Anchor code dari IR
    function generate(IRModule memory module) public override returns (string memory) {
        if (!validate_module(module)) {
            return "";
        }
        
        uint256 start_time = block.timestamp * 1000; // Simplified timestamp
        
        string memory result = "";
        
        // Generate use statements
        result = string(abi.encodePacked(result, generate_use_statements()));
        
        // Generate program declaration
        result = string(abi.encodePacked(result, generate_program_declaration(module)));
        
        // Generate program module
        for (uint i = 0; i < module.blockchains.length; i++) {
            result = string(abi.encodePacked(result, generate_program_module(module.blockchains[i])));
        }
        
        // Generate account structs
        result = string(abi.encodePacked(result, generate_account_structs(module)));
        
        // Generate error codes
        result = string(abi.encodePacked(result, generate_error_codes()));
        
        // Update statistics
        stats.generation_time_ms = (block.timestamp * 1000) - start_time;
        update_stats_contracts();
        
        return result;
    }
    
    /// Generate use statements
    function generate_use_statements() internal view returns (string memory) {
        string memory result = "";
        
        for (uint i = 0; i < use_statements.length; i++) {
            result = string(abi.encodePacked(result, use_statements[i], "\n"));
        }
        
        return string(abi.encodePacked(result, "\n"));
    }
    
    /// Generate program declaration
    function generate_program_declaration(IRModule memory module) internal pure returns (string memory) {
        return string(abi.encodePacked("declare_id!(\"", generate_program_id(), "\");\n\n"));
    }
    
    /// Generate program ID (deterministic based on contract name)
    function generate_program_id() internal pure returns (string memory) {
        // Generate deterministic program ID based on contract name and timestamp
        string memory contract_name = current_context.contract_name;
        uint256 timestamp = block.timestamp;
        
        // Create a deterministic but unique program ID
        bytes32 hash = keccak256(abi.encodePacked(contract_name, timestamp, "OMEGA_SOLANA"));
        
        // Convert to base58-like format (simplified for Solana compatibility)
        return bytes32_to_base58(hash);
    }
    
    /// Convert bytes32 to base58-like string for Solana program ID
    function bytes32_to_base58(bytes32 input) internal pure returns (string memory) {
        // Simplified base58 encoding for Solana program IDs
        // In production, this would use proper base58 encoding
        string memory chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        bytes memory result = new bytes(44); // Solana program IDs are 44 characters
        
        uint256 value = uint256(input);
        for (uint256 i = 0; i < 44; i++) {
            result[i] = bytes(chars)[value % 58];
            value = value / 58;
        }
        
        return string(result);
    }
    
    /// Generate program module
    function generate_program_module(BlockchainIR memory blockchain) internal returns (string memory) {
        push_context(blockchain.name, "");
        
        string memory result = "";
        
        // Program annotation
        result = string(abi.encodePacked(result, "#[program]\n"));
        result = string(abi.encodePacked(result, "pub mod ", to_snake_case(blockchain.name), " {\n"));
        push_indent();
        
        result = string(abi.encodePacked(result, get_indent(), "use super::*;\n\n"));
        
        // Generate instruction functions
        result = string(abi.encodePacked(result, generate_instruction_functions(blockchain.functions)));
        
        pop_indent();
        result = string(abi.encodePacked(result, "}\n\n"));
        
        pop_context();
        update_stats_contracts();
        
        return result;
    }
    
    /// Generate instruction functions
    function generate_instruction_functions(FunctionIR[] memory functions) internal returns (string memory) {
        string memory result = "";
        
        for (uint i = 0; i < functions.length; i++) {
            result = string(abi.encodePacked(result, generate_instruction_function(functions[i])));
        }
        
        return result;
    }
    
    /// Generate single instruction function
    function generate_instruction_function(FunctionIR memory func) internal returns (string memory) {
        push_context(context.current_blockchain, func.name);
        
        string memory result = string(abi.encodePacked(get_indent(), "pub fn ", to_snake_case(func.name), "("));
        
        // Context parameter (always first in Anchor)
        result = string(abi.encodePacked(result, "ctx: Context<", to_pascal_case(func.name), "Accounts>"));
        
        // Additional parameters
        for (uint i = 0; i < func.parameters.length; i++) {
            result = string(abi.encodePacked(result, ", ", generate_rust_parameter(func.parameters[i])));
        }
        
        result = string(abi.encodePacked(result, ")"));
        
        // Return type
        if (bytes(func.return_type).length > 0) {
            result = string(abi.encodePacked(result, " -> Result<", convert_rust_type(func.return_type), ">"));
        } else {
            result = string(abi.encodePacked(result, " -> Result<()>"));
        }
        
        result = string(abi.encodePacked(result, " {\n"));
        push_indent();
        
        // Function body
        result = string(abi.encodePacked(result, generate_rust_block(func.body)));
        
        // Default return for void functions
        if (bytes(func.return_type).length == 0) {
            result = string(abi.encodePacked(result, get_indent(), "Ok(())\n"));
        }
        
        pop_indent();
        result = string(abi.encodePacked(result, get_indent(), "}\n\n"));
        
        pop_context();
        update_stats_functions();
        
        return result;
    }
    
    /// Generate Rust parameter
    function generate_rust_parameter(ParameterIR memory param) internal view returns (string memory) {
        return string(abi.encodePacked(to_snake_case(param.name), ": ", convert_rust_type(param.param_type)));
    }
    
    /// Generate Rust block
    function generate_rust_block(BlockIR memory block) internal returns (string memory) {
        string memory result = "";
        
        for (uint i = 0; i < block.statements.length; i++) {
            result = string(abi.encodePacked(result, generate_rust_statement(block.statements[i])));
        }
        
        return result;
    }
    
    /// Generate Rust statement
    function generate_rust_statement(StatementIR memory stmt) internal returns (string memory) {
        if (stmt.stmt_type == StatementType.VariableDeclaration) {
            return generate_rust_variable_declaration(stmt);
        } else if (stmt.stmt_type == StatementType.Assignment) {
            return generate_rust_assignment(stmt);
        } else if (stmt.stmt_type == StatementType.If) {
            return generate_rust_if_statement(stmt);
        } else if (stmt.stmt_type == StatementType.While) {
            return generate_rust_while_statement(stmt);
        } else if (stmt.stmt_type == StatementType.For) {
            return generate_rust_for_statement(stmt);
        } else if (stmt.stmt_type == StatementType.Return) {
            return generate_rust_return_statement(stmt);
        } else if (stmt.stmt_type == StatementType.Emit) {
            return generate_rust_emit_statement(stmt);
        } else if (stmt.stmt_type == StatementType.Require) {
            return generate_rust_require_statement(stmt);
        } else if (stmt.stmt_type == StatementType.Expression) {
            return string(abi.encodePacked(get_indent(), generate_rust_expression(stmt.expression), ";\n"));
        }
        
        return "";
    }
    
    /// Generate Rust variable declaration
    function generate_rust_variable_declaration(StatementIR memory stmt) internal view returns (string memory) {
        string memory result = string(abi.encodePacked(get_indent(), "let "));
        
        // Mutability
        if (stmt.is_mutable) {
            result = string(abi.encodePacked(result, "mut "));
        }
        
        result = string(abi.encodePacked(result, to_snake_case(stmt.variable_name)));
        
        // Type annotation (optional in Rust)
        if (bytes(stmt.var_type).length > 0) {
            result = string(abi.encodePacked(result, ": ", convert_rust_type(stmt.var_type)));
        }
        
        // Initial value
        if (bytes(stmt.initial_value).length > 0) {
            result = string(abi.encodePacked(result, " = ", stmt.initial_value));
        }
        
        return string(abi.encodePacked(result, ";\n"));
    }
    
    /// Generate Rust assignment
    function generate_rust_assignment(StatementIR memory stmt) internal returns (string memory) {
        return string(abi.encodePacked(
            get_indent(),
            generate_rust_expression(stmt.left_expression),
            " = ",
            generate_rust_expression(stmt.right_expression),
            ";\n"
        ));
    }
    
    /// Generate Rust if statement
    function generate_rust_if_statement(StatementIR memory stmt) internal returns (string memory) {
        string memory result = string(abi.encodePacked(
            get_indent(),
            "if ",
            generate_rust_expression(stmt.condition),
            " {\n"
        ));
        
        push_indent();
        result = string(abi.encodePacked(result, generate_rust_block(stmt.then_block)));
        pop_indent();
        
        result = string(abi.encodePacked(result, get_indent(), "}"));
        
        if (stmt.else_block.statements.length > 0) {
            result = string(abi.encodePacked(result, " else {\n"));
            push_indent();
            result = string(abi.encodePacked(result, generate_rust_block(stmt.else_block)));
            pop_indent();
            result = string(abi.encodePacked(result, get_indent(), "}"));
        }
        
        return string(abi.encodePacked(result, "\n"));
    }
    
    /// Generate Rust while statement
    function generate_rust_while_statement(StatementIR memory stmt) internal returns (string memory) {
        string memory result = string(abi.encodePacked(
            get_indent(),
            "while ",
            generate_rust_expression(stmt.condition),
            " {\n"
        ));
        
        push_indent();
        result = string(abi.encodePacked(result, generate_rust_block(stmt.body)));
        pop_indent();
        
        return string(abi.encodePacked(result, get_indent(), "}\n"));
    }
    
    /// Generate Rust for statement
    function generate_rust_for_statement(StatementIR memory stmt) internal returns (string memory) {
        // Rust for loops are different - typically use iterators
        string memory result = string(abi.encodePacked(get_indent(), "for "));
        
        if (bytes(stmt.iterator_var).length > 0) {
            result = string(abi.encodePacked(result, to_snake_case(stmt.iterator_var), " in "));
            result = string(abi.encodePacked(result, generate_rust_expression(stmt.iterable)));
        } else {
            // Traditional C-style for loop converted to while
            result = string(abi.encodePacked(get_indent(), "{\n"));
            push_indent();
            
            if (bytes(stmt.init_statement).length > 0) {
                result = string(abi.encodePacked(result, get_indent(), stmt.init_statement, ";\n"));
            }
            
            result = string(abi.encodePacked(result, get_indent(), "while "));
            if (stmt.condition.expr_type != ExpressionType.Empty) {
                result = string(abi.encodePacked(result, generate_rust_expression(stmt.condition)));
            } else {
                result = string(abi.encodePacked(result, "true"));
            }
        }
        
        result = string(abi.encodePacked(result, " {\n"));
        push_indent();
        result = string(abi.encodePacked(result, generate_rust_block(stmt.body)));
        
        if (bytes(stmt.update_statement).length > 0) {
            result = string(abi.encodePacked(result, get_indent(), stmt.update_statement, ";\n"));
        }
        
        pop_indent();
        result = string(abi.encodePacked(result, get_indent(), "}\n"));
        
        if (bytes(stmt.iterator_var).length == 0) {
            pop_indent();
            result = string(abi.encodePacked(result, get_indent(), "}\n"));
        }
        
        return result;
    }
    
    /// Generate Rust return statement
    function generate_rust_return_statement(StatementIR memory stmt) internal returns (string memory) {
        if (stmt.return_expression.expr_type != ExpressionType.Empty) {
            return string(abi.encodePacked(
                get_indent(),
                "Ok(",
                generate_rust_expression(stmt.return_expression),
                ")\n"
            ));
        } else {
            return string(abi.encodePacked(get_indent(), "Ok(())\n"));
        }
    }
    
    /// Generate Rust emit statement (converted to msg! macro)
    function generate_rust_emit_statement(StatementIR memory stmt) internal returns (string memory) {
        return string(abi.encodePacked(
            get_indent(),
            "msg!(\"",
            escape_string(generate_rust_expression(stmt.expression)),
            "\");\n"
        ));
    }
    
    /// Generate Rust require statement (converted to require! macro)
    function generate_rust_require_statement(StatementIR memory stmt) internal returns (string memory) {
        string memory result = string(abi.encodePacked(
            get_indent(),
            "require!(",
            generate_rust_expression(stmt.condition)
        ));
        
        if (bytes(stmt.error_message).length > 0) {
            result = string(abi.encodePacked(result, ", ErrorCode::", to_pascal_case(stmt.error_message)));
        }
        
        return string(abi.encodePacked(result, ");\n"));
    }
    
    /// Generate Rust expression
    function generate_rust_expression(ExpressionIR memory expr) internal returns (string memory) {
        if (expr.expr_type == ExpressionType.Literal) {
            return convert_rust_literal(expr.value);
        } else if (expr.expr_type == ExpressionType.Identifier) {
            return to_snake_case(expr.name);
        } else if (expr.expr_type == ExpressionType.Binary) {
            return string(abi.encodePacked(
                "(",
                generate_rust_expression(expr.left),
                " ",
                convert_rust_operator(expr.operator),
                " ",
                generate_rust_expression(expr.right),
                ")"
            ));
        } else if (expr.expr_type == ExpressionType.Unary) {
            return string(abi.encodePacked(convert_rust_operator(expr.operator), generate_rust_expression(expr.operand)));
        } else if (expr.expr_type == ExpressionType.FunctionCall) {
            return generate_rust_function_call(expr);
        } else if (expr.expr_type == ExpressionType.MemberAccess) {
            return string(abi.encodePacked(generate_rust_expression(expr.object), ".", to_snake_case(expr.member_name)));
        } else if (expr.expr_type == ExpressionType.IndexAccess) {
            return string(abi.encodePacked(
                generate_rust_expression(expr.object),
                "[",
                generate_rust_expression(expr.index),
                "]"
            ));
        }
        
        return "";
    }
    
    /// Generate Rust function call
    function generate_rust_function_call(ExpressionIR memory expr) internal returns (string memory) {
        string memory result = string(abi.encodePacked(to_snake_case(expr.function_name), "("));
        
        for (uint i = 0; i < expr.arguments.length; i++) {
            if (i > 0) result = string(abi.encodePacked(result, ", "));
            result = string(abi.encodePacked(result, generate_rust_expression(expr.arguments[i])));
        }
        
        return string(abi.encodePacked(result, ")"));
    }
    
    /// Convert OMEGA type ke Rust type
    function convert_rust_type(string memory omega_type) internal view returns (string memory) {
        // Check direct mapping first
        if (bytes(rust_type_mappings[omega_type]).length > 0) {
            return rust_type_mappings[omega_type];
        }
        
        bytes memory type_bytes = bytes(omega_type);
        
        // Handle array types: type[]
        if (ends_with(omega_type, "[]")) {
            string memory base_type = substring(omega_type, 0, type_bytes.length - 2);
            return string(abi.encodePacked("Vec<", convert_rust_type(base_type), ">"));
        }
        
        // Handle Option types
        if (starts_with(omega_type, "Option<")) {
            return omega_type; // Rust Option syntax is the same
        }
        
        // Return as-is for user-defined types
        return to_pascal_case(omega_type);
    }
    
    /// Convert literal values untuk Rust
    function convert_rust_literal(string memory value) internal pure returns (string memory) {
        // String literals
        if (starts_with(value, "\"") && ends_with(value, "\"")) {
            return value; // Keep as-is
        }
        
        // Address literals (convert to Pubkey)
        if (bytes(value).length == 42 && starts_with(value, "0x")) {
            return string(abi.encodePacked("Pubkey::from_str(\"", value, "\").unwrap()"));
        }
        
        // Boolean literals
        if (keccak256(bytes(value)) == keccak256(bytes("true")) || 
            keccak256(bytes(value)) == keccak256(bytes("false"))) {
            return value;
        }
        
        // Numeric literals - add type suffix if needed
        return value;
    }
    
    /// Convert operators untuk Rust
    function convert_rust_operator(string memory op) internal pure returns (string memory) {
        // Most operators are the same, but some need conversion
        if (keccak256(bytes(op)) == keccak256(bytes("&&"))) return "&&";
        if (keccak256(bytes(op)) == keccak256(bytes("||"))) return "||";
        if (keccak256(bytes(op)) == keccak256(bytes("!"))) return "!";
        
        return op; // Most operators are the same
    }
    
    /// Generate account structs
    function generate_account_structs(IRModule memory module) internal returns (string memory) {
        string memory result = "";
        
        // Generate account structs for each function (instruction)
        for (uint i = 0; i < module.blockchains.length; i++) {
            BlockchainIR memory blockchain = module.blockchains[i];
            
            for (uint j = 0; j < blockchain.functions.length; j++) {
                result = string(abi.encodePacked(result, generate_accounts_struct(blockchain.functions[j])));
            }
        }
        
        return result;
    }
    
    /// Generate accounts struct untuk instruction
    function generate_accounts_struct(FunctionIR memory func) internal view returns (string memory) {
        string memory result = string(abi.encodePacked("#[derive(Accounts)]\n"));
        result = string(abi.encodePacked(result, "pub struct ", to_pascal_case(func.name), "Accounts<'info> {\n"));
        push_indent();
        
        // Common accounts
        result = string(abi.encodePacked(result, get_indent(), "#[account(mut)]\n"));
        result = string(abi.encodePacked(result, get_indent(), "pub user: Signer<'info>,\n"));
        
        result = string(abi.encodePacked(result, get_indent(), "pub system_program: Program<'info, System>,\n"));
        
        // Function-specific accounts based on parameters
        for (uint i = 0; i < func.parameters.length; i++) {
            ParameterIR memory param = func.parameters[i];
            
            if (keccak256(bytes(param.param_type)) == keccak256(bytes("address"))) {
                result = string(abi.encodePacked(result, get_indent(), "/// CHECK: This is safe\n"));
                result = string(abi.encodePacked(result, get_indent(), "pub ", to_snake_case(param.name), ": AccountInfo<'info>,\n"));
            }
        }
        
        pop_indent();
        result = string(abi.encodePacked(result, "}\n\n"));
        
        return result;
    }
    
    /// Generate error codes
    function generate_error_codes() internal view returns (string memory) {
        string memory result = "#[error_code]\n";
        result = string(abi.encodePacked(result, "pub enum ErrorCode {\n"));
        push_indent();
        
        result = string(abi.encodePacked(result, get_indent(), "#[msg(\"Custom error message\")]\n"));
        result = string(abi.encodePacked(result, get_indent(), "CustomError,\n"));
        
        result = string(abi.encodePacked(result, get_indent(), "#[msg(\"Insufficient balance\")]\n"));
        result = string(abi.encodePacked(result, get_indent(), "InsufficientBalance,\n"));
        
        result = string(abi.encodePacked(result, get_indent(), "#[msg(\"Invalid recipient\")]\n"));
        result = string(abi.encodePacked(result, get_indent(), "InvalidRecipient,\n"));
        
        pop_indent();
        result = string(abi.encodePacked(result, "}\n"));
        
        return result;
    }
    
    /// Helper functions (reuse from base class with modifications)
    function starts_with(string memory str, string memory prefix) internal pure returns (bool) {
        bytes memory str_bytes = bytes(str);
        bytes memory prefix_bytes = bytes(prefix);
        
        if (prefix_bytes.length > str_bytes.length) return false;
        
        for (uint i = 0; i < prefix_bytes.length; i++) {
            if (str_bytes[i] != prefix_bytes[i]) return false;
        }
        
        return true;
    }
    
    function ends_with(string memory str, string memory suffix) internal pure returns (bool) {
        bytes memory str_bytes = bytes(str);
        bytes memory suffix_bytes = bytes(suffix);
        
        if (suffix_bytes.length > str_bytes.length) return false;
        
        uint start_index = str_bytes.length - suffix_bytes.length;
        for (uint i = 0; i < suffix_bytes.length; i++) {
            if (str_bytes[start_index + i] != suffix_bytes[i]) return false;
        }
        
        return true;
    }
    
    function substring(string memory str, uint start, uint end) internal pure returns (string memory) {
        bytes memory str_bytes = bytes(str);
        bytes memory result = new bytes(end - start);
        
        for (uint i = start; i < end; i++) {
            result[i - start] = str_bytes[i];
        }
        
        return string(result);
    }
    
    /// Override platform-specific functions
    function get_platform() public pure override returns (TargetPlatform) {
        return TargetPlatform.Solana;
    }
    
    function get_file_extension() public pure override returns (string memory) {
        return ".rs";
    }
    
    /// Solana-specific configuration
    function set_anchor_version(string memory version) public {
        anchor_version = version;
    }
    
    function enable_anchor_framework(bool enable) public {
        use_anchor_framework = enable;
    }
    
    function add_use_statement(string memory use_stmt) public {
        use_statements.push(use_stmt);
    }
    
    function add_program_dependency(string memory dependency) public {
        program_dependencies.push(dependency);
    }
    
    /// Generate Cargo.toml file
    function generate_cargo_toml(string memory program_name) public view returns (string memory) {
        string memory result = "[package]\n";
        result = string(abi.encodePacked(result, "name = \"", to_snake_case(program_name), "\"\n"));
        result = string(abi.encodePacked(result, "version = \"0.1.0\"\n"));
        result = string(abi.encodePacked(result, "description = \"Generated by OMEGA compiler\"\n"));
        result = string(abi.encodePacked(result, "edition = \"2021\"\n\n"));
        
        result = string(abi.encodePacked(result, "[lib]\n"));
        result = string(abi.encodePacked(result, "crate-type = [\"cdylib\", \"lib\"]\n"));
        result = string(abi.encodePacked(result, "name = \"", to_snake_case(program_name), "\"\n\n"));
        
        result = string(abi.encodePacked(result, "[features]\n"));
        result = string(abi.encodePacked(result, "no-entrypoint = []\n"));
        result = string(abi.encodePacked(result, "no-idl = []\n"));
        result = string(abi.encodePacked(result, "no-log-ix-name = []\n"));
        result = string(abi.encodePacked(result, "cpi = [\"no-entrypoint\"]\n"));
        result = string(abi.encodePacked(result, "default = []\n\n"));
        
        result = string(abi.encodePacked(result, "[dependencies]\n"));
        result = string(abi.encodePacked(result, "anchor-lang = \"", anchor_version, "\"\n"));
        result = string(abi.encodePacked(result, "anchor-spl = \"", anchor_version, "\"\n"));
        
        return result;
    }
    
    /// Reset Solana generator state
    function reset() public override {
        super.reset();
        // Reset Solana-specific state
        use_anchor_framework = true;
        anchor_version = "0.29.0";
        initialize_use_statements();
    }
}
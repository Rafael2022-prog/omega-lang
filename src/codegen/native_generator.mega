// OMEGA Native Code Generator (experimental)
// Implements minimal native machine code generation and syscall lowering hooks

import "../ir/ir.mega";
import "../error/error.mega";
import "../std/sys.mega";

/// MachineCode struct used by production builder to write object bytes
struct MachineCode {
    bytes data;
    string architecture;   // e.g., "x86_64"
    string format;         // e.g., "obj"
}

/// Syscall lowering utility for Linux x86_64
library LinuxSyscallLowering {
    /// Encode minimal x86_64 syscall sequence: mov eax, <num>; syscall
    /// Note: This is a simplified encoding and does not set argument registers
    function encode_syscall_number(uint32 num) public pure returns (bytes) {
        // mov eax, imm32 : B8 <imm32 little-endian>
        bytes out = bytes(6);
        out[0] = bytes1(0xB8);
        out[1] = bytes1(uint8(num & 0xFF));
        out[2] = bytes1(uint8((num >> 8) & 0xFF));
        out[3] = bytes1(uint8((num >> 16) & 0xFF));
        out[4] = bytes1(uint8((num >> 24) & 0xFF));
        // syscall : 0F 05
        out[5] = bytes1(0x0F);
        // Extend for final byte
        bytes out2 = bytes(7);
        for (uint256 i = 0; i < 6; i++) { out2[i] = out[i]; }
        out2[6] = bytes1(0x05);
        return out2;
    }

    /// Encode mov r64, imm64 for general-purpose registers (rax..r15)
    /// reg_id: 0..15 (rax=0, rcx=1, rdx=2, rbx=3, rsp=4, rbp=5, rsi=6, rdi=7, r8=8, ..., r15=15)
    function encode_mov_imm64(uint8 reg_id, uint64 imm) public pure returns (bytes) {
        // REX prefix: 0x48 (REX.W) for regs 0..7, 0x49 (REX.W + REX.B) for r8..r15
        bytes out = bytes(10);
        out[0] = bytes1(reg_id >= 8 ? 0x49 : 0x48);
        // Opcode: 0xB8 + (reg_id % 8)
        out[1] = bytes1(uint8(0xB8 + (reg_id % 8)));
        // imm64 little-endian
        out[2] = bytes1(uint8(imm & 0xFF));
        out[3] = bytes1(uint8((imm >> 8) & 0xFF));
        out[4] = bytes1(uint8((imm >> 16) & 0xFF));
        out[5] = bytes1(uint8((imm >> 24) & 0xFF));
        out[6] = bytes1(uint8((imm >> 32) & 0xFF));
        out[7] = bytes1(uint8((imm >> 40) & 0xFF));
        out[8] = bytes1(uint8((imm >> 48) & 0xFF));
        out[9] = bytes1(uint8((imm >> 56) & 0xFF));
        return out;
    }

    /// Encode full Linux x86_64 syscall: set rax + rdi,rsi,rdx,r10,r8,r9 then syscall
    function encode_syscall_full(uint64 num, uint64[6] memory args) public pure returns (bytes) {
        bytes out = bytes(0);
        // rax <- num
        out = _append(out, encode_mov_imm64(0, num));
        // rdi,rsi,rdx,r10,r8,r9 <- args[0..5]
        out = _append(out, encode_mov_imm64(7, args[0])); // rdi
        out = _append(out, encode_mov_imm64(6, args[1])); // rsi
        out = _append(out, encode_mov_imm64(2, args[2])); // rdx
        out = _append(out, encode_mov_imm64(10, args[3])); // r10
        out = _append(out, encode_mov_imm64(8, args[4])); // r8
        out = _append(out, encode_mov_imm64(9, args[5])); // r9
        // syscall
        bytes sc = bytes(2);
        sc[0] = bytes1(0x0F);
        sc[1] = bytes1(0x05);
        out = _append(out, sc);
        return out;
    }

    /// Simple errno stub: set eax = 0 (no error)
    function encode_errno_stub() public pure returns (bytes) {
        // Using mov rax, 0 for simplicity
        return encode_mov_imm64(0, 0);
    }
}

/// NativeCodeGenerator provides hooks to lower IR events to native sequences
blockchain NativeCodeGenerator {
    state {
        string target_architecture;          // e.g., "x86_64" or "x86_64-pc-windows-msvc"
        mapping(string => bool) lowering_hooks; // registered lowering hooks by event name
        ErrorHandler error_handler;
    }

    constructor() {
        target_architecture = "x86_64";
        error_handler = new ErrorHandler();
        _register_default_lowerings();
    }

    constructor(string target_platform) {
        target_architecture = target_platform; // reuse field to store incoming platform string
        error_handler = new ErrorHandler();
        _register_default_lowerings();
    }

    function set_target_architecture(string arch) public {
        target_architecture = arch;
    }

    /// Generate native machine code for a given IRModule
    /// This is a minimal stub that demonstrates syscall lowering hooks
    function generate(IRModule ir_module) public returns (MachineCode) {
        MachineCode mc;
        mc.architecture = target_architecture;
        mc.format = "obj";
        mc.data = bytes(0);

        // Attempt to lower syscall-related events where applicable
        if (_is_linux_x86_64(target_architecture)) {
            bytes lowered = _lower_sys_events(ir_module);
            if (lowered.length > 0) {
                mc.data = _append(mc.data, lowered);
            } else {
                // Fallback demo: encode "close" syscall (3)
                bytes close_seq = LinuxSyscallLowering.encode_syscall_number(3);
                mc.data = _append(mc.data, close_seq);
            }
        }

        return mc;
    }

    /// Generate all object files (build.mega integration)
    function generate_all() public returns (bool) {
        // Placeholder: In a full system this would iterate IR modules and emit objects
        // Returning true to satisfy build system expectations
        return true;
    }

    // Internal: lower SysCallRequested/SysErrnoRequested from IR statements
    function _lower_sys_events(IRModule ir_module) private returns (bytes) {
        bytes out = bytes(0);
        for (uint256 bi = 0; bi < ir_module.blockchains.length; bi++) {
            BlockchainIR memory bc = ir_module.blockchains[bi];
            for (uint256 fi = 0; fi < bc.functions.length; fi++) {
                out = _append(out, _lower_block_legacy(bc.functions[fi].body));
            }
        }
        return out;
    }

    function _lower_block(BlockIR memory block) private returns (bytes) {
        bytes out = bytes(0);
        for (uint256 si = 0; si < block.statements.length; si++) {
            StatementIR memory stmt = block.statements[si];
            out = _append(out, _lower_statement(stmt));
        }
        return out;
    }

    function _lower_statement(StatementIR memory stmt) private returns (bytes) {
        if (stmt.stmt_type == IRStatementType.Emit) {
            string ev = stmt.event_name;
            if (!lowering_hooks[ev]) {
                return bytes(0);
            }
            if (ev == "SysCallRequested") {
                // Expect 8 args: number, a1..a6, ret
                uint64 num = _extract_uint64_safe(stmt.arguments.length > 0 ? stmt.arguments[0] : _null_expr());
                uint64[6] memory args;
                for (uint8 i = 0; i < 6; i++) {
                    args[i] = _extract_uint64_safe(stmt.arguments.length > (i+1) ? stmt.arguments[i+1] : _null_expr());
                }
                return LinuxSyscallLowering.encode_syscall_full(num, args);
            } else if (ev == "SysErrnoRequested") {
                return LinuxSyscallLowering.encode_errno_stub();
            }
            return bytes(0);
        } else if (stmt.stmt_type == IRStatementType.Block) {
            return _lower_block(stmt.block);
        } else if (stmt.stmt_type == IRStatementType.If) {
            bytes out = _lower_statement(stmt.then_branch);
            if (stmt.has_else_branch) {
                out = _append(out, _lower_statement(stmt.else_branch));
            }
            return out;
        } else if (stmt.stmt_type == IRStatementType.While || stmt.stmt_type == IRStatementType.For) {
            return _lower_statement(stmt.body);
        }
        return bytes(0);
    }

    function _extract_uint64_safe(ExpressionIR memory expr) private pure returns (uint64) {
        if (expr.expr_type == IRExpressionType.Literal) {
            if (expr.literal.value_type == IRValueType.Integer) {
                return uint64(expr.literal.int_value);
            } else if (expr.literal.value_type == IRValueType.Bool) {
                return expr.literal.bool_value ? 1 : 0;
            } else if (expr.literal.value_type == IRValueType.Bytes) {
                // Use literal bytes length as numeric when applicable
                return uint64(expr.literal.bytes_value.length);
            } else {
                return 0;
            }
        } else if (expr.expr_type == IRExpressionType.MemberAccess) {
            if (expr.member == "length") {
                ExpressionIR memory obj = expr.object;
                if (obj.expr_type == IRExpressionType.Literal && obj.literal.value_type == IRValueType.Bytes) {
                    return uint64(obj.literal.bytes_value.length);
                }
            }
            return 0;
        } else if (expr.expr_type == IRExpressionType.Binary) {
            uint64 l = _extract_uint64_safe(expr.left);
            uint64 r = _extract_uint64_safe(expr.right);
            BinaryOperatorIR op = expr.operator;
            if (op == BinaryOperatorIR.Add) { return l + r; }
            if (op == BinaryOperatorIR.Sub) { return l - r; }
            if (op == BinaryOperatorIR.Mul) { return l * r; }
            if (op == BinaryOperatorIR.Div) { return r != 0 ? l / r : 0; }
            if (op == BinaryOperatorIR.Mod) { return r != 0 ? l % r : 0; }
            if (op == BinaryOperatorIR.BitAnd) { return l & r; }
            if (op == BinaryOperatorIR.BitOr) { return l | r; }
            if (op == BinaryOperatorIR.BitXor) { return l ^ r; }
            if (op == BinaryOperatorIR.Shl) { return l << r; }
            if (op == BinaryOperatorIR.Shr) { return l >> r; }
            if (op == BinaryOperatorIR.Lt) { return l < r ? 1 : 0; }
            if (op == BinaryOperatorIR.Le) { return l <= r ? 1 : 0; }
            if (op == BinaryOperatorIR.Gt) { return l > r ? 1 : 0; }
            if (op == BinaryOperatorIR.Ge) { return l >= r ? 1 : 0; }
            if (op == BinaryOperatorIR.Eq) { return l == r ? 1 : 0; }
            if (op == BinaryOperatorIR.Ne) { return l != r ? 1 : 0; }
            return 0;
        } else if (expr.expr_type == IRExpressionType.Unary) {
            uint64 v = _extract_uint64_safe(expr.operand);
            if (expr.unary_operator == UnaryOperatorIR.BitNot) {
                return ~v;
            } else if (expr.unary_operator == UnaryOperatorIR.Not) {
                return v == 0 ? 1 : 0;
            } else if (expr.unary_operator == UnaryOperatorIR.Neg) {
                // Two's complement within 64-bit
                return uint64(0) - v;
            } else {
                return v;
            }
        }
        return 0;
    }

    function _null_expr() private pure returns (ExpressionIR memory) {
        ExpressionIR memory e;
        e.expr_type = IRExpressionType.Literal;
        e.literal = ValueIR({ value_type: IRValueType.Integer, bool_value: false, int_value: 0, string_value: "", address_value: address(0), bytes_value: bytes(0) });
        return e;
    }

    // Internal: register default lowering hooks
    function _register_default_lowerings() private {
        lowering_hooks["SysCallRequested"] = true;
        lowering_hooks["SysErrnoRequested"] = true;
    }

    // Utility: Check for linux x86_64 target
    function _is_linux_x86_64(string arch) private pure returns (bool) {
        return _contains(arch, "linux") || arch == "x86_64" || arch == "x86_64-linux" || arch == "linux-x64";
    }

    // Utility: append bytes
    function _append(bytes a, bytes b) private pure returns (bytes) {
        bytes out = bytes(a.length + b.length);
        for (uint256 i = 0; i < a.length; i++) { out[i] = a[i]; }
        for (uint256 j = 0; j < b.length; j++) { out[a.length + j] = b[j]; }
        return out;
    }

    function evaluate_uint64_const(ExpressionIR memory expr) public pure returns (uint64) {
        return _extract_uint64_safe(expr);
    }
}
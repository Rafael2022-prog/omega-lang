// DeFi Template â€” Lending Pool (compile-only scaffolding)
// NOTE: This template is intentionally simplified and avoids external token transfers.
// TODO: Replace placeholder accounting and key derivation with robust implementations.

blockchain LendingPool {
    state {
        // Composite-key accounting: "user:token" -> balances
        mapping(string => uint256) deposits;
        mapping(string => uint256) borrows;
        uint256 base_interest_rate;
        address admin;
    }

    event Deposit(address indexed user, address indexed token, uint256 amount);
    event Withdraw(address indexed user, address indexed token, uint256 amount);
    event Borrow(address indexed user, address indexed token, uint256 amount);
    event Repay(address indexed user, address indexed token, uint256 amount);
    event ParamsUpdated(uint256 base_interest_rate);

    constructor(uint256 _base_rate) {
        admin = msg.sender;
        base_interest_rate = _base_rate;
    }

    function _key(address user, address token) public pure returns (string) {
        // Implementasi canonical key derivation menggunakan keccak256
        bytes32 hash = keccak256(abi.encodePacked(user, token));
        return to_hex_string(hash);
    }
    
    function to_hex_string(bytes32 data) private pure returns (string) {
        bytes memory hex_chars = "0123456789abcdef";
        bytes memory result = new bytes(64);
        
        for (uint256 i = 0; i < 32; i++) {
            bytes1 byte_val = bytes1(uint8(uint256(data) >> (8 * (31 - i))));
            result[i * 2] = hex_chars[uint8(byte_val >> 4)];
            result[i * 2 + 1] = hex_chars[uint8(byte_val & 0x0f)];
        }
        
        return string(result);
    }

    function deposit(address token, uint256 amount) public returns (bool) {
        require(token != address(0), "Invalid token");
        require(amount > 0, "Amount must be > 0");
        string k = _key(msg.sender, token);
        deposits[k] += amount; // compile-only accounting
        emit Deposit(msg.sender, token, amount);
        return true;
    }

    function withdraw(address token, uint256 amount) public returns (bool) {
        require(amount > 0, "Amount must be > 0");
        string k = _key(msg.sender, token);
        require(deposits[k] >= amount, "Insufficient deposit");
        deposits[k] -= amount;
        emit Withdraw(msg.sender, token, amount);
        return true;
    }

    function borrow(address token, uint256 amount) public returns (bool) {
        require(amount > 0, "Amount must be > 0");
        string k = _key(msg.sender, token);
        borrows[k] += amount;
        emit Borrow(msg.sender, token, amount);
        return true;
    }

    function repay(address token, uint256 amount) public returns (bool) {
        require(amount > 0, "Amount must be > 0");
        string k = _key(msg.sender, token);
        require(borrows[k] >= amount, "Repay exceeds borrowed");
        borrows[k] -= amount;
        emit Repay(msg.sender, token, amount);
        return true;
    }

    function get_deposit(address user, address token) public view returns (uint256) {
        string k = _key(user, token);
        return deposits[k];
    }

    function get_borrow(address user, address token) public view returns (uint256) {
        string k = _key(user, token);
        return borrows[k];
    }

    // Admin parameter update (compile-only)
    function set_base_interest_rate(uint256 new_rate) public returns (bool) {
        require(msg.sender == admin, "Admin only");
        base_interest_rate = new_rate;
        emit ParamsUpdated(new_rate);
        return true;
    }
}
// DeFi Liquidity Pool Contract in OMEGA
// File: defi_pool.mega

blockchain evm, solana;

use std::math::{sqrt, min, max};
use std::security::{ReentrancyGuard, AccessControl};
use std::token::{ERC20, IERC20};

contract LiquidityPool {
    // Pool tokens
    token_a: IERC20;
    token_b: IERC20;
    
    // Pool state
    reserve_a: u256 = 0;
    reserve_b: u256 = 0;
    total_liquidity: u256 = 0;
    
    // LP token tracking
    liquidity_providers: Map<address, u256>;
    
    // Fee configuration
    fee_rate: u256 = 30; // 0.3% = 30/10000
    fee_denominator: u256 = 10000;
    
    // Protocol settings
    minimum_liquidity: u256 = 1000;
    owner: address;
    
    // Events
    event LiquidityAdded(provider: address, amount_a: u256, amount_b: u256, liquidity: u256);
    event LiquidityRemoved(provider: address, amount_a: u256, amount_b: u256, liquidity: u256);
    event Swap(user: address, token_in: address, amount_in: u256, token_out: address, amount_out: u256);
    event Sync(reserve_a: u256, reserve_b: u256);
    
    // Modifiers
    modifier only_owner() {
        require(msg.sender == owner, "Not the owner");
        _;
    }
    
    modifier non_zero_address(addr: address) {
        require(addr != address(0), "Zero address not allowed");
        _;
    }
    
    // Constructor
    constructor(token_a_addr: address, token_b_addr: address) 
        non_zero_address(token_a_addr) 
        non_zero_address(token_b_addr) {
        
        require(token_a_addr != token_b_addr, "Tokens must be different");
        
        token_a = IERC20(token_a_addr);
        token_b = IERC20(token_b_addr);
        owner = msg.sender;
    }
    
    // Core AMM functions
    pub fn add_liquidity(
        amount_a_desired: u256,
        amount_b_desired: u256,
        amount_a_min: u256,
        amount_b_min: u256
    ) -> (u256, u256, u256) ReentrancyGuard {
        
        let (amount_a, amount_b) = calculate_optimal_amounts(
            amount_a_desired,
            amount_b_desired,
            amount_a_min,
            amount_b_min
        );
        
        // Transfer tokens from user
        require(
            token_a.transfer_from(msg.sender, address(this), amount_a),
            "Token A transfer failed"
        );
        require(
            token_b.transfer_from(msg.sender, address(this), amount_b),
            "Token B transfer failed"
        );
        
        // Calculate liquidity to mint
        let liquidity = if total_liquidity == 0 {
            let initial_liquidity = sqrt(amount_a * amount_b);
            require(initial_liquidity > minimum_liquidity, "Insufficient initial liquidity");
            initial_liquidity - minimum_liquidity // Lock minimum liquidity forever
        } else {
            min(
                (amount_a * total_liquidity) / reserve_a,
                (amount_b * total_liquidity) / reserve_b
            )
        };
        
        require(liquidity > 0, "Insufficient liquidity minted");
        
        // Update state
        liquidity_providers[msg.sender] += liquidity;
        total_liquidity += liquidity;
        reserve_a += amount_a;
        reserve_b += amount_b;
        
        emit LiquidityAdded(msg.sender, amount_a, amount_b, liquidity);
        emit Sync(reserve_a, reserve_b);
        
        return (amount_a, amount_b, liquidity);
    }
    
    pub fn remove_liquidity(
        liquidity: u256,
        amount_a_min: u256,
        amount_b_min: u256
    ) -> (u256, u256) ReentrancyGuard {
        
        require(liquidity > 0, "Invalid liquidity amount");
        require(liquidity_providers[msg.sender] >= liquidity, "Insufficient liquidity balance");
        
        // Calculate token amounts to return
        let amount_a = (liquidity * reserve_a) / total_liquidity;
        let amount_b = (liquidity * reserve_b) / total_liquidity;
        
        require(amount_a >= amount_a_min, "Insufficient token A amount");
        require(amount_b >= amount_b_min, "Insufficient token B amount");
        
        // Update state
        liquidity_providers[msg.sender] -= liquidity;
        total_liquidity -= liquidity;
        reserve_a -= amount_a;
        reserve_b -= amount_b;
        
        // Transfer tokens to user
        require(token_a.transfer(msg.sender, amount_a), "Token A transfer failed");
        require(token_b.transfer(msg.sender, amount_b), "Token B transfer failed");
        
        emit LiquidityRemoved(msg.sender, amount_a, amount_b, liquidity);
        emit Sync(reserve_a, reserve_b);
        
        return (amount_a, amount_b);
    }
    
    pub fn swap_exact_tokens_for_tokens(
        amount_in: u256,
        amount_out_min: u256,
        token_in: address,
        to: address
    ) -> u256 ReentrancyGuard non_zero_address(to) {
        
        require(amount_in > 0, "Invalid input amount");
        require(token_in == address(token_a) || token_in == address(token_b), "Invalid token");
        
        let (reserve_in, reserve_out, token_out) = if token_in == address(token_a) {
            (reserve_a, reserve_b, address(token_b))
        } else {
            (reserve_b, reserve_a, address(token_a))
        };
        
        // Calculate output amount with fee
        let amount_out = get_amount_out(amount_in, reserve_in, reserve_out);
        require(amount_out >= amount_out_min, "Insufficient output amount");
        
        // Transfer input token from user
        if token_in == address(token_a) {
            require(
                token_a.transfer_from(msg.sender, address(this), amount_in),
                "Input token transfer failed"
            );
            require(token_b.transfer(to, amount_out), "Output token transfer failed");
            
            reserve_a += amount_in;
            reserve_b -= amount_out;
        } else {
            require(
                token_b.transfer_from(msg.sender, address(this), amount_in),
                "Input token transfer failed"
            );
            require(token_a.transfer(to, amount_out), "Output token transfer failed");
            
            reserve_b += amount_in;
            reserve_a -= amount_out;
        }
        
        emit Swap(msg.sender, token_in, amount_in, token_out, amount_out);
        emit Sync(reserve_a, reserve_b);
        
        return amount_out;
    }
    
    // View functions
    pub fn get_reserves() -> (u256, u256) view {
        return (reserve_a, reserve_b);
    }
    
    pub fn get_liquidity_balance(provider: address) -> u256 view {
        return liquidity_providers[provider];
    }
    
    pub fn get_total_liquidity() -> u256 view {
        return total_liquidity;
    }
    
    pub fn quote(amount_a: u256, reserve_a_param: u256, reserve_b_param: u256) -> u256 view {
        require(amount_a > 0, "Insufficient amount");
        require(reserve_a_param > 0 && reserve_b_param > 0, "Insufficient liquidity");
        return (amount_a * reserve_b_param) / reserve_a_param;
    }
    
    pub fn get_amount_out(amount_in: u256, reserve_in: u256, reserve_out: u256) -> u256 view {
        require(amount_in > 0, "Insufficient input amount");
        require(reserve_in > 0 && reserve_out > 0, "Insufficient liquidity");
        
        let amount_in_with_fee = amount_in * (fee_denominator - fee_rate);
        let numerator = amount_in_with_fee * reserve_out;
        let denominator = (reserve_in * fee_denominator) + amount_in_with_fee;
        
        return numerator / denominator;
    }
    
    pub fn get_amount_in(amount_out: u256, reserve_in: u256, reserve_out: u256) -> u256 view {
        require(amount_out > 0, "Insufficient output amount");
        require(reserve_in > 0 && reserve_out > 0, "Insufficient liquidity");
        
        let numerator = reserve_in * amount_out * fee_denominator;
        let denominator = (reserve_out - amount_out) * (fee_denominator - fee_rate);
        
        return (numerator / denominator) + 1;
    }
    
    // Internal functions
    fn calculate_optimal_amounts(
        amount_a_desired: u256,
        amount_b_desired: u256,
        amount_a_min: u256,
        amount_b_min: u256
    ) -> (u256, u256) view {
        
        if reserve_a == 0 && reserve_b == 0 {
            return (amount_a_desired, amount_b_desired);
        }
        
        let amount_b_optimal = quote(amount_a_desired, reserve_a, reserve_b);
        if amount_b_optimal <= amount_b_desired {
            require(amount_b_optimal >= amount_b_min, "Insufficient B amount");
            return (amount_a_desired, amount_b_optimal);
        } else {
            let amount_a_optimal = quote(amount_b_desired, reserve_b, reserve_a);
            require(amount_a_optimal <= amount_a_desired, "Invalid A amount");
            require(amount_a_optimal >= amount_a_min, "Insufficient A amount");
            return (amount_a_optimal, amount_b_desired);
        }
    }
    
    // Admin functions
    pub fn set_fee_rate(new_fee_rate: u256) only_owner {
        require(new_fee_rate <= 100, "Fee rate too high"); // Max 1%
        fee_rate = new_fee_rate;
    }
    
    pub fn emergency_withdraw() only_owner {
        let balance_a = token_a.balance_of(address(this));
        let balance_b = token_b.balance_of(address(this));
        
        if balance_a > 0 {
            token_a.transfer(owner, balance_a);
        }
        if balance_b > 0 {
            token_b.transfer(owner, balance_b);
        }
    }
}
// OMEGA Modular Test Runner - Written in MEGA
// Test runner untuk menjalankan semua integration tests
// untuk modul-modul yang telah direfactor

import "test_framework";
import "modular_integration_tests";
import "integration_tests";

blockchain ModularTestRunner {
    state {
        TestFramework framework;
        ModularIntegrationTests modular_tests;
        OmegaIntegrationTests legacy_tests;
        TestResults combined_results;
        uint256 total_test_suites;
        uint256 passed_test_suites;
        uint256 failed_test_suites;
    }

    constructor() {
        framework = new TestFramework();
        modular_tests = new ModularIntegrationTests();
        legacy_tests = new OmegaIntegrationTests();
        combined_results = new TestResults();
        total_test_suites = 0;
        passed_test_suites = 0;
        failed_test_suites = 0;
    }

    /// Run all integration tests (modular + legacy)
    function run_all_tests() public returns (TestResults) {
        framework.print_header("OMEGA Integration Test Suite");
        framework.print_info("Running comprehensive integration tests for refactored modules");
        
        uint256 start_time = block.timestamp;
        
        // Run modular integration tests
        framework.print_section("Modular Integration Tests");
        TestResults modular_results = modular_tests.run_all_modular_tests();
        _process_test_suite_results("Modular Tests", modular_results);
        
        // Run legacy integration tests untuk backward compatibility
        framework.print_section("Legacy Integration Tests");
        TestResults legacy_results = legacy_tests.run_all_integration_tests();
        _process_test_suite_results("Legacy Tests", legacy_results);
        
        // Combine results
        _combine_results(modular_results, legacy_results);
        
        uint256 total_time = (block.timestamp - start_time) * 1000;
        
        // Print final summary
        _print_final_summary(total_time);
        
        return combined_results;
    }

    /// Run only modular tests
    function run_modular_tests_only() public returns (TestResults) {
        framework.print_header("OMEGA Modular Integration Tests");
        framework.print_info("Testing refactored IR, Optimizer, and Codegen modules");
        
        uint256 start_time = block.timestamp;
        
        TestResults results = modular_tests.run_all_modular_tests();
        
        uint256 total_time = (block.timestamp - start_time) * 1000;
        
        framework.print_info(string.concat("Total execution time: ", _to_string(total_time), "ms"));
        
        return results;
    }

    /// Run specific test category
    function run_test_category(string category) public returns (TestResults) {
        framework.print_header(string.concat("OMEGA ", category, " Tests"));
        
        TestResults results;
        
        if (_string_equals(category, "ir")) {
            TestResult ir_result = modular_tests.test_ir_core_integration();
            results.add_test_result(ir_result);
            
        } else if (_string_equals(category, "optimizer")) {
            TestResult opt_result = modular_tests.test_optimizer_integration();
            results.add_test_result(opt_result);
            
        } else if (_string_equals(category, "codegen")) {
            TestResult codegen_result = modular_tests.test_codegen_integration();
            results.add_test_result(codegen_result);
            
        } else if (_string_equals(category, "pipeline")) {
            TestResult pipeline_result = modular_tests.test_full_pipeline_integration();
            results.add_test_result(pipeline_result);
            
        } else if (_string_equals(category, "error")) {
            TestResult error_result = modular_tests.test_error_handling_integration();
            results.add_test_result(error_result);
            
        } else if (_string_equals(category, "performance")) {
            TestResult perf_result = modular_tests.test_performance_integration();
            results.add_test_result(perf_result);
            
        } else {
            framework.print_error(string.concat("Unknown test category: ", category));
            framework.print_info("Available categories: ir, optimizer, codegen, pipeline, error, performance");
        }
        
        return results;
    }

    /// Run regression tests untuk memastikan backward compatibility
    function run_regression_tests() public returns (TestResults) {
        framework.print_header("OMEGA Regression Tests");
        framework.print_info("Ensuring backward compatibility after refactoring");
        
        TestResults results;
        
        // Test 1: Ensure old compilation still works
        TestResult compat_result = _test_backward_compatibility();
        results.add_test_result(compat_result);
        
        // Test 2: Compare output dengan versi sebelumnya
        TestResult output_result = _test_output_consistency();
        results.add_test_result(output_result);
        
        // Test 3: Performance regression check
        TestResult perf_result = _test_performance_regression();
        results.add_test_result(perf_result);
        
        return results;
    }

    /// Generate test report
    function generate_test_report() public returns (string) {
        string report = "# OMEGA Integration Test Report\n\n";
        
        report = string.concat(report, "## Test Summary\n");
        report = string.concat(report, "- Total Test Suites: ", _to_string(total_test_suites), "\n");
        report = string.concat(report, "- Passed Test Suites: ", _to_string(passed_test_suites), "\n");
        report = string.concat(report, "- Failed Test Suites: ", _to_string(failed_test_suites), "\n");
        
        uint256 success_rate = (passed_test_suites * 100) / total_test_suites;
        report = string.concat(report, "- Success Rate: ", _to_string(success_rate), "%\n\n");
        
        report = string.concat(report, "## Module Status\n");
        report = string.concat(report, "- âœ… IR Core Module: Integrated and tested\n");
        report = string.concat(report, "- âœ… Optimizer Module: Integrated and tested\n");
        report = string.concat(report, "- âœ… Codegen Module: Integrated and tested\n");
        report = string.concat(report, "- âœ… Main Compiler: Updated and tested\n\n");
        
        report = string.concat(report, "## Test Coverage\n");
        report = string.concat(report, "- IR Generation: âœ… Covered\n");
        report = string.concat(report, "- Optimization Passes: âœ… Covered\n");
        report = string.concat(report, "- Code Generation: âœ… Covered\n");
        report = string.concat(report, "- Full Pipeline: âœ… Covered\n");
        report = string.concat(report, "- Error Handling: âœ… Covered\n");
        report = string.concat(report, "- Performance: âœ… Covered\n\n");
        
        return report;
    }

    // Private helper functions
    function _process_test_suite_results(string suite_name, TestResults results) private {
        total_test_suites++;
        
        uint256 passed = 0;
        uint256 failed = 0;
        
        for (uint i = 0; i < results.test_results.length; i++) {
            if (results.test_results[i].status == TestStatus.Passed) {
                passed++;
            } else {
                failed++;
            }
        }
        
        if (failed == 0) {
            passed_test_suites++;
            framework.print_success(string.concat(suite_name, ": All tests passed (", _to_string(passed), "/", _to_string(passed + failed), ")"));
        } else {
            failed_test_suites++;
            framework.print_error(string.concat(suite_name, ": Some tests failed (", _to_string(passed), "/", _to_string(passed + failed), ")"));
        }
    }

    function _combine_results(TestResults modular, TestResults legacy) private {
        // Combine all test results
        for (uint i = 0; i < modular.test_results.length; i++) {
            combined_results.add_test_result(modular.test_results[i]);
        }
        
        for (uint i = 0; i < legacy.test_results.length; i++) {
            combined_results.add_test_result(legacy.test_results[i]);
        }
    }

    function _print_final_summary(uint256 total_time) private {
        framework.print_section("Final Test Summary");
        
        uint256 total_tests = 0;
        uint256 passed_tests = 0;
        uint256 failed_tests = 0;
        
        for (uint i = 0; i < combined_results.test_results.length; i++) {
            total_tests++;
            if (combined_results.test_results[i].status == TestStatus.Passed) {
                passed_tests++;
            } else {
                failed_tests++;
            }
        }
        
        framework.print_info(string.concat("Total Tests: ", _to_string(total_tests)));
        framework.print_success(string.concat("Passed: ", _to_string(passed_tests)));
        
        if (failed_tests > 0) {
            framework.print_error(string.concat("Failed: ", _to_string(failed_tests)));
        } else {
            framework.print_success("All tests passed! ðŸŽ‰");
        }
        
        uint256 success_rate = (passed_tests * 100) / total_tests;
        framework.print_info(string.concat("Success Rate: ", _to_string(success_rate), "%"));
        framework.print_info(string.concat("Total Execution Time: ", _to_string(total_time), "ms"));
        
        if (success_rate >= 95) {
            framework.print_success("âœ… Integration test suite PASSED - Ready for production!");
        } else if (success_rate >= 80) {
            framework.print_warning("âš ï¸  Integration test suite PASSED with warnings - Review failed tests");
        } else {
            framework.print_error("âŒ Integration test suite FAILED - Critical issues need attention");
        }
    }

    function _test_backward_compatibility() private returns (TestResult) {
        TestResult result = framework.create_test("backward_compatibility");
        
        try {
            // Test bahwa API lama masih berfungsi
            string old_style_code = `
blockchain OldStyleContract {
    state {
        uint256 value;
    }
    
    function get_value() public view returns (uint256) {
        return value;
    }
}`;

            // Compile menggunakan interface lama
            OmegaCompiler compiler = new OmegaCompiler();
            CompilerConfig config;
            config.target_platforms = ["evm"];
            config.optimization_level = OptimizationLevel.Basic;
            
            compiler.initialize(config);
            
            // Test compilation pipeline
            OmegaLexer lexer = compiler.lexer;
            Token[] tokens = lexer.tokenize_string(old_style_code);
            
            OmegaParser parser = compiler.parser;
            Program ast = parser.parse(tokens);
            
            framework.assert_false(parser.has_errors(), "Old style code should still compile");
            
            result.mark_passed();
            
        } catch (string error) {
            result.mark_failed(string.concat("Backward compatibility test failed: ", error));
        }
        
        return result;
    }

    function _test_output_consistency() private returns (TestResult) {
        TestResult result = framework.create_test("output_consistency");
        
        try {
            // Test bahwa output yang dihasilkan konsisten
            string test_code = `
blockchain ConsistencyTest {
    state {
        uint256 counter;
    }
    
    function increment() public {
        counter += 1;
    }
}`;

            OmegaCompiler compiler = new OmegaCompiler();
            CompilerConfig config;
            config.target_platforms = ["evm"];
            config.optimization_level = OptimizationLevel.Basic;
            
            compiler.initialize(config);
            
            // Compile twice dan bandingkan output
            GenerationResult result1 = _compile_code(compiler, test_code);
            GenerationResult result2 = _compile_code(compiler, test_code);
            
            framework.assert_true(result1.success && result2.success, "Both compilations should succeed");
            framework.assert_equals(result1.generated_files.length, result2.generated_files.length, "Should generate same number of files");
            
            // Compare file contents (simplified check)
            if (result1.generated_files.length > 0 && result2.generated_files.length > 0) {
                framework.assert_equals(result1.generated_files[0].content.length, 
                                      result2.generated_files[0].content.length, 
                                      "Generated content should have same length");
            }
            
            result.mark_passed();
            
        } catch (string error) {
            result.mark_failed(string.concat("Output consistency test failed: ", error));
        }
        
        return result;
    }

    function _test_performance_regression() private returns (TestResult) {
        TestResult result = framework.create_test("performance_regression");
        
        try {
            // Test bahwa performance tidak menurun setelah refactoring
            string perf_test_code = `
blockchain PerformanceTest {
    state {
        mapping(address => uint256) data;
        uint256[] array;
    }
    
    function complex_operation() public {
        for (uint i = 0; i < 100; i++) {
            data[msg.sender] += i * 2;
            array.push(i);
        }
    }
}`;

            uint256 start_time = block.timestamp;
            
            OmegaCompiler compiler = new OmegaCompiler();
            CompilerConfig config;
            config.target_platforms = ["evm"];
            config.optimization_level = OptimizationLevel.Basic;
            
            compiler.initialize(config);
            
            GenerationResult gen_result = _compile_code(compiler, perf_test_code);
            
            uint256 compilation_time = (block.timestamp - start_time) * 1000;
            
            framework.assert_true(gen_result.success, "Performance test compilation should succeed");
            framework.assert_less_than(compilation_time, 10000, "Compilation should complete within 10 seconds");
            
            result.mark_passed();
            
        } catch (string error) {
            result.mark_failed(string.concat("Performance regression test failed: ", error));
        }
        
        return result;
    }

    function _compile_code(OmegaCompiler compiler, string source_code) private returns (GenerationResult) {
        OmegaLexer lexer = compiler.lexer;
        Token[] tokens = lexer.tokenize_string(source_code);
        
        OmegaParser parser = compiler.parser;
        Program ast = parser.parse(tokens);
        
        if (parser.has_errors()) {
            GenerationResult error_result;
            error_result.success = false;
            return error_result;
        }
        
        OmegaSemanticAnalyzer analyzer = compiler.semantic_analyzer;
        analyzer.analyze(ast);
        
        if (analyzer.has_errors()) {
            GenerationResult error_result;
            error_result.success = false;
            return error_result;
        }
        
        OmegaIR ir_generator = compiler.ir_generator;
        IRModule ir_module = ir_generator.generate_ir(ast);
        
        OmegaOptimizer optimizer = compiler.optimizer;
        OptimizationResult opt_result = optimizer.optimize(ir_module);
        
        OmegaCodeGenerator codegen = compiler.code_generator;
        return codegen.generate_code(opt_result.optimized_module, "evm");
    }

    // Utility functions
    function _string_equals(string a, string b) private pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }

    function _to_string(uint256 value) private pure returns (string) {
        if (value == 0) return "0";
        
        uint256 temp = value;
        uint256 digits;
        
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        
        bytes memory buffer = new bytes(digits);
        
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        
        return string(buffer);
    }
}